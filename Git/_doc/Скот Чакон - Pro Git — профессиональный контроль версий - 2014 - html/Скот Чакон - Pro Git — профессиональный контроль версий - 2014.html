<html><body><head><title>Pro Git — профессиональный контроль версий</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /></head><div id="calibre_link-0">
<p align="center"><img src="cover.png"></p>
	

<h1>Pro Git — профессиональный контроль версий</h1>
<h0>Скот Чакон<h0>
<br></br>


	<p id="calibre_link-1"><span><span><b>Введение</b></span></span></p>
<p>Эта глава о том, как начать работу с Git'ом. Сначала мы расскажем о происхождении инструментов для контроля версий, затем &mdash; как установить и запустить Git на вашей машине и наконец, как настроить его так, чтоб можно было приступить к работе. К концу этой главы вы будете понимать, зачем Git вообще сделан, почему вам стоит им пользоваться, и будете готовы начать с ним работать.</p>
<div></div><p id="calibre_link-2"><span><span><b>О контроле версий</b></span></span></p>
<p>Что такое контроль версий, и зачем он вам нужен? Система контроля версий (СКВ) &mdash; это система, регистрирующая изменения в одном или нескольких файлах с тем, чтобы в дальнейшем была возможность вернуться к определённым старым версиям этих файлов. Для примеров в этой книге мы будем использовать исходные коды программ, но на самом деле под версионный контроль можно поместить файлы практически любого типа.</p>
<p>Если вы графический или веб-дизайнер и хотели бы хранить каждую версию изображения или макета &mdash; а этого вам наверняка хочется &mdash; то пользоваться системой контроля версий будет очень мудрым решением. СКВ даёт возможность возвращать отдельные файлы к прежнему виду, возвращать к прежнему состоянию весь проект, просматривать происходящие со временем изменения, определять, кто последним вносил изменения во внезапно переставший работать модуль, кто и когда внёс в код какую-то ошибку, и многое другое. Вообще, если, пользуясь СКВ, вы всё испортите или потеряете файлы, всё можно будет легко восстановить. Вдобавок, накладные расходы за всё, что вы получаете, будут очень маленькими.</p>
<p id="calibre_link-3"><span><span><b>Локальные системы контроля версий</b></span></span></p>
<p>Многие предпочитают контролировать версии, просто копируя файлы в другой каталог (как правило добавляя текущую дату к названию каталога). Такой подход очень распространён, потому что прост, но он и чаще даёт сбои. Очень легко забыть, что ты не в том каталоге, и случайно изменить не тот файл, либо скопировать файлы не туда, куда хотел, и затереть нужные файлы.</p>
<p>Чтобы решить эту проблему, программисты уже давно разработали локальные СКВ с простой базой данных, в которой хранятся все изменения нужных файлов (см. рисунок 1-1).</p>
<p><img src="images/000004.jpg"></img></p>
<p>Одной из наиболее популярных СКВ такого типа является rcs, которая до сих пор устанавливается на многие компьютеры. Даже в современной операционной системе Mac OS X утилита rcs устанавливается вместе с Developer Tools. Эта утилита основана на работе с наборами патчей между парами версий (патч &mdash; файл, описывающий различие между файлами), которые хранятся в специальном формате на диске. Это позволяет пересоздать любой файл на любой момент времени, последовательно накладывая патчи.</p>
<p id="calibre_link-4"><span><span><b>Централизованные системы контроля версий</b></span></span></p>
<p>Следующей основной проблемой оказалась необходимость сотрудничать с разработчиками за другими компьютерами. Чтобы решить её, были созданы централизованные системы контроля версий (ЦСКВ). В таких системах, например CVS, Subversion и Perforce, есть центральный сервер, на котором хранятся все файлы под версионным контролем, и ряд клиентов, которые получают копии файлов из него. Много лет это было стандартом для систем контроля версий (см. рис. 1-2).</p>
<p><img src="images/000056.jpg"></img></p>
<p>Такой подход имеет множество преимуществ, особенно над локальными СКВ. К примеру, все знают, кто и чем занимается в проекте. У администраторов есть чёткий контроль над тем, кто и что может делать, и, конечно, администрировать ЦСКВ намного легче, чем локальные базы на каждом клиенте.</p>
<p>Однако при таком подходе есть и несколько серьёзных недостатков. Наиболее очевидный &mdash; централизованный сервер является уязвимым местом всей системы. Если сервер выключается на час, то в течение часа разработчики не могут взаимодействовать, и никто не может сохранить новой версии своей работы. Если же повреждается диск с центральной базой данных и нет резервной копии, вы теряете абсолютно всё &mdash; всю историю проекта, разве что за исключением нескольких рабочих версий, сохранившихся на рабочих машинах пользователей. Локальные системы контроля версий подвержены той же проблеме: если вся история проекта хранится в одном месте, вы рискуете потерять всё.</p>
<p id="calibre_link-5"><span><span><b>Распределённые системы контроля версий</b></span></span></p>
<p>И в этой ситуации в игру вступают распределённые системы контроля версий (РСКВ). В таких системах как Git, Mercurial, Bazaar или Darcs клиенты не просто выгружают последние версии файлов, а полностью копируют весь репозиторий. Поэтому в случае, когда "умирает" сервер, через который шла работа, любой клиентский репозиторий может быть скопирован обратно на сервер, чтобы восстановить базу данных. Каждый раз, когда клиент забирает свежую версию файлов, он создаёт себе полную копию всех данных (см. рисунок 1-3).</p>
<p><img src="images/000073.jpg"></img></p>
<p>Кроме того, в большей части этих систем можно работать с несколькими удалёнными репозиториями, таким образом, можно одновременно работать по-разному с разными группами людей в рамках одного проекта. Так, в одном проекте можно одновременно вести несколько типов рабочих процессов, что невозможно в централизованных системах.</p>
<div></div><p id="calibre_link-6"><span><span><b>Краткая история Git</b></span></span></p>
<p>Как и многие замечательные вещи, Git начинался с, в некотором роде, разрушения во имя созидания и жарких споров. Ядро Linux &mdash; действительно очень большой открытый проект. Бо́льшую часть существования ядра Linux (1991-2002) изменения к нему распространялись в виде патчей и заархивированных файлов. В 2002 году проект перешёл на проприетарную РСКВ BitKeeper.</p>
<p>В 2005 году отношения между сообществом разработчиков ядра Linux и компанией, разрабатывавшей BitKeeper, испортились, и право бесплатного пользования продуктом было отменено. Это подтолкнуло разработчиков Linux (и в частности Линуса Торвальдса, создателя Linux) разработать собственную систему, основываясь на опыте, полученном за время использования BitKeeper. Основные требования к новой системе были следующими:</p>
<div>&nbsp;</div><ul><li value="1">Скорость</li><li value="2">Простота дизайна</li><li value="3">Поддержка нелинейной разработки (тысячи параллельных веток)</li><li value="4">Полная распределённость</li><li value="5">Возможность эффективной работы с такими большими проектами, как ядро Linux (как по скорости, так и по размеру данных)</li></ul><p>С момента рождения в 2005 году Git развивался и эволюционировал, становясь проще и удобнее в использовании, сохраняя при этом свои первоначальные качества. Он невероятно быстр, очень эффективен для больших проектов, а также обладает превосходной системой ветвления для нелинейной разработки (см. главу 3).</p>
<div></div><p id="calibre_link-7"><span><span><b>Основы Git</b></span></span></p>
<p>Так что же такое Git в двух словах? Эту часть важно усвоить, поскольку если вы поймёте, что такое Git, и каковы принципы его работы, вам будет гораздо проще пользоваться им эффективно. Изучая Git, постарайтесь освободиться от всего, что вы знали о других СКВ, таких как Subversion или Perforce. В Git'е совсем не такие понятия об информации и работе с ней как в других системах, хотя пользовательский интерфейс очень похож. Знание этих различий защитит вас от путаницы при использовании Git'а.</p>
<p id="calibre_link-8"><span><span><b>Слепки вместо патчей</b></span></span></p>
<p>Главное отличие Git'а от любых других СКВ (например, Subversion и ей подобных) &mdash; это то, как Git смотрит на свои данные. В принципе, большинство других систем хранит информацию как список изменений (патчей) для файлов. Эти системы (CVS, Subversion, Perforce, Bazaar и другие) относятся к хранимым данным как к набору файлов и изменений, сделанных для каждого из этих файлов во времени, как показано на рисунке 1-4.</p>
<p><img src="images/000075.jpg"></img></p>
<p>Git не хранит свои данные в таком виде. Вместо этого Git считает хранимые данные набором слепков небольшой файловой системы. Каждый раз, когда вы фиксируете текущую версию проекта, Git, по сути, сохраняет слепок того, как выглядят все файлы проекта на текущий момент. Ради эффективности, если файл не менялся, Git не сохраняет файл снова, а делает ссылку на ранее сохранённый файл. То, как Git подходит к хранению данных, похоже на рисунок 1-5.</p>
<p><img src="images/000033.jpg"></img></p>
<p>Это важное отличие Git'а от практически всех других систем контроля версий. Из-за него Git вынужден пересмотреть практически все аспекты контроля версий, которые другие системы переняли от своих предшественниц. Git больше похож на небольшую файловую систему с невероятно мощными инструментами, работающими поверх неё, чем на просто СКВ. В главе 3, коснувшись работы с ветвями в Git'е, мы узнаем, какие преимущества даёт такое понимание данных.</p>
<p id="calibre_link-9"><span><span><b>Почти все операции &mdash; локальные</b></span></span></p>
<p>Для совершения большинства операций в Git'е необходимы только локальные файлы и ресурсы, т.е. обычно информация с других компьютеров в сети не нужна. Если вы пользовались централизованными системами, где практически на каждую операцию накладывается сетевая задержка, вы, возможно, подумаете, что боги наделили Git неземной силой. Поскольку вся история проекта хранится локально у вас на диске, большинство операций кажутся практически мгновенными.</p>
<p>К примеру, чтобы показать историю проекта, Git'у не нужно скачивать её с сервера, он просто читает её прямо из вашего локального репозитория. Поэтому историю вы увидите практически мгновенно. Если вам нужно просмотреть изменения между текущей версией файла и версией, сделанной месяц назад, Git может взять файл месячной давности и вычислить разницу на месте, вместо того чтобы запрашивать разницу у СКВ-сервера или качать с него старую версию файла и делать локальное сравнение.</p>
<p>Кроме того, работа локально означает, что мало чего нельзя сделать без доступа к Сети или VPN. Если вы в самолёте или в поезде и хотите немного поработать, можно спокойно делать коммиты, а затем отправить их, как только станет доступна сеть. Если вы пришли домой, а VPN-клиент не работает, всё равно можно продолжать работать. Во многих других системах это невозможно или же крайне неудобно. Например, используя Perforce, вы мало что можете сделать без соединения с сервером. Работая с Subversion и CVS, вы можете редактировать файлы, но сохранить изменения в вашу базу данных нельзя (потому что она отключена от репозитория). Вроде ничего серьёзного, но потом вы удивитесь, насколько это меняет дело.</p>
<p id="calibre_link-10"><span><span><b>Git следит за целостностью данных</b></span></span></p>
<p>Перед сохранением любого файла Git вычисляет контрольную сумму, и она становится индексом этого файла. Поэтому невозможно изменить содержимое файла или каталога так, чтобы Git не узнал об этом. Эта функциональность встроена в сам фундамент Git'а и является важной составляющей его философии. Если информация потеряется при передаче или повредится на диске, Git всегда это выявит.</p>
<p>Механизм, используемый Git'ом для вычисления контрольных сумм, называется SHA-1 хешем. Это строка из 40 шестнадцатеричных символов (0-9 и a-f), вычисляемая в Git'е на основе содержимого файла или структуры каталога. SHA-1 хеш выглядит примерно так:</p>
<p><tt>24b9da6552252987aa493b52f8696cd6d3b00373<br></br></tt></p>
<p>Работая с Git'ом, вы будете встречать эти хеши повсюду, поскольку он их очень широко использует. Фактически, в своей базе данных Git сохраняет всё не по именам файлов, а по хешам их содержимого.</p>
<p id="calibre_link-11"><span><span><b>Чаще всего данные в Git только добавляются</b></span></span></p>
<p>Практически все действия, которые вы совершаете в Git'е, только добавляют данные в базу. Очень сложно заставить систему удалить данные или сделать что-то неотменяемое. Можно, как и в любой другой СКВ, потерять данные, которые вы ещё не сохранили, но как только они зафиксированы, их очень сложно потерять, особенно если вы регулярно отправляете изменения в другой репозиторий.</p>
<p>Поэтому пользоваться Git'ом &mdash; удовольствие, потому что можно экспериментировать, не боясь что-то серьёзно поломать. Чтобы узнать подробнее о том, как Git хранит свои данные и как восстановить то, что кажется уже потерянным, читайте главу 9.</p>
<p id="calibre_link-12"><span><span><b>Три состояния</b></span></span></p>
<p>Теперь внимание. Это самое важное, что нужно помнить про Git, если вы хотите, чтобы дальше изучение шло гладко. В Git'е файлы могут находиться в одном из трёх состояний: зафиксированном, изменённом и подготовленном. "Зафиксированный" значит, что файл уже сохранён в вашей локальной базе. К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы. Подготовленные файлы &mdash; это изменённые файлы, отмеченные для включения в следующий коммит.</p>
<p>Таким образом, в проектах, использующих Git, есть три части: каталог Git'а (Git directory), рабочий каталог (working directory) и область подготовленных файлов (staging area).</p>
<p><img src="images/000025.jpg"></img></p>
<p>Каталог Git'а &mdash; это место, где Git хранит метаданные и базу данных объектов вашего проекта. Это наиболее важная часть Git'а, и именно она копируется, когда вы клонируете репозиторий с другого компьютера.</p>
<p>Рабочий каталог &mdash; это извлечённая из базы копия определённой версии проекта. Эти файлы достаются из сжатой базы данных в каталоге Git'а и помещаются на диск для того, чтобы вы их просматривали и редактировали.</p>
<p>Область подготовленных файлов &mdash; это обычный файл, обычно хранящийся в каталоге Git'а, который содержит информацию о том, что должно войти в следующий коммит. Иногда его называют индексом (index), но в последнее время становится стандартом называть его областью подготовленных файлов (staging area).</p>
<p>Стандартный рабочий процесс с использованием Git'а выглядит примерно так:</p>
<div>&nbsp;</div><ol><li value="1">Вы вносите изменения в файлы в своём рабочем каталоге.</li><li value="2">Подготавливаете файлы, добавляя их слепки в область подготовленных файлов.</li><li value="3">Делаете коммит, который берёт подготовленные файлы из индекса и помещает их в каталог Git'а на постоянное хранение.</li></ol><p>Если рабочая версия файла совпадает с версией в каталоге Git'а, файл считается зафиксированным. Если файл изменён, но добавлен в область подготовленных данных, он подготовлен. Если же файл изменился после выгрузки из БД, но не был подготовлен, то он считается изменённым. В главе 2 вы узнаете больше об этих трёх состояниях и как можно либо воспользоваться этим, либо пропустить стадию подготовки.</p>
<div></div><p id="calibre_link-13"><span><span><b>Установка Git</b></span></span></p>
<p>Настало время немного ознакомиться с использованием Git'а. Первое, что вам необходимо сделать, &mdash; установить его. Есть несколько способов сделать это; два основных &mdash; установка из исходников и установка собранного пакета для вашей платформы.</p>
<p id="calibre_link-14"><span><span><b>Установка из исходников</b></span></span></p>
<p>Если есть возможность, то, как правило, лучше установить Git из исходных кодов, поскольку так вы получите самую свежую версию. Каждая новая версия Git'а обычно включает полезные улучшения пользовательского интерфейса, поэтому получение последней версии &mdash; часто лучший путь, если, конечно, вас не затрудняет установка программ из исходников. К тому же, многие дистрибутивы Linux содержат очень старые пакеты. Поэтому, если только вы не на очень свежем дистрибутиве или используете пакеты из экспериментальной ветки, установка из исходников может быть самым выигрышным решением.</p>
<p>Для установки Git'а вам понадобятся библиотеки, от которых он зависит: curl, zlib, openssl, expat и libiconv. Например, если в вашей системе менеджер пакетов &mdash; yum (Fedora), или apt-get (Debian, Ubuntu), можно воспользоваться следующими командами, чтобы разрешить все зависимости:</p>
<p><tt>$&nbsp;yum&nbsp;install&nbsp;curl-devel&nbsp;expat-devel&nbsp;gettext-devel&nbsp;\<br></br>&nbsp;&nbsp;openssl-devel&nbsp;zlib-devel<br></br><br></br>$&nbsp;apt-get&nbsp;install&nbsp;libcurl4-gnutls-dev&nbsp;libexpat1-dev&nbsp;gettext&nbsp;\<br></br>&nbsp;&nbsp;libz-dev&nbsp;libssl-dev<br></br></tt></p>
<p>Установив все необходимые библиотеки, можно идти дальше и скачать последнюю версию с сайта Git'а:</p>
<p><tt>http://git-scm.com/download<br></br></tt></p>
<p>Теперь скомпилируйте и установите:</p>
<p><tt>$&nbsp;tar&nbsp;-zxf&nbsp;git-1.7.2.2.tar.gz<br></br>$&nbsp;cd&nbsp;git-1.7.2.2<br></br>$&nbsp;make&nbsp;prefix=/usr/local&nbsp;all<br></br>$&nbsp;sudo&nbsp;make&nbsp;prefix=/usr/local&nbsp;install<br></br></tt></p>
<p>После этого вы можете скачать Git с помощью самого Git'а, чтобы получить обновления:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;git://git.kernel.org/pub/scm/git/git.git<br></br></tt></p>
<p id="calibre_link-15"><span><span><b>Установка в Linux</b></span></span></p>
<p>Если вы хотите установить Git под Linux как бинарный пакет, это можно сделать, используя обычный менеджер пакетов вашего дистрибутива. Если у вас Fedora, можно воспользоваться yum'ом:</p>
<p><tt>$&nbsp;yum&nbsp;install&nbsp;git-core<br></br></tt></p>
<p>Если же у вас дистрибутив, основанный на Debian, например, Ubuntu, попробуйте apt-get:</p>
<p><tt>$&nbsp;apt-get&nbsp;install&nbsp;git<br></br></tt></p>
<p id="calibre_link-16"><span><span><b>Установка на Mac</b></span></span></p>
<p>Есть два простых способа установить Git на Mac. Самый простой &mdash; использовать графический инсталлятор Git'а, который вы можете скачать со страницы на Google Code (см. рисунок 1-7):</p>
<p><tt>http://code.google.com/p/git-osx-installer<br></br></tt></p>
<p><img src="images/000023.jpg"></img></p>
<p>Другой распространённый способ установки Git'а &mdash; через MacPorts (<tt>http://www.macports.org</tt>). Если у вас установлен MacPorts, установите Git так:</p>
<p><tt>$&nbsp;sudo&nbsp;port&nbsp;install&nbsp;git-core&nbsp;+svn&nbsp;+doc&nbsp;+bash_completion&nbsp;+gitweb<br></br></tt></p>
<p>Вам не обязательно устанавливать все дополнения, но, вероятно, вам понадобится +svn, если вы когда-нибудь захотите использовать Git вместе с репозиториями Subversion (см. главу 8).</p>
<p id="calibre_link-17"><span><span><b>Установка в Windows</b></span></span></p>
<p>Установить Git в Windows очень просто. У проекта msysGit процедура установки &mdash; одна из самых простых. Просто скачайте exe-файл инсталлятора со страницы проекта на GitHub'е и запустите его:</p>
<p><tt>http://msysgit.github.com/<br></br></tt></p>
<p>После установки у вас будет как консольная версия (включающая SSH-клиент, который пригодится позднее), так и стандартная графическая.</p>
<p>Пожалуйста, используйте Git только из командой оболочки, входящей в состав msysGit, потому что так вы сможете запускать сложные команды, приведённые в примерах в настоящей книге. Командная оболочка Windows использует иной синтаксис, из-за чего примеры в ней могут работать некорректно.</p>
<div></div><p id="calibre_link-18"><span><span><b>Первоначальная настройка Git</b></span></span></p>
<p>Теперь, когда Git установлен в вашей системе, хотелось бы сделать кое-какие вещи, чтобы настроить среду для работы с Git'ом под себя. Это нужно сделать только один раз &mdash; при обновлении версии Git'а настройки сохранятся. Но вы можете поменять их в любой момент, выполнив те же команды снова.</p>
<p>В состав Git'а входит утилита <tt>git config</tt>, которая позволяет просматривать и устанавливать параметры, контролирующие все аспекты работы Git'а и его внешний вид. Эти параметры могут быть сохранены в трёх местах:</p>
<div>&nbsp;</div><ul><li value="1">Файл <tt>/etc/gitconfig</tt> содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске <tt>git config</tt> указать параметр <tt>--system</tt>, то параметры будут читаться и сохраняться именно в этот файл.</li><li value="2">Файл <tt>~/.gitconfig</tt> хранит настройки конкретного пользователя. Этот файл используется при указании параметра <tt>--global</tt>.</li><li value="3">Конфигурационный файл в каталоге Git'а (<tt>.git/config</tt>) в том репозитории, где вы находитесь в данный момент. Эти параметры действуют только для данного конкретного репозитория. Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в <tt>.git/config</tt> перекрывают соответствующие значения в <tt>/etc/gitconfig</tt>.</li></ul><p>В системах семейства Windows Git ищет файл <tt>.gitconfig</tt> в каталоге <tt>$HOME</tt> (<tt>C:\Documents and Settings\$USER</tt> или <tt>C:\Users\$USER</tt> для большинства пользователей). Кроме того Git ищет файл /etc/gitconfig, но уже относительно корневого каталога MSys, который находится там, куда вы решили установить Git, когда запускали инсталлятор.</p>
<p id="calibre_link-19"><span><span><b>Имя пользователя</b></span></span></p>
<p>Первое, что вам следует сделать после установки Git'а, &mdash; указать ваше имя и адрес электронной почты. Это важно, потому что каждый коммит в Git'е содержит эту информацию, и она включена в коммиты, передаваемые вами, и не может быть далее изменена:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;user.name&nbsp;"John&nbsp;Doe"<br></br>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;user.email&nbsp;johndoe@example.com<br></br></tt></p>
<p>Повторюсь, что, если указана опция <tt>--global</tt>, то эти настройки достаточно сделать только один раз, поскольку в этом случае Git будет использовать эти данные для всего, что вы делаете в этой системе. Если для каких-то отдельных проектов вы хотите указать другое имя или электронную почту, можно выполнить эту же команду без параметра <tt>--global</tt> в каталоге с нужным проектом.</p>
<p id="calibre_link-20"><span><span><b>Выбор редактора</b></span></span></p>
<p>Вы указали своё имя, и теперь можно выбрать текстовый редактор, который будет использоваться, если будет нужно набрать сообщение в Git'е. По умолчанию Git использует стандартный редактор вашей системы, обычно это Vi или Vim. Если вы хотите использовать другой текстовый редактор, например, Emacs, можно сделать следующее:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;core.editor&nbsp;emacs<br></br></tt></p>
<p id="calibre_link-21"><span><span><b>Утилита сравнения</b></span></span></p>
<p>Другая полезная настройка, которая может понадобиться &mdash; встроенная diff-утилита, которая будет использоваться для разрешения конфликтов слияния. Например, если вы хотите использовать vimdiff:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;merge.tool&nbsp;vimdiff<br></br></tt></p>
<p>Git умеет делать слияния при помощи kdiff3, tkdiff, meld, xxdiff, emerge, vimdiff, gvimdiff, ecmerge и opendiff, но вы можете настроить и другую утилиту. Подробнее об этом написано в главе 7.</p>
<p id="calibre_link-22"><span><span><b>Проверка настроек</b></span></span></p>
<p>Если вы хотите проверить используемые настройки, можете использовать команду <tt>git config --list</tt>, чтобы показать все, которые Git найдёт:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--list<br></br>user.name=Scott&nbsp;Chacon<br></br>user.email=schacon@gmail.com<br></br>color.status=auto<br></br>color.branch=auto<br></br>color.interactive=auto<br></br>color.diff=auto<br></br>...<br></br></tt></p>
<p>Некоторые ключи (названия) настроек могут появиться несколько раз, потому что Git читает один и тот же ключ из разных файлов (например из <tt>/etc/gitconfig</tt> и <tt>~/.gitconfig</tt>). В этом случае Git использует последнее значение для каждого ключа.</p>
<p>Также вы можете проверить значение конкретного ключа, выполнив <tt>git config {ключ}</tt>:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;user.name<br></br>Scott&nbsp;Chacon<br></br></tt></p>
<div></div><p id="calibre_link-23"><span><span><b>Как получить помощь?</b></span></span></p>
<p>Если вам нужна помощь при использовании Git'а, есть три способа открыть страницу руководства по любой команде Git'а:</p>
<p><tt>$&nbsp;git&nbsp;help&nbsp;&lt;команда&gt;<br></br>$&nbsp;git&nbsp;&lt;команда&gt;&nbsp;--help<br></br>$&nbsp;man&nbsp;git-&lt;команда&gt;<br></br></tt></p>
<p>Например, так можно открыть руководство по команде config:</p>
<p><tt>$&nbsp;git&nbsp;help&nbsp;config<br></br></tt></p>
<p>Эти команды хороши тем, что ими можно пользоваться всегда, даже без подключения к сети. Если руководства и этой книги недостаточно и вам нужна персональная помощь, вы можете попытаться поискать её на каналах <tt>#git</tt> и <tt>#github</tt> IRC-сервера Freenode (irc.freenode.net). Обычно там сотни людей, отлично знающих Git, которые могут помочь.</p>
<div></div><p id="calibre_link-24"><span><span><b>Итоги</b></span></span></p>
<p>Теперь у вас должно быть общее понимание, что такое Git, и в чём его отличие от тех ЦСКВ, которыми вы, вероятно, пользовались раньше. Также у вас должна быть установлена рабочая версия Git'а с вашими личными настройками. Настало время перейти к изучению основ Git'а.</p>
<div></div><p id="calibre_link-25"><span><span><b>Основы Git</b></span></span></p>
<p>Если вы хотите начать работать с Git'ом, прочитав всего одну главу, то эта глава &mdash; то, что вам нужно. Здесь рассмотрены все базовые команды, необходимые вам для решения подавляющего большинства задач возникающих при работе с Git'ом. После прочтения этой главы вы научитесь настраивать и инициализировать репозиторий, начинать и прекращать версионный контроль файлов, а также подготавливать и фиксировать изменения. Мы также продемонстрируем вам как настроить в Git'е игнорирование отдельных файлов или их групп, как быстро и просто отменить ошибочные изменения, как просмотреть историю вашего проекта и изменения между отдельными коммитами (commit), а также как отправлять (push) и получать (pull) изменения в/из удалённого (remote) репозитория.</p>
<div></div><p id="calibre_link-26"><span><span><b>Создание Git-репозитория</b></span></span></p>
<p>Для создания Git-репозитория существуют два основных подхода. Первый подход &mdash; импорт в Git уже существующего проекта или каталога. Второй &mdash; клонирование уже существующего репозитория с сервера.</p>
<p id="calibre_link-27"><span><span><b>Создание репозитория в существующем каталоге</b></span></span></p>
<p>Если вы собираетесь начать использовать Git для существующего проекта, то вам необходимо перейти в проектный каталог и в командной строке ввести</p>
<p><tt>$&nbsp;git&nbsp;init<br></br></tt></p>
<p>Эта команда создаёт в текущем каталоге новый подкаталог с именем .git содержащий все необходимые файлы репозитория &mdash; основу Git-репозитория. На этом этапе ваш проект ещё не находится под версионным контролем. (В главе 9 приведено подробное описание файлов содержащихся в только что созданном вами каталоге <tt>.git</tt>)</p>
<p>Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит проиндексировать эти файлы и осуществить первую фиксацию изменений. Осуществить это вы можете с помощью нескольких команд <tt>git add</tt> указывающих индексируемые файлы, а затем <tt>commit</tt>:</p>
<p><tt>$&nbsp;git&nbsp;add&nbsp;*.c<br></br>$&nbsp;git&nbsp;add&nbsp;README<br></br>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'initial&nbsp;project&nbsp;version'<br></br></tt></p>
<p>Мы разберём, что делают эти команды чуть позже. На данном этапе, у вас есть Git-репозиторий с добавленными файлами и начальным коммитом.</p>
<p id="calibre_link-28"><span><span><b>Клонирование существующего репозитория</b></span></span></p>
<p>Если вы желаете получить копию существующего репозитория Git, например, проекта, в котором вы хотите поучаствовать, то вам нужна команда <tt>git clone</tt>. Если вы знакомы с другими системами контроля версий, такими как Subversion, то заметите, что команда называется <tt>clone</tt>, а не <tt>checkout</tt>. Это важное отличие &mdash; Git получает копию практически всех данных, что есть на сервере. Каждая версия каждого файла из истории проекта забирается (pulled) с сервера, когда вы выполняете <tt>git clone</tt>. Фактически, если серверный диск выйдет из строя, вы можете использовать любой из клонов на любом из клиентов, для того чтобы вернуть сервер в то состояние, в котором он находился в момент клонирования (вы можете потерять часть серверных перехватчиков (server-side hooks) и т.п., но все данные, помещённые под версионный контроль, будут сохранены, подробнее см. в главе 4).</p>
<p>Клонирование репозитория осуществляется командой <tt>git clone [url]</tt>. Например, если вы хотите клонировать библиотеку Ruby Git, известную как Grit, вы можете сделать это следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;git://github.com/schacon/grit.git<br></br></tt></p>
<p>Эта команда создаёт каталог с именем <tt>grit</tt>, инициализирует в нём каталог <tt>.git</tt>, скачивает все данные для этого репозитория и создаёт (checks out) рабочую копию последней версии. Если вы зайдёте в новый каталог <tt>grit</tt>, вы увидите в нём проектные файлы, пригодные для работы и использования. Если вы хотите клонировать репозиторий в каталог, отличный от <tt>grit</tt>, можно это указать в следующем параметре командной строки:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;git://github.com/schacon/grit.git&nbsp;mygrit<br></br></tt></p>
<p>Эта команда делает всё то же самое, что и предыдущая, только результирующий каталог будет назван mygrit.</p>
<p>В Git'е реализовано несколько транспортных протоколов, которые вы можете использовать. В предыдущем примере использовался протокол <tt>git://</tt>, вы также можете встретить <tt>http(s)://</tt> или <tt>user@server:/path.git</tt>, использующий протокол передачи SSH. В главе 4 мы познакомимся со всеми доступными вариантами конфигурации сервера для обеспечения доступа к вашему Git-репозиторию, а также рассмотрим их достоинства и недостатки.</p>
<div></div><p id="calibre_link-29"><span><span><b>Запись изменений в репозиторий</b></span></span></p>
<p>Итак, у вас имеется настоящий Git-репозиторий и рабочая копия файлов для некоторого проекта. Вам нужно делать некоторые изменения и фиксировать “снимки” состояния (snapshots) этих изменений в вашем репозитории каждый раз, когда проект достигает состояния, которое вам хотелось бы сохранить.</p>
<p>Запомните, каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). Отслеживаемые файлы &mdash; это те файлы, которые были в последнем слепке состояния проекта (snapshot); они могут быть неизменёнными, изменёнными или подготовленными к коммиту (staged). Неотслеживаемые файлы &mdash; это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний слепок состояния и не подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что вы только взяли их из хранилища (checked them out) и ничего пока не редактировали.</p>
<p>Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, т.к. вы изменили их с момента последнего коммита. Вы индексируете (stage) эти изменения и затем фиксируете все индексированные изменения, а затем цикл повторяется. Этот жизненный цикл изображён на рисунке 2-1.</p>
<p><img src="images/000030.jpg"></img></p>
<p id="calibre_link-30"><span><span><b>Определение состояния файлов</b></span></span></p>
<p>Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся &mdash; это команда <tt>git status</tt>. Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:</p>
<p><tt>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>nothing&nbsp;to&nbsp;commit&nbsp;(working&nbsp;directory&nbsp;clean)<br></br></tt></p>
<p>Это означает, что у вас чистый рабочий каталог, другими словами &mdash; в нём нет отслеживаемых изменённых файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь. И наконец, команда сообщает вам на какой ветке (branch) вы сейчас находитесь. Пока что это всегда ветка <tt>master</tt> &mdash; это ветка по умолчанию; в этой главе это не важно. В следующей главе будет подробно рассказано про ветки и ссылки.</p>
<p>Предположим, вы добавили в свой проект новый файл, простой файл README. Если этого файла раньше не было, и вы выполните <tt>git status</tt>, вы увидите свой неотслеживаемый файл вот так:</p>
<p><tt>$&nbsp;vim&nbsp;README<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Untracked&nbsp;files:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;README<br></br>nothing&nbsp;added&nbsp;to&nbsp;commit&nbsp;but&nbsp;untracked&nbsp;files&nbsp;present&nbsp;(use&nbsp;"git&nbsp;add"&nbsp;to&nbsp;track)<br></br></tt></p>
<p>Понять, что новый файл README неотслеживаемый можно по тому, что он находится в секции "Untracked files" в выводе команды <tt>status</tt>. Статус "неотслеживаемый файл", по сути, означает, что Git видит файл, отсутствующий в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. Это предохранит вас от случайного добавления в репозиторий сгенерированных бинарных файлов или каких-либо других, которые вы и не думали добавлять. Мы хотели добавить README, так давайте сделаем это.</p>
<p id="calibre_link-31"><span><span><b>Отслеживание новых файлов</b></span></span></p>
<p>Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда <tt>git add</tt>. Чтобы начать отслеживание файла README, вы можете выполнить следующее:</p>
<p><tt>$&nbsp;git&nbsp;add&nbsp;README<br></br></tt></p>
<p>Если вы снова выполните команду <tt>status</tt>, то увидите, что файл README теперь отслеживаемый и индексированный:</p>
<p><tt>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;new&nbsp;file:&nbsp;&nbsp;&nbsp;README<br></br>#<br></br></tt></p>
<p>Вы можете видеть, что файл проиндексирован по тому, что он находится в секции “Changes to be committed”. Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды <tt>git add</tt>, будет добавлена в историю снимков состояния. Как вы помните, когда вы ранее выполнили <tt>git init</tt>, вы затем выполнили <tt>git add (файлы)</tt> &mdash; это было сделано для того, чтобы добавить файлы в вашем каталоге под версионный контроль. Команда <tt>git add</tt> принимает параметром путь к файлу или каталогу, если это каталог, команда рекурсивно добавляет (индексирует) все файлы в данном каталоге.</p>
<p id="calibre_link-32"><span><span><b>Индексация изменённых файлов</b></span></span></p>
<p>Давайте модифицируем файл, уже находящийся под версионным контролем. Если вы измените отслеживаемый файл benchmarks.rb и после этого снова выполните команду <tt>status</tt>, то результат будет примерно следующим:</p>
<p><tt>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;new&nbsp;file:&nbsp;&nbsp;&nbsp;README<br></br>#<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br></tt></p>
<p>Файл benchmarks.rb находится в секции “Changes not staged for commit” &mdash; это означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду <tt>git add</tt> (это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния). Выполним <tt>git add</tt>, чтобы проиндексировать benchmarks.rb, а затем снова выполним <tt>git status</tt>:</p>
<p><tt>$&nbsp;git&nbsp;add&nbsp;benchmarks.rb<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;new&nbsp;file:&nbsp;&nbsp;&nbsp;README<br></br>#&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br></tt></p>
<p>Теперь оба файла проиндексированы и войдут в следующий коммит. В этот момент вы, предположим, вспомнили одно небольшое изменение, которое вы хотите сделать в benchmarks.rb до фиксации. Вы открываете файл, вносите и сохраняете необходимые изменения и вроде бы готовы к коммиту. Но давайте-ка ещё раз выполним <tt>git status</tt>:</p>
<p><tt>$&nbsp;vim&nbsp;benchmarks.rb<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;new&nbsp;file:&nbsp;&nbsp;&nbsp;README<br></br>#&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br></tt></p>
<p>Что за чёрт? Теперь benchmarks.rb отображается как проиндексированный и непроиндексированный одновременно. Как такое возможно? Такая ситуация наглядно демонстрирует, что Git индексирует файл в точности в том состоянии, в котором он находился, когда вы выполнили команду <tt>git add</tt>. Если вы выполните коммит сейчас, то файл benchmarks.rb попадёт в коммит в том состоянии, в котором он находился, когда вы последний раз выполняли команду <tt>git add</tt>, а не в том, в котором он находится в вашем рабочем каталоге в момент выполнения <tt>git commit</tt>. Если вы изменили файл после выполнения <tt>git add</tt>, вам придётся снова выполнить <tt>git add</tt>, чтобы проиндексировать последнюю версию файла:</p>
<p><tt>$&nbsp;git&nbsp;add&nbsp;benchmarks.rb<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;new&nbsp;file:&nbsp;&nbsp;&nbsp;README<br></br>#&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br></tt></p>
<p id="calibre_link-33"><span><span><b>Игнорирование файлов</b></span></span></p>
<p>Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т.п.). В таком случае, вы можете создать файл .gitignore с перечислением шаблонов соответствующих таким файлам. Вот пример файла .gitignore:</p>
<p><tt>$&nbsp;cat&nbsp;.gitignore<br></br>*.[oa]<br></br>*~<br></br></tt></p>
<p>Первая строка предписывает Git'у игнорировать любые файлы заканчивающиеся на .o или .a &mdash; объектные и архивные файлы, которые могут появиться во время сборки кода. Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду (<tt>~</tt>), которая используется во многих текстовых редакторах, например Emacs, для обозначения временных файлов. Вы можете также включить каталоги log, tmp или pid; автоматически создаваемую документацию; и т.д. и т.п. Хорошая практика заключается в настройке файла .gitignore до того, как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там видеть не хотите.</p>
<p>К шаблонам в файле .gitignore применяются следующие правила:</p>
<div>&nbsp;</div><ul><li value="1">Пустые строки, а также строки, начинающиеся с #, игнорируются.</li><li value="2">Можно использовать стандартные glob шаблоны.</li><li value="3">Можно заканчивать шаблон символом слэша (<tt>/</tt>) для указания каталога.</li><li value="4">Можно инвертировать шаблон, использовав восклицательный знак (<tt>!</tt>) в качестве первого символа.</li></ul><p>Glob-шаблоны представляют собой упрощённые регулярные выражения используемые командными интерпретаторами. Символ <tt>*</tt> соответствует 0 или более символам; последовательность <tt>[abc]</tt> &mdash; любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (<tt>?</tt>) соответствует одному символу; <tt>[0-9]</tt> соответствует любому символу из интервала (в данном случае от 0 до 9).</p>
<p>Вот ещё один пример файла .gitignore:</p>
<p><tt>#&nbsp;комментарий&nbsp;&mdash;&nbsp;эта&nbsp;строка&nbsp;игнорируется<br></br>#&nbsp;не&nbsp;обрабатывать&nbsp;файлы,&nbsp;имя&nbsp;которых&nbsp;заканчивается&nbsp;на&nbsp;.a<br></br>*.a<br></br>#&nbsp;НО&nbsp;отслеживать&nbsp;файл&nbsp;lib.a,&nbsp;несмотря&nbsp;на&nbsp;то,&nbsp;что&nbsp;мы&nbsp;игнорируем&nbsp;все&nbsp;.a&nbsp;файлы&nbsp;с&nbsp;помощью&nbsp;предыдущего&nbsp;правила<br></br>!lib.a<br></br>#&nbsp;игнорировать&nbsp;только&nbsp;файл&nbsp;TODO&nbsp;находящийся&nbsp;в&nbsp;корневом&nbsp;каталоге,&nbsp;не&nbsp;относится&nbsp;к&nbsp;файлам&nbsp;вида&nbsp;subdir/TODO<br></br>/TODO<br></br>#&nbsp;игнорировать&nbsp;все&nbsp;файлы&nbsp;в&nbsp;каталоге&nbsp;build/<br></br>build/<br></br>#&nbsp;игнорировать&nbsp;doc/notes.txt,&nbsp;но&nbsp;не&nbsp;doc/server/arch.txt<br></br>doc/*.txt<br></br>#&nbsp;игнорировать&nbsp;все&nbsp;.txt&nbsp;файлы&nbsp;в&nbsp;каталоге&nbsp;doc/<br></br>doc/**/*.txt<br></br></tt></p>
<p>Шаблон <tt>**/</tt> доступен в Git, начиная с версии 1.8.2.</p>
<p id="calibre_link-34"><span><span><b>Просмотр индексированных и неиндексированных изменений</b></span></span></p>
<p>Если результат работы команды <tt>git status</tt> недостаточно информативен для вас &mdash; вам хочется знать, что конкретно поменялось, а не только какие файлы были изменены &mdash; вы можете использовать команду <tt>git diff</tt>. Позже мы рассмотрим команду <tt>git diff</tt> подробнее; вы, скорее всего, будете использовать эту команду для получения ответов на два вопроса: что вы изменили, но ещё не проиндексировали, и что вы проиндексировали и собираетесь фиксировать. Если <tt>git status</tt> отвечает на эти вопросы слишком обобщённо, то <tt>git diff</tt> показывает вам непосредственно добавленные и удалённые строки &mdash; собственно заплатку (patch).</p>
<p>Допустим, вы снова изменили и проиндексировали файл README, а затем изменили файл benchmarks.rb без индексирования. Если вы выполните команду <tt>status</tt>, вы опять увидите что-то вроде:</p>
<p><tt>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;new&nbsp;file:&nbsp;&nbsp;&nbsp;README<br></br>#<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br></tt></p>
<p>Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите <tt>git diff</tt> без аргументов:</p>
<p><tt>$&nbsp;git&nbsp;diff<br></br>diff&nbsp;--git&nbsp;a/benchmarks.rb&nbsp;b/benchmarks.rb<br></br>index&nbsp;3cb747f..da65585&nbsp;100644<br></br>---&nbsp;a/benchmarks.rb<br></br>+++&nbsp;b/benchmarks.rb<br></br>@@&nbsp;-36,6&nbsp;+36,10&nbsp;@@&nbsp;def&nbsp;main<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@commit.parents[0].parents[0].parents[0]<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br></br><br></br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run_code(x,&nbsp;'commits&nbsp;1')&nbsp;do<br></br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git.commits.size<br></br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>+<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run_code(x,&nbsp;'commits&nbsp;2')&nbsp;do<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;=&nbsp;git.commits('master',&nbsp;15)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.size<br></br></tt></p>
<p>Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения.</p>
<p>Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить <tt>git diff --cached</tt>. (В Git'е версии 1.6.1 и выше, вы также можете использовать <tt>git diff --staged</tt>, которая легче запоминается.) Эта команда сравнивает ваши индексированные изменения с последним коммитом:</p>
<p><tt>$&nbsp;git&nbsp;diff&nbsp;--cached<br></br>diff&nbsp;--git&nbsp;a/README&nbsp;b/README<br></br>new&nbsp;file&nbsp;mode&nbsp;100644<br></br>index&nbsp;0000000..03902a1<br></br>---&nbsp;/dev/null<br></br>+++&nbsp;b/README2<br></br>@@&nbsp;-0,0&nbsp;+1,5&nbsp;@@<br></br>+grit<br></br>+&nbsp;by&nbsp;Tom&nbsp;Preston-Werner,&nbsp;Chris&nbsp;Wanstrath<br></br>+&nbsp;http://github.com/mojombo/grit<br></br>+<br></br>+Grit&nbsp;is&nbsp;a&nbsp;Ruby&nbsp;library&nbsp;for&nbsp;extracting&nbsp;information&nbsp;from&nbsp;a&nbsp;Git&nbsp;repository<br></br></tt></p>
<p>Важно отметить, что <tt>git diff</tt> сама по себе не показывает все изменения сделанные с последнего коммита &mdash; только те, что ещё не проиндексированы. Такое поведение может сбивать с толку, так как если вы проиндексируете все свои изменения, то <tt>git diff</tt> ничего не вернёт.</p>
<p>Другой пример: вы проиндексировали файл benchmarks.rb и затем изменили его, вы можете использовать <tt>git diff</tt> для просмотра как индексированных изменений в этом файле, так и тех, что пока не проиндексированы:</p>
<p><tt>$&nbsp;git&nbsp;add&nbsp;benchmarks.rb<br></br>$&nbsp;echo&nbsp;'#&nbsp;test&nbsp;line'&nbsp;&gt;&gt;&nbsp;benchmarks.rb<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br></tt></p>
<p>Теперь вы можете используя <tt>git diff</tt> посмотреть непроиндексированные изменения</p>
<p><tt>$&nbsp;git&nbsp;diff<br></br>diff&nbsp;--git&nbsp;a/benchmarks.rb&nbsp;b/benchmarks.rb<br></br>index&nbsp;e445e28..86b2f7c&nbsp;100644<br></br>---&nbsp;a/benchmarks.rb<br></br>+++&nbsp;b/benchmarks.rb<br></br>@@&nbsp;-127,3&nbsp;+127,4&nbsp;@@&nbsp;end<br></br>&nbsp;main()<br></br><br></br>&nbsp;##pp&nbsp;Grit::GitRuby.cache_client.stats<br></br>+#&nbsp;test&nbsp;line<br></br></tt></p>
<p>а также уже проиндексированные, используя <tt>git diff --cached</tt>:</p>
<p><tt>$&nbsp;git&nbsp;diff&nbsp;--cached<br></br>diff&nbsp;--git&nbsp;a/benchmarks.rb&nbsp;b/benchmarks.rb<br></br>index&nbsp;3cb747f..e445e28&nbsp;100644<br></br>---&nbsp;a/benchmarks.rb<br></br>+++&nbsp;b/benchmarks.rb<br></br>@@&nbsp;-36,6&nbsp;+36,10&nbsp;@@&nbsp;def&nbsp;main<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@commit.parents[0].parents[0].parents[0]<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br></br><br></br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run_code(x,&nbsp;'commits&nbsp;1')&nbsp;do<br></br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git.commits.size<br></br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run_code(x,&nbsp;'commits&nbsp;2')&nbsp;do<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log&nbsp;=&nbsp;git.commits('master',&nbsp;15)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.size<br></br></tt></p>
<p id="calibre_link-35"><span><span><b>Фиксация изменений</b></span></span></p>
<p>Теперь, когда ваш индекс настроен так, как вам и хотелось, вы можете зафиксировать свои изменения. Запомните, всё, что до сих пор не проиндексировано &mdash; любые файлы, созданные или изменённые вами, и для которых вы не выполнили <tt>git add</tt> после момента редактирования &mdash; не войдут в этот коммит. Они останутся изменёнными файлами на вашем диске. В нашем случае, когда вы в последний раз выполняли <tt>git status</tt>, вы видели что всё проиндексировано, и вот, вы готовы к коммиту. Простейший способ зафиксировать изменения &mdash; это набрать <tt>git commit</tt>:</p>
<p><tt>$&nbsp;git&nbsp;commit<br></br></tt></p>
<p>Эта команда откроет выбранный вами текстовый редактор. (Редактор устанавливается системной переменной <tt>$EDITOR</tt> &mdash; обычно это vim или emacs, хотя вы можете установить ваш любимый с помощью команды <tt>git config --global core.editor</tt>, как было показано в главе 1).</p>
<p>В редакторе будет отображён следующий текст (это пример окна Vim'а):</p>
<p><tt>#&nbsp;Please&nbsp;enter&nbsp;the&nbsp;commit&nbsp;message&nbsp;for&nbsp;your&nbsp;changes.&nbsp;Lines&nbsp;starting<br></br>#&nbsp;with&nbsp;'#'&nbsp;will&nbsp;be&nbsp;ignored,&nbsp;and&nbsp;an&nbsp;empty&nbsp;message&nbsp;aborts&nbsp;the&nbsp;commit.<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;file:&nbsp;&nbsp;&nbsp;README<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>~<br></br>~<br></br>~<br></br>".git/COMMIT_EDITMSG"&nbsp;10L,&nbsp;283C<br></br></tt></p>
<p>Вы можете видеть, что комментарий по умолчанию для коммита содержит закомментированный результат работы ("выхлоп") команды <tt>git status</tt> и ещё одну пустую строку сверху. Вы можете удалить эти комментарии и набрать своё сообщение или же оставить их для напоминания о том, что вы фиксируете. (Для ещё более подробного напоминания, что же именно вы поменяли, можете передать аргумент <tt>-v</tt> в команду <tt>git commit</tt>. Это приведёт к тому, что в комментарий будет также помещена дельта/diff изменений, таким образом вы сможете точно увидеть всё, что сделано.) Когда вы выходите из редактора, Git создаёт для вас коммит с этим сообщением (удаляя комментарии и вывод diff'а).</p>
<p>Есть и другой способ &mdash; вы можете набрать свой комментарий к коммиту в командной строке вместе с командой <tt>commit</tt>, указав его после параметра -m, как в следующем примере:</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;"Story&nbsp;182:&nbsp;Fix&nbsp;benchmarks&nbsp;for&nbsp;speed"<br></br>[master]:&nbsp;created&nbsp;463dc4f:&nbsp;"Fix&nbsp;benchmarks&nbsp;for&nbsp;speed"<br></br>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;3&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;README<br></br></tt></p>
<p>Итак, вы создали свой первый коммит! Вы можете видеть, что коммит вывел вам немного информации о себе: на какую ветку вы выполнили коммит (master), какая контрольная сумма SHA-1 у этого коммита (<tt>463dc4f</tt>), сколько файлов было изменено, а также статистику по добавленным/удалённым строкам в этом коммите.</p>
<p>Запомните, что коммит сохраняет снимок состояния вашего индекса. Всё, что вы не проиндексировали, так и торчит в рабочем каталоге как изменённое; вы можете сделать ещё один коммит, чтобы добавить эти изменения в репозиторий. Каждый раз, когда вы делаете коммит, вы сохраняете снимок состояния вашего проекта, который позже вы можете восстановить или с которым можно сравнить текущее состояние.</p>
<p id="calibre_link-36"><span><span><b>Игнорирование индексации</b></span></span></p>
<p>Несмотря на то, что индекс может быть удивительно полезным для создания коммитов именно такими, как вам и хотелось, он временами несколько сложнее, чем вам нужно в процессе работы. Если у вас есть желание пропустить этап индексирования, Git предоставляет простой способ. Добавление параметра <tt>-a</tt> в команду <tt>git commit</tt> заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без <tt>git add</tt>:</p>
<p><tt>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br>$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'added&nbsp;new&nbsp;benchmarks'<br></br>[master&nbsp;83e38c7]&nbsp;added&nbsp;new&nbsp;benchmarks<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;5&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p>Обратите внимание на то, что в данном случае перед коммитом вам не нужно выполнять <tt>git add</tt> для файла benchmarks.rb.</p>
<p id="calibre_link-37"><span><span><b>Удаление файлов</b></span></span></p>
<p>Для того чтобы удалить файл из Git'а, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать команда <tt>git rm</tt>, которая также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите его как “неотслеживаемый”.</p>
<p>Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции “Changes not staged for commit” (“Изменённые но не обновлённые” &mdash; читай не проиндексированные) вывода команды <tt>git status</tt>:</p>
<p><tt>$&nbsp;rm&nbsp;grit.gemspec<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add/rm&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deleted:&nbsp;&nbsp;&nbsp;&nbsp;grit.gemspec<br></br>#<br></br></tt></p>
<p>Затем, если вы выполните команду <tt>git rm</tt>, удаление файла попадёт в индекс:</p>
<p><tt>$&nbsp;git&nbsp;rm&nbsp;grit.gemspec<br></br>rm&nbsp;'grit.gemspec'<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deleted:&nbsp;&nbsp;&nbsp;&nbsp;grit.gemspec<br></br>#<br></br></tt></p>
<p>После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра <tt>-f</tt>. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git'а.</p>
<p>Другая полезная штука, которую вы можете захотеть сделать &mdash; это удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть оставить файл на винчестере, и убрать его из-под бдительного ока Git'а. Это особенно полезно, если вы забыли добавить что-то в файл <tt>.gitignore</tt> и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию <tt>--cached</tt>:</p>
<p><tt>$&nbsp;git&nbsp;rm&nbsp;--cached&nbsp;readme.txt<br></br></tt></p>
<p>В команду <tt>git rm</tt> можно передавать файлы, каталоги или glob-шаблоны. Это означает, что вы можете вытворять что-то вроде:</p>
<p><tt>$&nbsp;git&nbsp;rm&nbsp;log/\*.log<br></br></tt></p>
<p>Обратите внимание на обратный слэш (<tt>\</tt>) перед <tt>*</tt>. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора. Эта команда удаляет все файлы, которые имеют расширение <tt>.log</tt> в каталоге <tt>log/</tt>. Или же вы можете сделать вот так:</p>
<p><tt>$&nbsp;git&nbsp;rm&nbsp;\*~<br></br></tt></p>
<p>Эта команда удаляет все файлы, чьи имена заканчиваются на <tt>~</tt>.</p>
<p id="calibre_link-38"><span><span><b>Перемещение файлов</b></span></span></p>
<p>В отличие от многих других систем версионного контроля, Git не отслеживает перемещение файлов явно. Когда вы переименовываете файл в Git'е, в нём не сохраняется никаких метаданных, говорящих о том, что файл был переименован. Однако, Git довольно умён в плане обнаружения перемещений постфактум &mdash; мы рассмотрим обнаружение перемещения файлов чуть позже.</p>
<p>Таким образом, наличие в Git'е команды <tt>mv</tt> выглядит несколько странным. Если вам хочется переименовать файл в Git'е, вы можете сделать что-то вроде:</p>
<p><tt>$&nbsp;git&nbsp;mv&nbsp;file_from&nbsp;file_to<br></br></tt></p>
<p>и это отлично сработает. На самом деле, если вы выполните что-то вроде этого и посмотрите на статус, вы увидите, что Git считает, что произошло переименование файла:</p>
<p><tt>$&nbsp;git&nbsp;mv&nbsp;README.txt&nbsp;README<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Your&nbsp;branch&nbsp;is&nbsp;ahead&nbsp;of&nbsp;'origin/master'&nbsp;by&nbsp;1&nbsp;commit.<br></br>#<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;renamed:&nbsp;&nbsp;&nbsp;&nbsp;README.txt&nbsp;-&gt;&nbsp;README<br></br>#<br></br></tt></p>
<p>Однако, это эквивалентно выполнению следующих команд:</p>
<p><tt>$&nbsp;mv&nbsp;README.txt&nbsp;README<br></br>$&nbsp;git&nbsp;rm&nbsp;README.txt<br></br>$&nbsp;git&nbsp;add&nbsp;README<br></br></tt></p>
<p>Git неявно определяет, что произошло переименование, поэтому неважно, переименуете вы файл так или используя команду <tt>mv</tt>. Единственное отличие состоит лишь в том, что <tt>mv</tt> &mdash; это одна команда вместо трёх &mdash; это функция для удобства. Важнее другое &mdash; вы можете использовать любой удобный способ, чтобы переименовать файл, и затем воспользоваться add/rm перед коммитом.</p>
<div></div><p id="calibre_link-39"><span><span><b>Просмотр истории коммитов</b></span></span></p>
<p>После того как вы создадите несколько коммитов, или же вы склонируете репозиторий с уже существующей историей коммитов, вы, вероятно, захотите оглянуться назад и узнать, что же происходило с этим репозиторием. Наиболее простой и в то же время мощный инструмент для этого &mdash; команда <tt>git log</tt>.</p>
<p>Данные примеры используют очень простой проект, названный simplegit, который я часто использую для демонстраций. Чтобы получить этот проект, выполните:</p>
<p><tt>git&nbsp;clone&nbsp;git://github.com/schacon/simplegit-progit.git<br></br></tt></p>
<p>В результате выполнения <tt>git log</tt> в данном проекте, вы должны получить что-то вроде этого:</p>
<p><tt>$&nbsp;git&nbsp;log<br></br>commit&nbsp;ca82a6dff817ec66f44342007202690a93763949<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Mon&nbsp;Mar&nbsp;17&nbsp;21:52:11&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;changed&nbsp;the&nbsp;version&nbsp;number<br></br><br></br>commit&nbsp;085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sat&nbsp;Mar&nbsp;15&nbsp;16:40:33&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;unnecessary&nbsp;test&nbsp;code<br></br><br></br>commit&nbsp;a11bef06a3f659402fe7563abf99ad00de2209e6<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sat&nbsp;Mar&nbsp;15&nbsp;10:31:28&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;commit<br></br></tt></p>
<p>По умолчанию, без аргументов, <tt>git log</tt> выводит список коммитов созданных в данном репозитории в обратном хронологическом порядке. То есть самые последние коммиты показываются первыми. Как вы можете видеть, эта команда отображает каждый коммит вместе с его контрольной суммой SHA-1, именем и электронной почтой автора, датой создания и комментарием.</p>
<p>Существует превеликое множество параметров команды <tt>git log</tt> и их комбинаций, для того чтобы показать вам именно то, что вы ищете. Здесь мы покажем вам несколько наиболее часто применяемых.</p>
<p>Один из наиболее полезных параметров &mdash; это <tt>-p</tt>, который показывает дельту (разницу/diff), привнесенную каждым коммитом. Вы также можете использовать <tt>-2</tt>, что ограничит вывод до 2-х последних записей:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-p&nbsp;-2<br></br>commit&nbsp;ca82a6dff817ec66f44342007202690a93763949<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Mon&nbsp;Mar&nbsp;17&nbsp;21:52:11&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;changed&nbsp;the&nbsp;version&nbsp;number<br></br><br></br>diff&nbsp;--git&nbsp;a/Rakefile&nbsp;b/Rakefile<br></br>index&nbsp;a874b73..8f94139&nbsp;100644<br></br>---&nbsp;a/Rakefile<br></br>+++&nbsp;b/Rakefile<br></br>@@&nbsp;-5,5&nbsp;+5,5&nbsp;@@&nbsp;require&nbsp;'rake/gempackagetask'<br></br>&nbsp;spec&nbsp;=&nbsp;Gem::Specification.new&nbsp;do&nbsp;|s|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"simplegit"<br></br>-&nbsp;&nbsp;&nbsp;&nbsp;s.version&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"0.1.0"<br></br>+&nbsp;&nbsp;&nbsp;&nbsp;s.version&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"0.1.1"<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.author&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"Scott&nbsp;Chacon"<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.email&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"schacon@gee-mail.com<br></br><br></br>commit&nbsp;085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sat&nbsp;Mar&nbsp;15&nbsp;16:40:33&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;unnecessary&nbsp;test&nbsp;code<br></br><br></br>diff&nbsp;--git&nbsp;a/lib/simplegit.rb&nbsp;b/lib/simplegit.rb<br></br>index&nbsp;a0a60ae..47c6340&nbsp;100644<br></br>---&nbsp;a/lib/simplegit.rb<br></br>+++&nbsp;b/lib/simplegit.rb<br></br>@@&nbsp;-18,8&nbsp;+18,3&nbsp;@@&nbsp;class&nbsp;SimpleGit<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br></br><br></br>&nbsp;end<br></br>-<br></br>-if&nbsp;$0&nbsp;==&nbsp;__FILE__<br></br>-&nbsp;&nbsp;git&nbsp;=&nbsp;SimpleGit.new<br></br>-&nbsp;&nbsp;puts&nbsp;git.show<br></br>-end<br></br>\&nbsp;No&nbsp;newline&nbsp;at&nbsp;end&nbsp;of&nbsp;file<br></br></tt></p>
<p>Этот параметр показывает ту же самую информацию плюс внесённые изменения, отображаемые непосредственно после каждого коммита. Это очень удобно для инспекций кода или для того, чтобы быстро посмотреть, что происходило в результате последовательности коммитов, добавленных коллегой.</p>
<p>В некоторых ситуациях гораздо удобней просматривать внесённые изменения на уровне слов, а не на уровне строк. Чтобы получить дельту по словам вместо обычной дельты по строкам, нужно дописать после команды <tt>git log -p</tt> опцию <tt>--word-diff</tt>. Дельты на уровне слов практически бесполезны при работе над программным кодом, но они буду очень кстати при работе над длинным текстом, таким как книга или диссертация. Рассмотрим пример:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-U1&nbsp;--word-diff<br></br>commit&nbsp;ca82a6dff817ec66f44342007202690a93763949<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Mon&nbsp;Mar&nbsp;17&nbsp;21:52:11&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;changed&nbsp;the&nbsp;version&nbsp;number<br></br><br></br>diff&nbsp;--git&nbsp;a/Rakefile&nbsp;b/Rakefile<br></br>index&nbsp;a874b73..8f94139&nbsp;100644<br></br>---&nbsp;a/Rakefile<br></br>+++&nbsp;b/Rakefile<br></br>@@&nbsp;-7,3&nbsp;+7,3&nbsp;@@&nbsp;spec&nbsp;=&nbsp;Gem::Specification.new&nbsp;do&nbsp;|s|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;s.name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"simplegit"<br></br>&nbsp;&nbsp;&nbsp;&nbsp;s.version&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;[-"0.1.0"-]{+"0.1.1"+}<br></br>&nbsp;&nbsp;&nbsp;&nbsp;s.author&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"Scott&nbsp;Chacon"<br></br></tt></p>
<p>Как видите, в этом выводе нет ни добавленных ни удалённых строк, как для обычного diff'а. Вместо этого изменения показаны внутри строки. Добавленное слово заключено в <tt>{+ +}</tt>, а удалённое в <tt>[- -]</tt>. Также может быть полезно сократить обычные три строки контекста в выводе команды <tt>diff</tt> до одной строки, так как контекстом в данном случае являются слова, а не строки. Сделать это можно с помощью опции <tt>-U1</tt> как было показано в примере выше.</p>
<p>С командой <tt>git log</tt> вы также можете использовать группы суммирующих параметров. Например, если вы хотите получить некоторую краткую статистику по каждому коммиту, вы можете использовать параметр <tt>--stat</tt>:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--stat<br></br>commit&nbsp;ca82a6dff817ec66f44342007202690a93763949<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Mon&nbsp;Mar&nbsp;17&nbsp;21:52:11&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;changed&nbsp;the&nbsp;version&nbsp;number<br></br><br></br>&nbsp;Rakefile&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;+-<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br><br></br>commit&nbsp;085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sat&nbsp;Mar&nbsp;15&nbsp;16:40:33&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;unnecessary&nbsp;test&nbsp;code<br></br><br></br>&nbsp;lib/simplegit.rb&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;-----<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;0&nbsp;insertions(+),&nbsp;5&nbsp;deletions(-)<br></br><br></br>commit&nbsp;a11bef06a3f659402fe7563abf99ad00de2209e6<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sat&nbsp;Mar&nbsp;15&nbsp;10:31:28&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;commit<br></br><br></br>&nbsp;README&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;++++++<br></br>&nbsp;Rakefile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;23&nbsp;+++++++++++++++++++++++<br></br>&nbsp;lib/simplegit.rb&nbsp;|&nbsp;&nbsp;&nbsp;25&nbsp;+++++++++++++++++++++++++<br></br>&nbsp;3&nbsp;files&nbsp;changed,&nbsp;54&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p>Как видно из лога, параметр <tt>--stat</tt> выводит под каждым коммитом список изменённых файлов, количество изменённых файлов, а также количество добавленных и удалённых строк в этих файлах. Он также выводит сводную информацию в конце. Другой действительно полезный параметр &mdash; это <tt>--pretty</tt>. Он позволяет изменить формат вывода лога. Для вас доступны несколько предустановленных вариантов. Параметр <tt>oneline</tt> выводит каждый коммит в одну строку, что удобно если вы просматриваете большое количество коммитов. В дополнение к этому, параметры <tt>short</tt>, <tt>full</tt>, и <tt>fuller</tt>, практически не меняя формат вывода, позволяют выводить меньше или больше деталей соответственно:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=oneline<br></br>ca82a6dff817ec66f44342007202690a93763949&nbsp;changed&nbsp;the&nbsp;version&nbsp;number<br></br>085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7&nbsp;removed&nbsp;unnecessary&nbsp;test&nbsp;code<br></br>a11bef06a3f659402fe7563abf99ad00de2209e6&nbsp;first&nbsp;commit<br></br></tt></p>
<p>Наиболее интересный параметр &mdash; это <tt>format</tt>, который позволяет вам полностью создать собственный формат вывода лога. Это особенно полезно, когда вы создаёте отчёты для автоматического разбора (парсинга) &mdash; поскольку вы явно задаёте формат и уверены в том, что он не будет изменяться при обновлениях Git'а:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=format:"%h&nbsp;-&nbsp;%an,&nbsp;%ar&nbsp;:&nbsp;%s"<br></br>ca82a6d&nbsp;-&nbsp;Scott&nbsp;Chacon,&nbsp;11&nbsp;months&nbsp;ago&nbsp;:&nbsp;changed&nbsp;the&nbsp;version&nbsp;number<br></br>085bb3b&nbsp;-&nbsp;Scott&nbsp;Chacon,&nbsp;11&nbsp;months&nbsp;ago&nbsp;:&nbsp;removed&nbsp;unnecessary&nbsp;test&nbsp;code<br></br>a11bef0&nbsp;-&nbsp;Scott&nbsp;Chacon,&nbsp;11&nbsp;months&nbsp;ago&nbsp;:&nbsp;first&nbsp;commit<br></br></tt></p>
<p>Таблица 2-1 содержит список наиболее полезных параметров формата.</p>
<p><tt>Параметр&nbsp;&nbsp;&nbsp;&nbsp;Описание&nbsp;выводимых&nbsp;данных<br></br>%H&nbsp;&nbsp;Хеш&nbsp;коммита<br></br>%h&nbsp;&nbsp;Сокращённый&nbsp;хеш&nbsp;коммита<br></br>%T&nbsp;&nbsp;Хеш&nbsp;дерева<br></br>%t&nbsp;&nbsp;Сокращённый&nbsp;хеш&nbsp;дерева<br></br>%P&nbsp;&nbsp;Хеши&nbsp;родительских&nbsp;коммитов<br></br>%p&nbsp;&nbsp;Сокращённые&nbsp;хеши&nbsp;родительских&nbsp;коммитов<br></br>%an&nbsp;Имя&nbsp;автора<br></br>%ae&nbsp;Электронная&nbsp;почта&nbsp;автора<br></br>%ad&nbsp;Дата&nbsp;автора&nbsp;(формат&nbsp;соответствует&nbsp;параметру&nbsp;`--date=`)<br></br>%ar&nbsp;Дата&nbsp;автора,&nbsp;относительная&nbsp;(пр.&nbsp;"2&nbsp;мес.&nbsp;назад")<br></br>%cn&nbsp;Имя&nbsp;коммитера<br></br>%ce&nbsp;Электронная&nbsp;почта&nbsp;коммитера<br></br>%cd&nbsp;Дата&nbsp;коммитера<br></br>%cr&nbsp;Дата&nbsp;коммитера,&nbsp;относительная<br></br>%s&nbsp;&nbsp;Комментарий<br></br></tt></p>
<p>Вас может заинтересовать, в чём же разница между <span><i>автором</i></span> и <span><i>коммитером</i></span>. Автор &mdash; это человек, изначально сделавший работу, тогда как коммитер &mdash; это человек, который последним применил эту работу. Так что если вы послали патч (заплатку) в проект и один из основных разработчиков применил этот патч, вы оба не будете забыты &mdash; вы как автор, а разработчик как коммитер. Мы чуть подробнее рассмотрим это различие в главе 5.</p>
<p>Параметры <tt>oneline</tt> и <tt>format</tt> также полезны с другим параметром команды <tt>log</tt> &mdash; <tt>--graph</tt>. Этот параметр добавляет миленький ASCII-граф, показывающий историю ветвлений и слияний. Один из таких можно увидеть для нашей копии репозитория проекта Grit:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=format:"%h&nbsp;%s"&nbsp;--graph<br></br>*&nbsp;2d3acf9&nbsp;ignore&nbsp;errors&nbsp;from&nbsp;SIGCHLD&nbsp;on&nbsp;trap<br></br>*&nbsp;&nbsp;5e3ee11&nbsp;Merge&nbsp;branch&nbsp;'master'&nbsp;of&nbsp;git://github.com/dustin/grit<br></br>|\<br></br>|&nbsp;*&nbsp;420eac9&nbsp;Added&nbsp;a&nbsp;method&nbsp;for&nbsp;getting&nbsp;the&nbsp;current&nbsp;branch.<br></br>*&nbsp;|&nbsp;30e367c&nbsp;timeout&nbsp;code&nbsp;and&nbsp;tests<br></br>*&nbsp;|&nbsp;5a09431&nbsp;add&nbsp;timeout&nbsp;protection&nbsp;to&nbsp;grit<br></br>*&nbsp;|&nbsp;e1193f8&nbsp;support&nbsp;for&nbsp;heads&nbsp;with&nbsp;slashes&nbsp;in&nbsp;them<br></br>|/<br></br>*&nbsp;d6016bc&nbsp;require&nbsp;time&nbsp;for&nbsp;xmlschema<br></br>*&nbsp;&nbsp;11d191e&nbsp;Merge&nbsp;branch&nbsp;'defunkt'&nbsp;into&nbsp;local<br></br></tt></p>
<p>Мы рассмотрели только самые простые параметры форматирования вывода для <tt>git log</tt> &mdash; их гораздо больше. Таблица 2-2 содержит как уже рассмотренные нами параметры, так и другие полезные параметры вместе с описанием того, как они влияют на вывод команды <tt>log</tt>.</p>
<p><tt>Параметр&nbsp;&nbsp;&nbsp;&nbsp;Описание<br></br>-p&nbsp;&nbsp;Для&nbsp;каждого&nbsp;коммита&nbsp;показывать&nbsp;дельту&nbsp;внесённых&nbsp;им&nbsp;изменений.<br></br>--word-diff&nbsp;Показывать&nbsp;изменения&nbsp;на&nbsp;уровне&nbsp;слов.<br></br>--stat&nbsp;&nbsp;Для&nbsp;каждого&nbsp;коммита&nbsp;дополнительно&nbsp;выводить&nbsp;статистику&nbsp;по&nbsp;изменённым&nbsp;файлам.<br></br>--shortstat&nbsp;Показывать&nbsp;только&nbsp;строку&nbsp;changed/insertions/deletions&nbsp;от&nbsp;вывода&nbsp;с&nbsp;опцией&nbsp;`--stat`.<br></br>--name-only&nbsp;Показывать&nbsp;список&nbsp;изменённых&nbsp;файлов&nbsp;после&nbsp;информации&nbsp;о&nbsp;коммите.<br></br>--name-status&nbsp;&nbsp;&nbsp;Выводить&nbsp;список&nbsp;изменённых&nbsp;файлов&nbsp;вместе&nbsp;с&nbsp;информацией&nbsp;о&nbsp;добавлении/изменении/удалении.<br></br>--abbrev-commit&nbsp;Выводить&nbsp;только&nbsp;первые&nbsp;несколько&nbsp;символов&nbsp;контрольной&nbsp;суммы&nbsp;SHA-1&nbsp;вместо&nbsp;всех&nbsp;40.<br></br>--relative-date&nbsp;Выводить&nbsp;дату&nbsp;в&nbsp;относительном&nbsp;формате&nbsp;(например,&nbsp;"2&nbsp;weeks&nbsp;ago")&nbsp;вместо&nbsp;полной&nbsp;даты.<br></br>--graph&nbsp;Показывать&nbsp;ASCII-граф&nbsp;истории&nbsp;ветвлений&nbsp;и&nbsp;слияний&nbsp;рядом&nbsp;с&nbsp;выводом&nbsp;лога.<br></br>--pretty&nbsp;&nbsp;&nbsp;&nbsp;Отображать&nbsp;коммиты&nbsp;в&nbsp;альтернативном&nbsp;формате.&nbsp;Возможные&nbsp;параметры:&nbsp;`oneline`,&nbsp;`short`,&nbsp;`full`,&nbsp;`fuller`&nbsp;и&nbsp;`format`&nbsp;(где&nbsp;вы&nbsp;можете&nbsp;указать&nbsp;свой&nbsp;собственный&nbsp;формат).<br></br></tt></p>
<p id="calibre_link-40"><span><span><b>Ограничение вывода команды log</b></span></span></p>
<p>Кроме опций для форматирования вывода, <tt>git log</tt> имеет ряд полезных ограничительных параметров, то есть параметров, которые дают возможность отобразить часть коммитов. Вы уже видели один из таких параметров &mdash; параметр <tt>-2</tt>, который отображает только два последних коммита. На самом деле, вы можете задать <tt>-&lt;n&gt;</tt>, где <tt>n</tt> это количество отображаемых коммитов. На практике вам вряд ли придётся часто этим пользоваться потому, что по умолчанию Git через канал (pipe) отправляет весь вывод на pager, так что вы всегда будете видеть только одну страницу.</p>
<p>А вот параметры, ограничивающие по времени, такие как <tt>--since</tt> и <tt>--until</tt>, весьма полезны. Например, следующая команда выдаёт список коммитов, сделанных за последние две недели:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--since=2.weeks<br></br></tt></p>
<p>Такая команда может работать с множеством форматов &mdash; вы можете указать точную дату (“2008-01-15”) или относительную дату, такую как “2 years 1 day 3 minutes ago”.</p>
<p>Вы также можете отфильтровать список коммитов по какому-либо критерию поиска. Опция <tt>--author</tt> позволяет фильтровать по автору, опция <tt>--grep</tt> позволяет искать по ключевым словам в сообщении. (Заметим, что, если вы укажете и опцию <tt>author</tt>, и опцию <tt>grep</tt>, то будут найдены все коммиты, которые удовлетворяют первому ИЛИ второму критерию. Чтобы найти коммиты, которые удовлетворяют первому И второму критерию, следует добавить опцию <tt>--all-match</tt>.)</p>
<p>Последняя действительно полезная опция-фильтр для <tt>git log</tt> &mdash; это путь. Указав имя каталога или файла, вы ограничите вывод log теми коммитами, которые вносят изменения в указанные файлы. Эта опция всегда указывается последней и обычно предваряется двумя минусами (<tt>--</tt>), чтобы отделить пути от остальных опций.</p>
<p>В таблице 2-3 для справки приведён список часто употребляемых опций.</p>
<p><tt>Опция&nbsp;&nbsp;Описание<br></br>-(n)&nbsp;&nbsp;&nbsp;&nbsp;Показать&nbsp;последние&nbsp;n&nbsp;коммитов<br></br>--since,&nbsp;--after&nbsp;&nbsp;&nbsp;&nbsp;Ограничить&nbsp;коммиты&nbsp;теми,&nbsp;которые&nbsp;сделаны&nbsp;после&nbsp;указанной&nbsp;даты.<br></br>--until,&nbsp;--before&nbsp;&nbsp;&nbsp;Ограничить&nbsp;коммиты&nbsp;теми,&nbsp;которые&nbsp;сделаны&nbsp;до&nbsp;указанной&nbsp;даты.<br></br>--author&nbsp;&nbsp;&nbsp;&nbsp;Показать&nbsp;только&nbsp;те&nbsp;коммиты,&nbsp;автор&nbsp;которых&nbsp;соответствует&nbsp;указанной&nbsp;строке.<br></br>--committer&nbsp;Показать&nbsp;только&nbsp;те&nbsp;коммиты,&nbsp;коммитер&nbsp;которых&nbsp;соответствует&nbsp;указанной&nbsp;строке.<br></br></tt></p>
<p>Например, если вы хотите посмотреть из истории Git'а такие коммиты, которые вносят изменения в тестовые файлы, были сделаны Junio Hamano, не являются слияниями и были сделаны в октябре 2008го, вы можете выполнить что-то вроде такого:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty="%h&nbsp;-&nbsp;%s"&nbsp;--author=gitster&nbsp;--since="2008-10-01"&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;--before="2008-11-01"&nbsp;--no-merges&nbsp;--&nbsp;t/<br></br>5610e3b&nbsp;-&nbsp;Fix&nbsp;testcase&nbsp;failure&nbsp;when&nbsp;extended&nbsp;attribute<br></br>acd3b9e&nbsp;-&nbsp;Enhance&nbsp;hold_lock_file_for_{update,append}()<br></br>f563754&nbsp;-&nbsp;demonstrate&nbsp;breakage&nbsp;of&nbsp;detached&nbsp;checkout&nbsp;wi<br></br>d1a43f2&nbsp;-&nbsp;reset&nbsp;--hard/read-tree&nbsp;--reset&nbsp;-u:&nbsp;remove&nbsp;un<br></br>51a94af&nbsp;-&nbsp;Fix&nbsp;"checkout&nbsp;--track&nbsp;-b&nbsp;newbranch"&nbsp;on&nbsp;detac<br></br>b0ad11e&nbsp;-&nbsp;pull:&nbsp;allow&nbsp;"git&nbsp;pull&nbsp;origin&nbsp;$something:$cur<br></br></tt></p>
<p>Из примерно 20 000 коммитов в истории Git'а, данная команда выбрала всего 6 коммитов, соответствующих заданным критериям.</p>
<p id="calibre_link-41"><span><span><b>Использование графического интерфейса для визуализации истории</b></span></span></p>
<p>Если у вас есть желание использовать какой-нибудь графический инструмент для визуализации истории коммитов, можно попробовать распространяемую вместе с Git'ом программу gitk, написанную на Tcl/Tk. В сущности gitk &mdash; это наглядный вариант <tt>git log</tt>, к тому же он принимает почти те же фильтрующие опции, что и <tt>git log</tt>. Если наберёте в командной строке gitk, находясь в проекте, то увидите что-то наподобие рис. 2-2.</p>
<p><img src="images/000037.jpg"></img></p>
<p>В верхней части окна располагается история коммитов вместе с подробным графом наследников. Просмотрщик дельт в нижней половине окна отображает изменения, сделанные выбранным коммитом. Указать коммит можно с помощью щелчка мышью.</p>
<div></div><p id="calibre_link-42"><span><span><b>Отмена изменений</b></span></span></p>
<p>На любой стадии может возникнуть необходимость что-либо отменить. Здесь мы рассмотрим несколько основных инструментов для отмены произведённых изменений. Будьте осторожны, ибо не всегда можно отменить сами отмены. Это одно из немногих мест в Git'е, где вы можете потерять свою работу если сделаете что-то неправильно.</p>
<p id="calibre_link-43"><span><span><b>Изменение последнего коммита</b></span></span></p>
<p>Одна из типичных отмен происходит тогда, когда вы делаете коммит слишком рано, забыв добавить какие-то файлы, или напутали с комментарием к коммиту. Если вам хотелось бы сделать этот коммит ещё раз, вы можете выполнить commit с опцией <tt>--amend</tt>:</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;--amend<br></br></tt></p>
<p>Эта команда берёт индекс и использует его для коммита. Если после последнего коммита не было никаких изменений (например, вы запустили приведённую команду сразу после предыдущего коммита), то состояние проекта будет абсолютно таким же и всё, что вы измените, это комментарий к коммиту.</p>
<p>Появится всё тот же редактор для комментариев к коммитам, но уже с введённым комментарием к последнему коммиту. Вы можете отредактировать это сообщение так же, как обычно, и оно перепишет предыдущее.</p>
<p>Для примера, если после совершения коммита вы осознали, что забыли проиндексировать изменения в файле, которые хотели добавить в этот коммит, вы можете сделать что-то подобное:</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'initial&nbsp;commit'<br></br>$&nbsp;git&nbsp;add&nbsp;forgotten_file<br></br>$&nbsp;git&nbsp;commit&nbsp;--amend<br></br></tt></p>
<p>Все три команды вместе дают один коммит &mdash; второй коммит заменяет результат первого.</p>
<p id="calibre_link-44"><span><span><b>Отмена индексации файла</b></span></span></p>
<p>В следующих двух разделах мы продемонстрируем, как переделать изменения в индексе и в рабочем каталоге. Приятно то, что команда, используемая для определения состояния этих двух вещей, дополнительно напоминает о том, как отменить изменения в них. Приведём пример. Допустим, вы внесли изменения в два файла и хотите записать их как два отдельных коммита, но случайно набрали <tt>git add *</tt> и проиндексировали оба файла. Как теперь отменить индексацию одного из двух файлов? Команда <tt>git status</tt> напомнит вам об этом:</p>
<p><tt>$&nbsp;git&nbsp;add&nbsp;.<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;README.txt<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br></tt></p>
<p>Сразу после надписи “Changes to be committed”, написано использовать <tt>git reset HEAD &lt;файл&gt;...</tt> для исключения из индекса. Так что давайте последуем совету и отменим индексацию файла benchmarks.rb:</p>
<p><tt>$&nbsp;git&nbsp;reset&nbsp;HEAD&nbsp;benchmarks.rb<br></br>benchmarks.rb:&nbsp;locally&nbsp;modified<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;README.txt<br></br>#<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;checkout&nbsp;--&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;discard&nbsp;changes&nbsp;in&nbsp;working&nbsp;directory)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br></tt></p>
<p>Эта команда немного странновата, но она работает. Файл benchmarks.rb изменён, но снова не в индексе.</p>
<p id="calibre_link-45"><span><span><b>Отмена изменений файла</b></span></span></p>
<p>Что, если вы поняли, что не хотите оставлять изменения, внесённые в файл benchmarks.rb? Как быстро отменить изменения, вернуть то состояние, в котором он находился во время последнего коммита (или первоначального клонирования, или какого-то другого действия, после которого файл попал в рабочий каталог)? К счастью, <tt>git status</tt> говорит, как добиться и этого. В выводе для последнего примера, неиндексированная область выглядит следующим образом:</p>
<p><tt>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;checkout&nbsp;--&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;discard&nbsp;changes&nbsp;in&nbsp;working&nbsp;directory)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;benchmarks.rb<br></br>#<br></br></tt></p>
<p>Здесь довольно ясно сказано, как отменить сделанные изменения (по крайней мере новые версии Git'а, начиная с 1.6.1, делают это; если у вас версия старее, мы настоятельно рекомендуем обновиться, чтобы получать такие подсказки и сделать свою работу удобней). Давайте сделаем то, что написано:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;--&nbsp;benchmarks.rb<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;README.txt<br></br>#<br></br></tt></p>
<p>Как вы видите, изменения были отменены. Вы должны понимать, что это опасная команда: все сделанные вами изменения в этом файле пропали &mdash; вы просто скопировали поверх него другой файл. Никогда не используйте эту команду, если вы не полностью уверены, что этот файл вам не нужен. Если вам нужно просто сделать, чтобы он не мешался, мы рассмотрим прятание (stash) и ветвление в следующей главе; эти способы обычно более предпочтительны.</p>
<p>Помните, что всё, что является частью коммита в Git'е, почти всегда может быть восстановлено. Даже коммиты, которые находятся на ветках, которые были удалены, и коммиты переписанные с помощью <tt>--amend</tt> могут быть восстановлены (см. главу 9 для восстановления данных). Несмотря на это, всё, что никогда не попадало в коммит, вы скорее всего уже не увидите снова.</p>
<div></div><p id="calibre_link-46"><span><span><b>Работа с удалёнными репозиториями</b></span></span></p>
<p>Чтобы иметь возможность совместной работы над каким-либо Git-проектом, необходимо знать, как управлять удалёнными репозиториями. Удалённые репозитории &mdash; это модификации проекта, которые хранятся в интернете или ещё где-то в сети. Их может быть несколько, каждый из которых, как правило, доступен для вас либо только на чтение, либо на чтение и запись. Совместная работа включает в себя управление удалёнными репозиториями и помещение (push) и получение (pull) данных в и из них тогда, когда нужно обменяться результатами работы. Управление удалёнными репозиториями включает умение добавлять удалённые репозитории, удалять те из них, которые больше не действуют, умение управлять различными удалёнными ветками и определять их как отслеживаемые (tracked) или нет и прочее. Данный раздел охватывает все перечисленные навыки по управлению удалёнными репозиториями.</p>
<p id="calibre_link-47"><span><span><b>Отображение удалённых репозиториев</b></span></span></p>
<p>Чтобы просмотреть, какие удалённые серверы у вас уже настроены, следует выполнить команду <tt>git remote</tt>. Она перечисляет список имён-сокращений для всех уже указанных удалённых дескрипторов. Если вы склонировали ваш репозиторий, у вас должен отобразиться, по крайней мере, origin &mdash; это имя по умолчанию, которое Git присваивает серверу, с которого вы склонировали:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;git://github.com/schacon/ticgit.git<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/private/tmp/ticgit/.git/<br></br>remote:&nbsp;Counting&nbsp;objects:&nbsp;595,&nbsp;done.<br></br>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100%&nbsp;(269/269),&nbsp;done.<br></br>remote:&nbsp;Total&nbsp;595&nbsp;(delta&nbsp;255),&nbsp;reused&nbsp;589&nbsp;(delta&nbsp;253)<br></br>Receiving&nbsp;objects:&nbsp;100%&nbsp;(595/595),&nbsp;73.31&nbsp;KiB&nbsp;|&nbsp;1&nbsp;KiB/s,&nbsp;done.<br></br>Resolving&nbsp;deltas:&nbsp;100%&nbsp;(255/255),&nbsp;done.<br></br>$&nbsp;cd&nbsp;ticgit<br></br>$&nbsp;git&nbsp;remote<br></br>origin<br></br></tt></p>
<p>Чтобы посмотреть, какому URL соответствует сокращённое имя в Git, можно указать команде опцию <tt>-v</tt>:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;-v<br></br>origin&nbsp;&nbsp;git://github.com/schacon/ticgit.git&nbsp;(fetch)<br></br>origin&nbsp;&nbsp;git://github.com/schacon/ticgit.git&nbsp;(push)<br></br></tt></p>
<p>Если у вас больше одного удалённого репозитория, команда покажет их все. Например, мой репозиторий Grit выглядит следующим образом.</p>
<p><tt>$&nbsp;cd&nbsp;grit<br></br>$&nbsp;git&nbsp;remote&nbsp;-v<br></br>bakkdoor&nbsp;&nbsp;git://github.com/bakkdoor/grit.git<br></br>cho45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git://github.com/cho45/grit.git<br></br>defunkt&nbsp;&nbsp;&nbsp;git://github.com/defunkt/grit.git<br></br>koke&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git://github.com/koke/grit.git<br></br>origin&nbsp;&nbsp;&nbsp;&nbsp;git@github.com:mojombo/grit.git<br></br></tt></p>
<p>Это означает, что мы легко можем получить изменения от любого из этих пользователей. Но, заметьте, что origin &mdash; это единственный удалённый сервер прописанный как SSH-ссылка, поэтому он единственный, в который я могу помещать свои изменения (это будет рассмотрено в главе 4).</p>
<p id="calibre_link-48"><span><span><b>Добавление удалённых репозиториев</b></span></span></p>
<p>В предыдущих разделах мы упомянули и немного продемонстрировали добавление удалённых репозиториев, сейчас мы рассмотрим это более детально. Чтобы добавить новый удалённый Git-репозиторий под именем-сокращением, к которому будет проще обращаться, выполните <tt>git remote add [сокращение] [url]</tt>:</p>
<p><tt>$&nbsp;git&nbsp;remote<br></br>origin<br></br>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;pb&nbsp;git://github.com/paulboone/ticgit.git<br></br>$&nbsp;git&nbsp;remote&nbsp;-v<br></br>origin&nbsp;&nbsp;git://github.com/schacon/ticgit.git<br></br>pb&nbsp;&nbsp;git://github.com/paulboone/ticgit.git<br></br></tt></p>
<p>Теперь вы можете использовать в командной строке имя pb вместо полного URL. Например, если вы хотите извлечь (fetch) всю информацию, которая есть в репозитории Павла, но нет в вашем, вы можете выполнить <tt>git fetch pb</tt>:</p>
<p><tt>$&nbsp;git&nbsp;fetch&nbsp;pb<br></br>remote:&nbsp;Counting&nbsp;objects:&nbsp;58,&nbsp;done.<br></br>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100%&nbsp;(41/41),&nbsp;done.<br></br>remote:&nbsp;Total&nbsp;44&nbsp;(delta&nbsp;24),&nbsp;reused&nbsp;1&nbsp;(delta&nbsp;0)<br></br>Unpacking&nbsp;objects:&nbsp;100%&nbsp;(44/44),&nbsp;done.<br></br>From&nbsp;git://github.com/paulboone/ticgit<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;pb/master<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ticgit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;pb/ticgit<br></br></tt></p>
<p>Ветка master Павла теперь доступна локально как <tt>pb/master</tt>. Вы можете слить (merge) её в одну из своих веток или перейти на эту ветку, если хотите её проверить.</p>
<p id="calibre_link-49"><span><span><b>Fetch и Pull</b></span></span></p>
<p>Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:</p>
<p><tt>$&nbsp;git&nbsp;fetch&nbsp;[имя&nbsp;удал.&nbsp;сервера]<br></br></tt></p>
<p>Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта. Теперь эти ветки в любой момент могут быть просмотрены или слиты. (В главе 3 мы перейдём к более детальному рассмотрению, что такое ветки и как их использовать.)</p>
<p>Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем origin. Таким образом, <tt>git fetch origin</tt> извлекает все наработки, отправленные (push) на этот сервер после того, как вы склонировали его (или получили изменения с помощью fetch). Важно отметить, что команда <tt>fetch</tt> забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.</p>
<p>Если у вас есть ветка, настроенная на отслеживание удалённой ветки (для дополнительной информации смотри следующий раздел и главу 3), то вы можете использовать команду <tt>git pull</tt>. Она автоматически извлекает и затем сливает данные из удалённой ветки в вашу текущую ветку. Этот способ может для вас оказаться более простым или более удобным. К тому же по умолчанию команда <tt>git clone</tt> автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали (подразумевается, что на удалённом сервере есть ветка master). Выполнение <tt>git pull</tt>, как правило, извлекает (fetch) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.</p>
<p id="calibre_link-50"><span><span><b>Push</b></span></span></p>
<p>Когда вы хотите поделиться своими наработками, вам необходимо отправить (push) их в главный репозиторий. Команда для этого действия простая: <tt>git push [удал. сервер] [ветка]</tt>. Чтобы отправить вашу ветку master на сервер <tt>origin</tt> (повторимся, что клонирование, как правило, настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки наработок на сервер:</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master<br></br></tt></p>
<p>Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а затем команду push выполняете вы, то ваш push точно будет отклонён. Вам придётся сначала вытянуть (pull) их изменения и объединить с вашими. Только после этого вам будет позволено выполнить push. Смотри главу 3 для более подробного описания, как отправлять (push) данные на удалённый сервер.</p>
<p id="calibre_link-51"><span><span><b>Инспекция удалённого репозитория</b></span></span></p>
<p>Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду <tt>git remote show [удал. сервер]</tt>. Если вы выполните эту команду с некоторым именем, например, <tt>origin</tt>, вы получите что-то подобное:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;show&nbsp;origin<br></br>*&nbsp;remote&nbsp;origin<br></br>&nbsp;&nbsp;URL:&nbsp;git://github.com/schacon/ticgit.git<br></br>&nbsp;&nbsp;Remote&nbsp;branch&nbsp;merged&nbsp;with&nbsp;'git&nbsp;pull'&nbsp;while&nbsp;on&nbsp;branch&nbsp;master<br></br>&nbsp;&nbsp;&nbsp;&nbsp;master<br></br>&nbsp;&nbsp;Tracked&nbsp;remote&nbsp;branches<br></br>&nbsp;&nbsp;&nbsp;&nbsp;master<br></br>&nbsp;&nbsp;&nbsp;&nbsp;ticgit<br></br></tt></p>
<p>Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке master, выполните <tt>git pull</tt>, ветка master с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.</p>
<p>Это был пример для простой ситуации, и наверняка вы встретились с чем-то подобным. Однако, если вы используете Git более интенсивно, вы можете увидеть гораздо большее количество информации от <tt>git remote show</tt>:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;show&nbsp;origin<br></br>*&nbsp;remote&nbsp;origin<br></br>&nbsp;&nbsp;URL:&nbsp;git@github.com:defunkt/github.git<br></br>&nbsp;&nbsp;Remote&nbsp;branch&nbsp;merged&nbsp;with&nbsp;'git&nbsp;pull'&nbsp;while&nbsp;on&nbsp;branch&nbsp;issues<br></br>&nbsp;&nbsp;&nbsp;&nbsp;issues<br></br>&nbsp;&nbsp;Remote&nbsp;branch&nbsp;merged&nbsp;with&nbsp;'git&nbsp;pull'&nbsp;while&nbsp;on&nbsp;branch&nbsp;master<br></br>&nbsp;&nbsp;&nbsp;&nbsp;master<br></br>&nbsp;&nbsp;New&nbsp;remote&nbsp;branches&nbsp;(next&nbsp;fetch&nbsp;will&nbsp;store&nbsp;in&nbsp;remotes/origin)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;caching<br></br>&nbsp;&nbsp;Stale&nbsp;tracking&nbsp;branches&nbsp;(use&nbsp;'git&nbsp;remote&nbsp;prune')<br></br>&nbsp;&nbsp;&nbsp;&nbsp;libwalker<br></br>&nbsp;&nbsp;&nbsp;&nbsp;walker2<br></br>&nbsp;&nbsp;Tracked&nbsp;remote&nbsp;branches<br></br>&nbsp;&nbsp;&nbsp;&nbsp;acl<br></br>&nbsp;&nbsp;&nbsp;&nbsp;apiv2<br></br>&nbsp;&nbsp;&nbsp;&nbsp;dashboard2<br></br>&nbsp;&nbsp;&nbsp;&nbsp;issues<br></br>&nbsp;&nbsp;&nbsp;&nbsp;master<br></br>&nbsp;&nbsp;&nbsp;&nbsp;postgres<br></br>&nbsp;&nbsp;Local&nbsp;branch&nbsp;pushed&nbsp;with&nbsp;'git&nbsp;push'<br></br>&nbsp;&nbsp;&nbsp;&nbsp;master:master<br></br></tt></p>
<p>Данная команда показывает какая именно локальная ветка будет отправлена на удалённый сервер по умолчанию при выполнении <tt>git push</tt>. Она также показывает, каких веток с удалённого сервера у вас ещё нет, какие ветки всё ещё есть у вас, но уже удалены на сервере. И для нескольких веток показано, какие удалённые ветки будут в них влиты при выполнении <tt>git pull</tt>.</p>
<p id="calibre_link-52"><span><span><b>Удаление и переименование удалённых репозиториев</b></span></span></p>
<p>Для переименования ссылок в новых версиях Git'а можно вылолнить <tt>git remote rename</tt>, это изменит сокращённое имя, используемое для удалённого репозитория. Например, если вы хотите переименовать <tt>pb</tt> в <tt>paul</tt>, вы можете сделать это следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;rename&nbsp;pb&nbsp;paul<br></br>$&nbsp;git&nbsp;remote<br></br>origin<br></br>paul<br></br></tt></p>
<p>Стоит упомянуть, что это также меняет для вас имена удалённых веток. То, к чему вы обращались как <tt>pb/master</tt>, стало <tt>paul/master</tt>.</p>
<p>Если по какой-то причине вы хотите удалить ссылку (вы сменили сервер или больше не используете определённое зеркало, или, возможно, контрибьютор перестал быть активным), вы можете использовать <tt>git remote rm</tt>:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;rm&nbsp;paul<br></br>$&nbsp;git&nbsp;remote<br></br>origin<br></br></tt></p>
<div></div><p id="calibre_link-53"><span><span><b>Работа с метками</b></span></span></p>
<p>Как и большинство СКВ, Git имеет возможность помечать (tag) определённые моменты в истории как важные. Как правило, этот функционал используется для отметки моментов выпуска версий (v1.0, и т.п.). В этом разделе вы узнаете, как посмотреть имеющиеся метки (tag), как создать новые. А также вы узнаете, что из себя представляют разные типы меток.</p>
<p id="calibre_link-54"><span><span><b>Просмотр меток</b></span></span></p>
<p>Просмотр имеющихся меток (tag) в Git'е делается просто. Достаточно набрать <tt>git tag</tt>:</p>
<p><tt>$&nbsp;git&nbsp;tag<br></br>v0.1<br></br>v1.3<br></br></tt></p>
<p>Данная команда перечисляет метки в алфавитном порядке; порядок их появления не имеет значения.</p>
<p>Для меток вы также можете осуществлять поиск по шаблону. Например, репозиторий Git'а содержит более 240 меток. Если вас интересует просмотр только выпусков 1.4.2, вы можете выполнить следующее:</p>
<p><tt>$&nbsp;git&nbsp;tag&nbsp;-l&nbsp;'v1.4.2.*'<br></br>v1.4.2.1<br></br>v1.4.2.2<br></br>v1.4.2.3<br></br>v1.4.2.4<br></br></tt></p>
<p id="calibre_link-55"><span><span><b>Создание меток</b></span></span></p>
<p>Git использует два основных типа меток: легковесные и аннотированные. Легковесная метка &mdash; это что-то весьма похожее на ветку, которая не меняется &mdash; это просто указатель на определённый коммит. А вот аннотированные метки хранятся в базе данных Git'а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG). Обычно рекомендуется создавать аннотированные метки, чтобы иметь всю перечисленную информацию; но если вы хотите сделать временную метку или по какой-то причине не хотите сохранять остальную информацию, то для этого годятся и легковесные метки.</p>
<p id="calibre_link-56"><span><span><b>Аннотированные метки</b></span></span></p>
<p>Создание аннотированной метки в Git'е выполняется легко. Самый простой способ это указать <tt>-a</tt> при выполнении команды <tt>tag</tt>:</p>
<p><tt>$&nbsp;git&nbsp;tag&nbsp;-a&nbsp;v1.4&nbsp;-m&nbsp;'my&nbsp;version&nbsp;1.4'<br></br>$&nbsp;git&nbsp;tag<br></br>v0.1<br></br>v1.3<br></br>v1.4<br></br></tt></p>
<p>Опция <tt>-m</tt> задаёт меточное сообщение, которое будет храниться вместе с меткой. Если не указать сообщение для аннотированной метки, Git запустит редактор, чтоб вы смогли его ввести.</p>
<p>Вы можете посмотреть данные метки вместе с коммитом, который был помечен, с помощью команды <tt>git show</tt>:</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;v1.4<br></br>tag&nbsp;v1.4<br></br>Tagger:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Mon&nbsp;Feb&nbsp;9&nbsp;14:45:11&nbsp;2009&nbsp;-0800<br></br><br></br>my&nbsp;version&nbsp;1.4<br></br>commit&nbsp;15027957951b64cf874c3557a0f3547bd83b3ff6<br></br>Merge:&nbsp;4a447f7...&nbsp;a6b4c97...<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sun&nbsp;Feb&nbsp;8&nbsp;19:02:46&nbsp;2009&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Merge&nbsp;branch&nbsp;'experiment'<br></br></tt></p>
<p>Она показывает информацию о выставившем метку, дату отметки коммита и аннотирующее сообщение перед информацией о коммите.</p>
<p id="calibre_link-57"><span><span><b>Подписанные метки</b></span></span></p>
<p>Вы также можете подписывать свои метки с помощью GPG, конечно, если у вас есть ключ. Всё что нужно сделать, это использовать <tt>-s</tt> вместо <tt>-a</tt>:</p>
<p><tt>$&nbsp;git&nbsp;tag&nbsp;-s&nbsp;v1.5&nbsp;-m&nbsp;'my&nbsp;signed&nbsp;1.5&nbsp;tag'<br></br>You&nbsp;need&nbsp;a&nbsp;passphrase&nbsp;to&nbsp;unlock&nbsp;the&nbsp;secret&nbsp;key&nbsp;for<br></br>user:&nbsp;"Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;"<br></br>1024-bit&nbsp;DSA&nbsp;key,&nbsp;ID&nbsp;F721C45A,&nbsp;created&nbsp;2009-02-09<br></br></tt></p>
<p>Если вы выполните <tt>git show</tt> на этой метке, то увидите прикреплённую к ней GPG-подпись:</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;v1.5<br></br>tag&nbsp;v1.5<br></br>Tagger:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Mon&nbsp;Feb&nbsp;9&nbsp;15:22:20&nbsp;2009&nbsp;-0800<br></br><br></br>my&nbsp;signed&nbsp;1.5&nbsp;tag<br></br>-----BEGIN&nbsp;PGP&nbsp;SIGNATURE-----<br></br>Version:&nbsp;GnuPG&nbsp;v1.4.8&nbsp;(Darwin)<br></br><br></br>iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN<br></br>Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/<br></br>=WryJ<br></br>-----END&nbsp;PGP&nbsp;SIGNATURE-----<br></br>commit&nbsp;15027957951b64cf874c3557a0f3547bd83b3ff6<br></br>Merge:&nbsp;4a447f7...&nbsp;a6b4c97...<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sun&nbsp;Feb&nbsp;8&nbsp;19:02:46&nbsp;2009&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Merge&nbsp;branch&nbsp;'experiment'<br></br></tt></p>
<p>Чуть позже вы узнаете, как верифицировать метки с подписью.</p>
<p id="calibre_link-58"><span><span><b>Легковесные метки</b></span></span></p>
<p>Легковесная метка &mdash; это ещё один способ отметки коммитов. В сущности, это контрольная сумма коммита, сохранённая в файл &mdash; больше никакой информации не хранится. Для создания легковесной метки не передавайте опций <tt>-a</tt>, <tt>-s</tt> и <tt>-m</tt>:</p>
<p><tt>$&nbsp;git&nbsp;tag&nbsp;v1.4-lw<br></br>$&nbsp;git&nbsp;tag<br></br>v0.1<br></br>v1.3<br></br>v1.4<br></br>v1.4-lw<br></br>v1.5<br></br></tt></p>
<p>На этот раз при выполнении <tt>git show</tt> на этой метке вы не увидите дополнительной информации. Команда просто покажет помеченный коммит:</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;v1.4-lw<br></br>commit&nbsp;15027957951b64cf874c3557a0f3547bd83b3ff6<br></br>Merge:&nbsp;4a447f7...&nbsp;a6b4c97...<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sun&nbsp;Feb&nbsp;8&nbsp;19:02:46&nbsp;2009&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Merge&nbsp;branch&nbsp;'experiment'<br></br></tt></p>
<p id="calibre_link-59"><span><span><b>Верификация меток</b></span></span></p>
<p>Для верификации подписанной метки, используйте <tt>git tag -v [имя метки]</tt>. Эта команда использует GPG для верификации подписи. Вам нужен открытый ключ автора подписи, чтобы команда работала правильно:</p>
<p><tt>$&nbsp;git&nbsp;tag&nbsp;-v&nbsp;v1.4.2.1<br></br>object&nbsp;883653babd8ee7ea23e6a5c392bb739348b1eb61<br></br>type&nbsp;commit<br></br>tag&nbsp;v1.4.2.1<br></br>tagger&nbsp;Junio&nbsp;C&nbsp;Hamano&nbsp;&lt;junkio@cox.net&gt;&nbsp;1158138501&nbsp;-0700<br></br><br></br>GIT&nbsp;1.4.2.1<br></br><br></br>Minor&nbsp;fixes&nbsp;since&nbsp;1.4.2,&nbsp;including&nbsp;git-mv&nbsp;and&nbsp;git-http&nbsp;with&nbsp;alternates.<br></br>gpg:&nbsp;Signature&nbsp;made&nbsp;Wed&nbsp;Sep&nbsp;13&nbsp;02:08:25&nbsp;2006&nbsp;PDT&nbsp;using&nbsp;DSA&nbsp;key&nbsp;ID&nbsp;F3119B9A<br></br>gpg:&nbsp;Good&nbsp;signature&nbsp;from&nbsp;"Junio&nbsp;C&nbsp;Hamano&nbsp;&lt;junkio@cox.net&gt;"<br></br>gpg:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aka&nbsp;"[jpeg&nbsp;image&nbsp;of&nbsp;size&nbsp;1513]"<br></br>Primary&nbsp;key&nbsp;fingerprint:&nbsp;3565&nbsp;2A26&nbsp;2040&nbsp;E066&nbsp;C9A7&nbsp;&nbsp;4A7D&nbsp;C0C6&nbsp;D9A4&nbsp;F311&nbsp;9B9A<br></br></tt></p>
<p>Если у вас нет открытого ключа автора подписи, вы вместо этого получите что-то подобное:</p>
<p><tt>gpg:&nbsp;Signature&nbsp;made&nbsp;Wed&nbsp;Sep&nbsp;13&nbsp;02:08:25&nbsp;2006&nbsp;PDT&nbsp;using&nbsp;DSA&nbsp;key&nbsp;ID&nbsp;F3119B9A<br></br>gpg:&nbsp;Can't&nbsp;check&nbsp;signature:&nbsp;public&nbsp;key&nbsp;not&nbsp;found<br></br>error:&nbsp;could&nbsp;not&nbsp;verify&nbsp;the&nbsp;tag&nbsp;'v1.4.2.1'<br></br></tt></p>
<p id="calibre_link-60"><span><span><b>Выставление меток позже</b></span></span></p>
<p>Также возможно помечать уже пройденные коммиты. Предположим, что история коммитов выглядит следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=oneline<br></br>15027957951b64cf874c3557a0f3547bd83b3ff6&nbsp;Merge&nbsp;branch&nbsp;'experiment'<br></br>a6b4c97498bd301d84096da251c98a07c7723e65&nbsp;beginning&nbsp;write&nbsp;support<br></br>0d52aaab4479697da7686c15f77a3d64d9165190&nbsp;one&nbsp;more&nbsp;thing<br></br>6d52a271eda8725415634dd79daabbc4d9b6008e&nbsp;Merge&nbsp;branch&nbsp;'experiment'<br></br>0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc&nbsp;added&nbsp;a&nbsp;commit&nbsp;function<br></br>4682c3261057305bdd616e23b64b0857d832627b&nbsp;added&nbsp;a&nbsp;todo&nbsp;file<br></br>166ae0c4d3f420721acbb115cc33848dfcc2121a&nbsp;started&nbsp;write&nbsp;support<br></br>9fceb02d0ae598e95dc970b74767f19372d61af8&nbsp;updated&nbsp;rakefile<br></br>964f16d36dfccde844893cac5b347e7b3d44abbc&nbsp;commit&nbsp;the&nbsp;todo<br></br>8a5cbc430f1a9c3d00faaeffd07798508422908a&nbsp;updated&nbsp;readme<br></br></tt></p>
<p>Теперь предположим, что вы забыли отметить версию проекта v1.2, которая была там, где находится коммит "updated rakefile". Вы можете добавить метку и позже. Для отметки коммита укажите его контрольную сумму (или её часть) в конце команды:</p>
<p><tt>$&nbsp;git&nbsp;tag&nbsp;-a&nbsp;v1.2&nbsp;-m&nbsp;'version&nbsp;1.2'&nbsp;9fceb02<br></br></tt></p>
<p>Можете проверить, что коммит теперь отмечен:</p>
<p><tt>$&nbsp;git&nbsp;tag<br></br>v0.1<br></br>v1.2<br></br>v1.3<br></br>v1.4<br></br>v1.4-lw<br></br>v1.5<br></br><br></br>$&nbsp;git&nbsp;show&nbsp;v1.2<br></br>tag&nbsp;v1.2<br></br>Tagger:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Mon&nbsp;Feb&nbsp;9&nbsp;15:32:16&nbsp;2009&nbsp;-0800<br></br><br></br>version&nbsp;1.2<br></br>commit&nbsp;9fceb02d0ae598e95dc970b74767f19372d61af8<br></br>Author:&nbsp;Magnus&nbsp;Chacon&nbsp;&lt;mchacon@gee-mail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sun&nbsp;Apr&nbsp;27&nbsp;20:43:35&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;updated&nbsp;rakefile<br></br>...<br></br></tt></p>
<p id="calibre_link-61"><span><span><b>Обмен метками</b></span></span></p>
<p>По умолчанию, команда <tt>git push</tt> не отправляет метки на удалённые серверы. Необходимо явно отправить (push) метки на общий сервер после того, как вы их создали. Это делается так же, как и выкладывание в совместное пользование удалённых веток &mdash; нужно выполнить <tt>git push origin [имя метки]</tt>.</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;v1.5<br></br>Counting&nbsp;objects:&nbsp;50,&nbsp;done.<br></br>Compressing&nbsp;objects:&nbsp;100%&nbsp;(38/38),&nbsp;done.<br></br>Writing&nbsp;objects:&nbsp;100%&nbsp;(44/44),&nbsp;4.56&nbsp;KiB,&nbsp;done.<br></br>Total&nbsp;44&nbsp;(delta&nbsp;18),&nbsp;reused&nbsp;8&nbsp;(delta&nbsp;1)<br></br>To&nbsp;git@github.com:schacon/simplegit.git<br></br>*&nbsp;[new&nbsp;tag]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1.5&nbsp;-&gt;&nbsp;v1.5<br></br></tt></p>
<p>Если у вас есть много меток, которые хотелось бы отправить все за один раз, можно использовать опцию <tt>--tags</tt> для команды <tt>git push</tt>. В таком случае все ваши метки отправятся на удалённый сервер (если только их уже там нет).</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;--tags<br></br>Counting&nbsp;objects:&nbsp;50,&nbsp;done.<br></br>Compressing&nbsp;objects:&nbsp;100%&nbsp;(38/38),&nbsp;done.<br></br>Writing&nbsp;objects:&nbsp;100%&nbsp;(44/44),&nbsp;4.56&nbsp;KiB,&nbsp;done.<br></br>Total&nbsp;44&nbsp;(delta&nbsp;18),&nbsp;reused&nbsp;8&nbsp;(delta&nbsp;1)<br></br>To&nbsp;git@github.com:schacon/simplegit.git<br></br>&nbsp;*&nbsp;[new&nbsp;tag]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v0.1&nbsp;-&gt;&nbsp;v0.1<br></br>&nbsp;*&nbsp;[new&nbsp;tag]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1.2&nbsp;-&gt;&nbsp;v1.2<br></br>&nbsp;*&nbsp;[new&nbsp;tag]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1.4&nbsp;-&gt;&nbsp;v1.4<br></br>&nbsp;*&nbsp;[new&nbsp;tag]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1.4-lw&nbsp;-&gt;&nbsp;v1.4-lw<br></br>&nbsp;*&nbsp;[new&nbsp;tag]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1.5&nbsp;-&gt;&nbsp;v1.5<br></br></tt></p>
<p>Теперь, если кто-то склонирует (clone) или выполнит <tt>git pull</tt> из вашего репозитория, то он получит вдобавок к остальному и ваши метки.</p>
<div></div><p id="calibre_link-62"><span><span><b>Полезные советы</b></span></span></p>
<p>Перед тем как закончить данную главу об основах Git'а, дадим несколько полезных советов о том, как сделать ваш опыт работы с Git'ом проще, удобнее или привычнее. Многие люди используют Git, не прибегая к этим советам, и мы дальше в книге не будем ссылаться на них или подразумевать, что вы ими пользуетесь, но вам всё же стоит знать о них.</p>
<p id="calibre_link-63"><span><span><b>Автоматическое дополнение</b></span></span></p>
<p>Если вы используете командную оболочку Bash, Git поставляется с замечательным сценарием (script), который вы можете активировать. Скачайте исходный код Git'а и посмотрите в каталоге <tt>contrib/completion</tt>; там должен быть файл <tt>git-completion.bash</tt>. Скопируйте этот файл в свой домашний каталог и добавьте следующее в файл <tt>.bashrc</tt>:</p>
<p><tt>source&nbsp;~/.git-completion.bash<br></br></tt></p>
<p>Если вы хотите настроить автоматическое дополнение в Bash'е для всех пользователей, скопируйте этот сценарий в каталог <tt>/opt/local/etc/bash_completion.d</tt> на Mac-системах или в каталог <tt>/etc/bash_completion.d/</tt> на Linux-системах. Это каталог, из которого Bash автоматически загружает сценарии для автодополнения.</p>
<p>Если вы используете Git Bash на Windows, что является стандартным при установке Git'а на Windows с помощью msysGit, то автодополнение должно быть настроено заранее.</p>
<p>Нажав Tab во время ввода команды для Git'а, вы должны получить набор вариантов на выбор:</p>
<p><tt>$&nbsp;git&nbsp;co&lt;tab&gt;&lt;tab&gt;<br></br>commit&nbsp;config<br></br></tt></p>
<p>В данном случае, набрав <tt>git co</tt> и дважды нажав клавишу Tab, вы получите как варианты commit и config. Добавление <tt>m&lt;tab&gt;</tt> выполнит дополнение до <tt>git commit</tt> автоматически.</p>
<p>То же самое работает и для опций, что, возможно, полезней. Например, если вы хотите выполнить команду <tt>git log</tt> и не помните какую-то опцию, вы можете начать её печатать и затем нажать Tab, чтобы увидеть, что подходит:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--s&lt;tab&gt;<br></br>--shortstat&nbsp;&nbsp;--since=&nbsp;&nbsp;--src-prefix=&nbsp;&nbsp;--stat&nbsp;&nbsp;&nbsp;--summary<br></br></tt></p>
<p>Это довольно приятная уловка, которая может сэкономить вам немного рабочего времени от чтения документации.</p>
<p id="calibre_link-64"><span><span><b>Псевдонимы в Git</b></span></span></p>
<p>Git не будет пытаться сделать вывод о том, какую команду вы хотели ввести, если вы ввели её неполностью. Если вы не хотите печатать каждую команду для Git'а целиком, вы легко можете настроить псевдонимы (alias) для любой команды с помощью <tt>git config</tt>. Вот несколько примеров псевдонимов, которые вы, возможно, захотите задать:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;alias.co&nbsp;checkout<br></br>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;alias.br&nbsp;branch<br></br>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;alias.ci&nbsp;commit<br></br>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;alias.st&nbsp;status<br></br></tt></p>
<p>Это означает, что, например, вместо набирания <tt>git commit</tt>, вам достаточно набрать только <tt>git ci</tt>. По мере освоения Git'а вам, вероятно, придётся часто пользоваться и другими командами. В этом случае без колебаний создавайте новые псевдонимы.</p>
<p>Такой способ может также быть полезен для создания команд, которые, вы думаете, должны существовать. Например, чтобы исправить неудобство, с которым мы столкнулись при исключении файла из индекса, можно добавить в Git свой собственный псевдоним unstage:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;alias.unstage&nbsp;'reset&nbsp;HEAD&nbsp;--'<br></br></tt></p>
<p>Это делает следующие две команды эквивалентными:</p>
<p><tt>$&nbsp;git&nbsp;unstage&nbsp;fileA<br></br>$&nbsp;git&nbsp;reset&nbsp;HEAD&nbsp;fileA<br></br></tt></p>
<p>Так как будто немного понятней. Также обычно добавляют команду <tt>last</tt> следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;alias.last&nbsp;'log&nbsp;-1&nbsp;HEAD'<br></br></tt></p>
<p>Так легко можно просмотреть последний коммит:</p>
<p><tt>$&nbsp;git&nbsp;last<br></br>commit&nbsp;66938dae3329c7aebe598c2246a8e6af90d04646<br></br>Author:&nbsp;Josh&nbsp;Goebel&nbsp;&lt;dreamer3@example.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Tue&nbsp;Aug&nbsp;26&nbsp;19:48:51&nbsp;2008&nbsp;+0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;test&nbsp;for&nbsp;current&nbsp;head<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Signed-off-by:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@example.com&gt;<br></br></tt></p>
<p>Можно сказать, что Git просто заменяет эти новые команды на то, для чего вы создавали псевдоним (alias). Однако, возможно, вы захотите выполнять внешнюю команду, а не подкоманду Git'а. В этом случае, следует начать команду с символа <tt>!</tt>. Такое полезно, если вы пишите свои утилиты для работы с Git-репозиторием. Продемонстрируем этот случай на примере создания псевдонима <tt>git visual</tt> для запуска <tt>gitk</tt>:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;alias.visual&nbsp;'!gitk'<br></br></tt></p>
<div></div><p id="calibre_link-65"><span><span><b>Итоги</b></span></span></p>
<p>К этому моменту вы умеете выполнять все базовые локальные операции с Git'ом: создавать или клонировать репозиторий, вносить изменения, индексировать и фиксировать эти изменения, а также просматривать историю всех изменений в репозитории. Дальше мы рассмотрим самую убийственную особенность Git'а &mdash; его модель ветвления.</p>
<div></div><p id="calibre_link-66"><span><span><b>Ветвление в Git</b></span></span></p>
<p>Почти каждая СКВ имеет в какой-то форме поддержку ветвления. Ветвление означает, что вы отклоняетесь от основной линии разработки и продолжаете работу, не вмешиваясь в основную линию. Во многих СКВ это в некотором роде дорогостоящий процесс, зачастую требующий от вас создания новой копии каталога с исходным кодом, что может занять продолжительное время для больших проектов.</p>
<p>Некоторые говорят, что модель ветвления Git'а это его “killer feature“ и она безусловно выделяет Git в СКВ-сообществе. Что же в ней такого особенного? Способ ветвления в Git'е чрезвычайно легковесен, что делает операции ветвления практически мгновенными и переключение туда-сюда между ветками обычно так же быстрым. В отличие от многих других СКВ, Git поощряет процесс работы, при котором ветвление и слияние осуществляется часто, даже по несколько раз в день. Понимание и владение этой функциональностью даёт вам уникальный мощный инструмент и может буквально изменить то, как вы ведёте разработку.</p>
<div></div><p id="calibre_link-67"><span><span><b>Что такое ветка?</b></span></span></p>
<p>Чтобы на самом деле разобраться в том, как Git работает с ветками, мы должны сделать шаг назад и рассмотреть, как Git хранит свои данные. Как вы, наверное, помните из главы 1, Git хранит данные не как последовательность изменений или дельт, а как последовательность снимков состояния (snapshot).</p>
<p>Когда вы создаёте коммит в Git'е, Git записывает в базу объект-коммит, который содержит указатель на снимок состояния, записанный ранее в индекс, метаданные автора и комментария и ноль и более указателей на коммиты, являющиеся прямыми предками этого коммита: ноль предков для первого коммита, один &mdash; для обычного коммита и несколько &mdash; для коммита, полученного в результате слияния двух или более веток.</p>
<p>Для наглядности давайте предположим, что у вас есть каталог, содержащий три файла, и вы хотите добавить их все в индекс и сделать коммит. При добавлении файлов в индекс для каждого из них вычислится контрольная сумма (SHA-1 хеш, о котором мы упоминали в главе 1), затем эти версии файлов будут сохранены в Git-репозиторий (Git обращается к ним как к двоичным данным), а их контрольные суммы добавятся в индекс:</p>
<p><tt>$&nbsp;git&nbsp;add&nbsp;README&nbsp;test.rb&nbsp;LICENSE<br></br>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'initial&nbsp;commit&nbsp;of&nbsp;my&nbsp;project'<br></br></tt></p>
<p>Когда вы создаёте коммит, выполняя <tt>git commit</tt>, Git вычисляет контрольную сумму каждого подкаталога (в нашем случае только корневого каталога) и сохраняет эти объекты-деревья в Git-репозиторий. Затем Git создаёт объект для коммита, в котором есть метаданные и указатель на объект-дерево для корня проекта. Таким образом, Git сможет воссоздать текущее состояние, когда будет нужно.</p>
<p>Ваш Git-репозиторий теперь содержит пять объектов: по одному блобу для содержимого каждого из трёх файлов, одно дерево, в котором перечислено содержимое каталога и определено соответствие имён файлов и блобов, и один коммит с указателем на тот самый объект-дерево для корня и со всеми метаданными коммита. Схематично данные в этом Git-репозитории выглядят так, как показано на рисунке 3-1.</p>
<p><img src="images/000026.jpg"></img></p>
<p>Если вы сделаете некоторые изменения и создадите новый коммит, то следующий коммит сохранит указатель на коммит, который шёл непосредственно перед ним. После следующих двух коммитов история может выглядеть, как на рисунке 3-2.</p>
<p><img src="images/000022.jpg"></img></p>
<p>Ветка в Git'е &mdash; это просто легковесный подвижный указатель на один из этих коммитов. Ветка по умолчанию в Git'е называется <tt>master</tt>. Когда вы создаёте коммиты на начальном этапе, вам дана ветка <tt>master</tt>, указывающая на последний сделанный коммит. При каждом новом коммите она сдвигается вперёд автоматически.</p>
<p><img src="images/000084.jpg"></img></p>
<p>Что произойдёт, если вы создадите новую ветку? Итак, этим вы создадите новый указатель, который можно будет перемещать. Скажем, создадим новую ветку под названием <tt>testing</tt>. Это делается командой <tt>git branch</tt>:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;testing<br></br></tt></p>
<p>Эта команда создаст новый указатель на тот самый коммит, на котором вы сейчас находитесь (см. рис. 3-4).</p>
<p><img src="images/000020.jpg"></img></p>
<p>Откуда Git узнает, на какой ветке вы находитесь в данный момент? Он хранит специальный указатель, который называется HEAD (верхушка). Учтите, что это сильно отличается от концепции HEAD в других СКВ, таких как Subversion или CVS, к которым вы, возможно, привыкли. В Git'е это указатель на локальную ветку, на которой вы находитесь. В данный момент вы всё ещё на ветке <tt>master</tt>. Команда <tt>git branch</tt> только создала новую ветку, она не переключила вас на неё (см. рис. 3-5).</p>
<p><img src="images/000040.jpg"></img></p>
<p>Чтобы перейти на существующую ветку, вам надо выполнить команду <tt>git checkout</tt>. Давайте перейдём на новую ветку <tt>testing</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;testing<br></br></tt></p>
<p>Это действие передвинет HEAD так, чтобы тот указывал на ветку <tt>testing</tt> (см. рис. 3-6).</p>
<p><img src="images/000039.jpg"></img></p>
<p>В чём же важность этого? Давайте сделаем ещё один коммит:</p>
<p><tt>$&nbsp;vim&nbsp;test.rb<br></br>$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'made&nbsp;a&nbsp;change'<br></br></tt></p>
<p>На рисунке 3-7 показан результат.</p>
<p><img src="images/000047.jpg"></img></p>
<p>Это интересно, потому что теперь ваша ветка <tt>testing</tt> передвинулась вперёд, но ветка <tt>master</tt> всё ещё указывает на коммит, на котором вы были, когда выполняли <tt>git checkout</tt>, чтобы переключить ветки. Давайте перейдём обратно на ветку <tt>master</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;master<br></br></tt></p>
<p>На рисунке 3-8 можно увидеть результат.</p>
<p><img src="images/000074.jpg"></img></p>
<p>Эта команда выполнила два действия. Она передвинула указатель HEAD назад на ветку <tt>master</tt> и вернула файлы в вашем рабочем каталоге назад, в соответствие со снимком состояния, на который указывает <tt>master</tt>. Это также означает, что изменения, которые вы делаете, начиная с этого момента, будут ответвляться от старой версии проекта. Это, по сути, откатывает изменения, которые вы временно делали на ветке <tt>testing</tt>, так что дальше вы можете двигаться в другом направлении.</p>
<p>Давайте снова внесём немного изменений и сделаем коммит:</p>
<p><tt>$&nbsp;vim&nbsp;test.rb<br></br>$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'made&nbsp;other&nbsp;changes'<br></br></tt></p>
<p>Теперь история вашего проекта разветвилась (см. рис. 3-9). Вы создали новую ветку, перешли на неё, поработали на ней немного, переключились обратно на основную ветку и выполнили другую работу. Оба эти изменения изолированы в отдельных ветках: вы можете переключаться туда и обратно между ветками и слить их, когда будете готовы. И всё это было сделано простыми командами <tt>branch</tt> и <tt>checkout</tt>.</p>
<p><img src="images/000060.jpg"></img></p>
<p>Из-за того, что ветка в Git'е на самом деле является простым файлом, который содержит 40 символов контрольной суммы SHA-1 коммита, на который он указывает, создание и удаление веток практически беззатратно. Создание новой ветки настолько же быстрое и простое, как запись 41 байта в файл (40 символов + символ новой строки).</p>
<p>Это разительно отличается от того, как в большинстве СКВ делается ветвление. Там это приводит к копированию всех файлов проекта в другой каталог. Это может занять несколько секунд или даже минут, в зависимости от размера проекта, тогда как в Git'е это всегда происходит моментально. Также благодаря тому, что мы запоминаем предков для каждого коммита, поиск нужной базовой версии для слияния уже автоматически выполнен за нас, и в общем случае слияние делается легко. Эти особенности помогают поощрять разработчиков к частому созданию и использованию веток.</p>
<p>Давайте поймём, почему и вам стоит так делать.</p>
<div></div><p id="calibre_link-68"><span><span><b>Основы ветвления и слияния</b></span></span></p>
<p>Давайте рассмотрим ветвление и слияние на простом примере с таким процессом работы, который вы могли бы использовать в настоящей разработке. Мы выполним следующие шаги:</p>
<div>&nbsp;</div><ol><li value="1">Поработаем над веб-сайтом.</li><li value="2">Создадим ветку для работы над новой задачей.</li><li value="3">Выполним некоторую работу на этой ветке.</li></ol><p>На этом этапе вам поступит звонок о том, что сейчас критична другая проблема, и её надо срочно решить. Мы сделаем следующее:</p>
<div>&nbsp;</div><ol><li value="1">Вернёмся на ветку для версии в производстве.</li><li value="2">Создадим ветку для исправления ошибки.</li><li value="3">После тестирования ветки с исправлением сольём её обратно и отправим в продакшн.</li><li value="4">Вернёмся к своей исходной задаче и продолжим работать над ней.</li></ol><p id="calibre_link-69"><span><span><b>Основы ветвления</b></span></span></p>
<p>Для начала представим, что вы работаете над своим проектом и уже имеете пару коммитов (см. рис. 3-10).</p>
<p><img src="images/000066.jpg"></img></p>
<p>Вы решили, что вы будете работать над проблемой №53 из системы отслеживания ошибок, используемой вашей компанией. Разумеется, Git не привязан к какой-то определенной системе отслеживания ошибок. Так как проблема №53 является обособленной задачей, над которой вы собираетесь работать, мы создадим новую ветку и будем работать на ней. Чтобы создать ветку и сразу же перейти на неё, вы можете выполнить команду <tt>git checkout</tt> с ключом <tt>-b</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;iss53<br></br>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;"iss53"<br></br></tt></p>
<p>Это сокращение для:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;iss53<br></br>$&nbsp;git&nbsp;checkout&nbsp;iss53<br></br></tt></p>
<p>Рисунок 3-11 демонстрирует результат.</p>
<p><img src="images/000034.jpg"></img></p>
<p>Во время работы над своим веб-сайтом вы делаете несколько коммитов. Эти действия сдвигают ветку <tt>iss53</tt> вперёд потому, что вы на неё перешли (то есть ваш HEAD указывает на неё; см. рис. 3-12):</p>
<p><tt>$&nbsp;vim&nbsp;index.html<br></br>$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'added&nbsp;a&nbsp;new&nbsp;footer&nbsp;[issue&nbsp;53]'<br></br></tt></p>
<p><img src="images/000068.jpg"></img></p>
<p>Теперь вы получаете звонок о том, что есть проблема с веб-сайтом, которую необходимо немедленно устранить. С Git'ом вам нет нужды делать исправления для неё поверх тех изменений, которые вы уже сделали в <tt>iss53</tt>, и нет необходимости прикладывать много усилий для отмены этих изменений перед тем, как вы сможете начать работать над решением срочной проблемы. Всё, что вам нужно сделать, это перейти на ветку <tt>master</tt>.</p>
<p>Однако, прежде чем сделать это, учтите, что если в вашем рабочем каталоге или индексе имеются незафиксированные изменения, которые конфликтуют с веткой, на которую вы переходите, Git не позволит переключить ветки. Лучше всего при переключении веток иметь чистое рабочее состояние. Существует несколько способов добиться этого (а именно, прятанье (stash) работы и правка (amend) коммита), которые мы рассмотрим позже. А на данный момент представим, что все изменения были добавлены в коммит, и теперь вы можете переключиться обратно на ветку <tt>master</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>Switched&nbsp;to&nbsp;branch&nbsp;"master"<br></br></tt></p>
<p>Теперь рабочий каталог проекта находится точно в таком же состоянии, что и в момент начала работы над проблемой №53, так что вы можете сконцентрироваться на исправлении срочной проблемы. Очень важно запомнить: Git возвращает ваш рабочий каталог к снимку состояния того коммита, на который указывает ветка, на которую вы переходите. Он добавляет, удаляет и изменяет файлы автоматически, чтобы гарантировать, что состояние вашей рабочей копии идентично последнему коммиту на ветке.</p>
<p>Итак, вам надо срочно исправить ошибку. Давайте создадим для этого ветку, на которой вы будете работать (см. рис. 3-13):</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;hotfix<br></br>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;"hotfix"<br></br>$&nbsp;vim&nbsp;index.html<br></br>$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'fixed&nbsp;the&nbsp;broken&nbsp;email&nbsp;address'<br></br>[hotfix]:&nbsp;created&nbsp;3a0874c:&nbsp;"fixed&nbsp;the&nbsp;broken&nbsp;email&nbsp;address"<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;0&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br></tt></p>
<p><img src="images/000042.jpg"></img></p>
<p>Вы можете запустить тесты, убедиться, что решение работает, и слить (merge) изменения назад в ветку <tt>master</tt>, чтобы включить их в продукт. Это делается с помощью команды <tt>git merge</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>$&nbsp;git&nbsp;merge&nbsp;hotfix<br></br>Updating&nbsp;f42c576..3a0874c<br></br>Fast&nbsp;forward<br></br>&nbsp;README&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;0&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br></tt></p>
<p>Наверное, вы заметили фразу "Fast forward" в этом слиянии. Так как ветка, которую мы слили, указывала на коммит, являющийся прямым родителем коммита, на котором мы сейчас находимся, Git просто сдвинул её указатель вперёд. Иными словами, когда вы пытаетесь слить один коммит с другим таким, которого можно достигнуть, проследовав по истории первого коммита, Git поступает проще, перемещая указатель вперёд, так как нет расходящихся изменений, которые нужно было бы сливать воедино. Это называется "перемотка" (fast forward).</p>
<p>Ваши изменения теперь в снимке состояния коммита, на который указывает ветка <tt>master</tt>, и вы можете включить изменения в продукт (см. рис. 3-14).</p>
<p><img src="images/000054.jpg"></img></p>
<p>После того как очень важная проблема решена, вы готовы вернуться обратно к тому, над чем вы работали перед тем, как вас прервали. Однако, сначала удалите ветку <tt>hotfix</tt>, так как она больше не нужна &mdash; ветка <tt>master</tt> уже указывает на то же место. Вы можете удалить ветку с помощью опции <tt>-d</tt> к <tt>git branch</tt>:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;-d&nbsp;hotfix<br></br>Deleted&nbsp;branch&nbsp;hotfix&nbsp;(3a0874c).<br></br></tt></p>
<p>Теперь вы можете вернуться обратно к рабочей ветке для проблемы №53 и продолжить работать над ней (см. рис. 3-15):</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;iss53<br></br>Switched&nbsp;to&nbsp;branch&nbsp;"iss53"<br></br>$&nbsp;vim&nbsp;index.html<br></br>$&nbsp;git&nbsp;commit&nbsp;-a&nbsp;-m&nbsp;'finished&nbsp;the&nbsp;new&nbsp;footer&nbsp;[issue&nbsp;53]'<br></br>[iss53]:&nbsp;created&nbsp;ad82d7a:&nbsp;"finished&nbsp;the&nbsp;new&nbsp;footer&nbsp;[issue&nbsp;53]"<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p><img src="images/000072.jpg"></img></p>
<p>Стоит напомнить, что работа, сделанная на ветке <tt>hotfix</tt>, не включена в файлы на ветке <tt>iss53</tt>. Если вам это необходимо, вы можете слить ветку <tt>master</tt> в ветку <tt>iss53</tt> посредством команды <tt>git merge master</tt>. Или же вы можете подождать с интеграцией изменений до тех пор, пока не решите включить изменения на <tt>iss53</tt> в продуктовую ветку <tt>master</tt>.</p>
<p id="calibre_link-70"><span><span><b>Основы слияния</b></span></span></p>
<p>Допустим, вы разобрались с проблемой №53 и готовы объединить эту ветку и свой <tt>master</tt>. Чтобы сделать это, мы сольём ветку <tt>iss53</tt> в ветку <tt>master</tt> точно так же, как мы делали это ранее с веткой <tt>hotfix</tt>. Всё, что вам нужно сделать, &mdash; перейти на ту ветку, в которую вы хотите слить свои изменения, и выполнить команду <tt>git merge</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>$&nbsp;git&nbsp;merge&nbsp;iss53<br></br>Merge&nbsp;made&nbsp;by&nbsp;recursive.<br></br>&nbsp;README&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p>Это слияние немного отличается от слияния, сделанного ранее для ветки <tt>hotfix</tt>. В данном случае история разработки разделилась в некоторой точке. Так как коммит на той ветке, на которой вы находитесь, не является прямым предком для ветки, которую вы сливаете, Git'у придётся проделать кое-какую работу. В этом случае Git делает простое трёхходовое слияние, используя при этом те два снимка состояния репозитория, на которые указывают вершины веток, и общий для этих двух веток снимок-прародитель. На рисунке 3-16 выделены три снимка состояния, которые Git будет использовать для слияния в данном случае.</p>
<p><img src="images/000071.jpg"></img></p>
<p>Вместо того чтобы просто передвинуть указатель ветки вперёд, Git создаёт новый снимок состояния, который является результатом трёхходового слияния, и автоматически создаёт новый коммит, который указывает на этот новый снимок состояния (см. рис. 3-17). Такой коммит называют коммит-слияние, так как он является особенным из-за того, что имеет больше одного предка.</p>
<p>Стоит отметить, что Git сам определяет наилучшего общего предка для слияния веток; в CVS или Subversion (версии ранее 1.5) этого не происходит. Разработчик должен сам указать основу для слияния. Это делает слияние в Git'е гораздо более простым занятием, чем в других системах.</p>
<p><img src="images/000000.jpg"></img></p>
<p>Теперь, когда вы осуществили слияние ваших наработок, ветка <tt>iss53</tt> вам больше не нужна. Можете удалить её и затем вручную закрыть карточку (ticket) в своей системе:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;-d&nbsp;iss53<br></br></tt></p>
<p id="calibre_link-71"><span><span><b>Основы конфликтов при слиянии</b></span></span></p>
<p>Иногда процесс слияния не идёт гладко. Если вы изменили одну и ту же часть файла по-разному в двух ветках, которые собираетесь слить, Git не сможет сделать это чисто. Если ваше решение проблемы №53 изменяет ту же часть файла, что и <tt>hotfix</tt>, вы получите конфликт слияния, и выглядеть он будет примерно так:</p>
<p><tt>$&nbsp;git&nbsp;merge&nbsp;iss53<br></br>Auto-merging&nbsp;index.html<br></br>CONFLICT&nbsp;(content):&nbsp;Merge&nbsp;conflict&nbsp;in&nbsp;index.html<br></br>Automatic&nbsp;merge&nbsp;failed;&nbsp;fix&nbsp;conflicts&nbsp;and&nbsp;then&nbsp;commit&nbsp;the&nbsp;result.<br></br></tt></p>
<p>Git не создал новый коммит для слияния. Он приостановил этот процесс до тех пор, пока вы не разрешите конфликт. Если вы хотите посмотреть, какие файлы не прошли слияние (на любом этапе после возникновения конфликта), выполните команду <tt>git status</tt>:</p>
<p><tt>[master*]$&nbsp;git&nbsp;status<br></br>index.html:&nbsp;needs&nbsp;merge<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;checkout&nbsp;--&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;discard&nbsp;changes&nbsp;in&nbsp;working&nbsp;directory)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;unmerged:&nbsp;&nbsp;&nbsp;index.html<br></br>#<br></br></tt></p>
<p>Всё, что имеет отношение к конфликту слияния и что не было разрешено, отмечено как unmerged. Git добавляет стандартные маркеры к файлам, которые имеют конфликт, так что вы можете открыть их вручную и разрешить эти конфликты. Ваш файл содержит секцию, которая выглядит примерно так:</p>
<p><tt>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&nbsp;HEAD:index.html<br></br>&lt;div&nbsp;id="footer"&gt;contact&nbsp;:&nbsp;email.support@github.com&lt;/div&gt;<br></br>=======<br></br>&lt;div&nbsp;id="footer"&gt;<br></br>&nbsp;&nbsp;please&nbsp;contact&nbsp;us&nbsp;at&nbsp;support@github.com<br></br>&lt;/div&gt;<br></br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&nbsp;iss53:index.html<br></br></tt></p>
<p>В верхней части блока (всё что выше <tt>=======</tt>) это версия из HEAD (вашей ветки master, так как именно на неё вы перешли перед выполнением команды merge), всё, что находится в нижней части &mdash; версия в <tt>iss53</tt>. Чтобы разрешить конфликт, вы должны либо выбрать одну из этих частей, либо как-то объединить содержимое по своему усмотрению. Например, вы можете разрешить этот конфликт заменой всего блока, показанного выше, следующим блоком:</p>
<p><tt>&lt;div&nbsp;id="footer"&gt;<br></br>please&nbsp;contact&nbsp;us&nbsp;at&nbsp;email.support@github.com<br></br>&lt;/div&gt;<br></br></tt></p>
<p>Это решение содержит понемногу из каждой части, и я полностью удалил строки <tt>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</tt>, <tt>=======</tt> и <tt>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</tt>. После того как вы разобрались с каждой из таких секций в каждом из конфликтных файлов, выполните <tt>git add</tt> для каждого конфликтного файла. Индексирование будет означать для Git'а, что все конфликты в файле теперь разрешены. Если вы хотите использовать графические инструменты для разрешения конфликтов, можете выполнить команду <tt>git mergetool</tt>, которая запустит соответствующий графический инструмент и покажет конфликтные ситуации:</p>
<p><tt>$&nbsp;git&nbsp;mergetool<br></br>merge&nbsp;tool&nbsp;candidates:&nbsp;kdiff3&nbsp;tkdiff&nbsp;xxdiff&nbsp;meld&nbsp;gvimdiff&nbsp;opendiff&nbsp;emerge&nbsp;vimdiff<br></br>Merging&nbsp;the&nbsp;files:&nbsp;index.html<br></br><br></br>Normal&nbsp;merge&nbsp;conflict&nbsp;for&nbsp;'index.html':<br></br>&nbsp;&nbsp;{local}:&nbsp;modified<br></br>&nbsp;&nbsp;{remote}:&nbsp;modified<br></br>Hit&nbsp;return&nbsp;to&nbsp;start&nbsp;merge&nbsp;resolution&nbsp;tool&nbsp;(opendiff):<br></br></tt></p>
<p>Если вы хотите использовать другой инструмент для слияния, нежели выбираемый по умолчанию (Git выбрал <tt>opendiff</tt> для меня, так как я выполнил команду на Mac'е). Вы можете увидеть все поддерживаемые инструменты, указанные выше после “merge tool candidates”. Укажите название предпочтительного для вас инструмента. В главе 7 мы обсудим, как изменить это значение по умолчанию для вашего окружения.</p>
<p>После того как вы выйдете из инструмента для выполнения слияния, Git спросит вас, было ли оно успешным. Если вы отвечаете, что да &mdash; файл индексируется (добавляется в область для коммита), чтобы дать вам понять, что конфликт разрешён.</p>
<p>Можете выполнить <tt>git status</tt> ещё раз, чтобы убедиться, что все конфликты были разрешены:</p>
<p><tt>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;index.html<br></br>#<br></br></tt></p>
<p>Если вы довольны тем, что получили, и удостоверились, что всё, имевшее конфликты, было проиндексировано, можете выполнить <tt>git commit</tt> для завершения слияния. По умолчанию сообщение коммита будет выглядеть примерно так:</p>
<p><tt>Merge&nbsp;branch&nbsp;'iss53'<br></br><br></br>Conflicts:<br></br>&nbsp;&nbsp;index.html<br></br>#<br></br>#&nbsp;It&nbsp;looks&nbsp;like&nbsp;you&nbsp;may&nbsp;be&nbsp;committing&nbsp;a&nbsp;MERGE.<br></br>#&nbsp;If&nbsp;this&nbsp;is&nbsp;not&nbsp;correct,&nbsp;please&nbsp;remove&nbsp;the&nbsp;file<br></br>#&nbsp;.git/MERGE_HEAD<br></br>#&nbsp;and&nbsp;try&nbsp;again.<br></br>#<br></br></tt></p>
<p>Вы можете дополнить это сообщение информацией о том, как вы разрешили конфликт, если считаете, что это может быть полезно для других в будущем. Например, можете указать почему вы сделали то, что сделали, если это не очевидно, конечно.</p>
<div></div><p id="calibre_link-72"><span><span><b>Управление ветками</b></span></span></p>
<p>Теперь, когда вы уже попробовали создавать, объединять и удалять ветки, пора познакомиться с некоторыми инструментами для управления ветками, которые вам пригодятся, когда вы начнёте использовать ветки постоянно.</p>
<p>Команда <tt>git branch</tt> делает несколько больше, чем просто создаёт и удаляет ветки. Если вы выполните её без аргументов, то получите простой список имеющихся у вас веток:</p>
<p><tt>$&nbsp;git&nbsp;branch<br></br>&nbsp;&nbsp;iss53<br></br>*&nbsp;master<br></br>&nbsp;&nbsp;testing<br></br></tt></p>
<p>Обратите внимание на символ <tt>*</tt>, стоящий перед веткой <tt>master</tt>: он указывает на ветку, на которой вы находитесь в настоящий момент. Это означает, что если вы сейчас выполните коммит, ветка <tt>master</tt> переместится вперёд в соответствии с вашими последними изменениями. Чтобы посмотреть последний коммит на каждой из веток, выполните команду <tt>git branch -v</tt>:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;-v<br></br>&nbsp;&nbsp;iss53&nbsp;&nbsp;&nbsp;93b412c&nbsp;fix&nbsp;javascript&nbsp;issue<br></br>*&nbsp;master&nbsp;&nbsp;7a98805&nbsp;Merge&nbsp;branch&nbsp;'iss53'<br></br>&nbsp;&nbsp;testing&nbsp;782fd34&nbsp;add&nbsp;scott&nbsp;to&nbsp;the&nbsp;author&nbsp;list&nbsp;in&nbsp;the&nbsp;readmes<br></br></tt></p>
<p>Ещё одна полезная возможность для выяснения состояния веток состоит в том, чтобы оставить в этом списке только те ветки, которые вы слили (или не слили) в ветку, на которой сейчас находитесь. Для этих целей в Git'е есть опции <tt>--merged</tt> и <tt>--no-merged</tt>. Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду <tt>git branch --merged</tt>:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;--merged<br></br>&nbsp;&nbsp;iss53<br></br>*&nbsp;master<br></br></tt></p>
<p>Из-за того что мы ранее слили <tt>iss53</tt>, мы видим её в этом списке. Те ветки из этого списка, перед которыми нет символа <tt>*</tt>, можно смело удалять командой <tt>git branch -d</tt>; вы уже включили наработки из этих веток в другую ветку, так что вы ничего не потеряете.</p>
<p>Чтобы увидеть все ветки, содержащие наработки, которые вы пока ещё не слили в текущую ветку, выполните команду <tt>git branch --no-merged</tt>:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;--no-merged<br></br>&nbsp;&nbsp;testing<br></br></tt></p>
<p>Вы увидите оставшуюся ветку. Так как она содержит ещё не слитые наработки, попытка удалить её командой <tt>git branch -d</tt> не увенчается успехом:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;-d&nbsp;testing<br></br>error:&nbsp;The&nbsp;branch&nbsp;'testing'&nbsp;is&nbsp;not&nbsp;an&nbsp;ancestor&nbsp;of&nbsp;your&nbsp;current&nbsp;HEAD.<br></br>If&nbsp;you&nbsp;are&nbsp;sure&nbsp;you&nbsp;want&nbsp;to&nbsp;delete&nbsp;it,&nbsp;run&nbsp;'git&nbsp;branch&nbsp;-D&nbsp;testing'.<br></br></tt></p>
<p>Если вы действительно хотите удалить ветку и потерять наработки, вы можете сделать это при помощи опции <tt>-D</tt>, как указано в подсказке.</p>
<div></div><p id="calibre_link-73"><span><span><b>Приёмы работы с ветками</b></span></span></p>
<p>Теперь, когда вы познакомились с основами ветвления и слияния, что вам делать с ветками дальше? В этом разделе мы рассмотрим некоторые стандартные приёмы работы, которые становятся возможными благодаря лёгкости осуществления ветвления. И вы сможете выбрать, включить ли вам какие-то из них в свой цикл разработки.</p>
<p id="calibre_link-74"><span><span><b>Долгоживущие ветки</b></span></span></p>
<p>Так как Git использует простое трёхходовое слияние, периодически сливать одну ветку с другой на протяжении большого промежутка времени достаточно просто. Это значит, вы можете иметь несколько веток, которые всегда открыты и которые вы используете для разных стадий вашего цикла разработки; вы можете регулярно сливать их одну в другую.</p>
<p>Многие разработчики Git'а придерживаются такого подхода, при котором ветка <tt>master</tt> содержит исключительно стабильный код &mdash; единственный выпускаемый код. Для разработки и тестирования используется параллельная ветка, называемая <tt>develop</tt> или <tt>next</tt>, она может не быть стабильной постоянно, но в стабильные моменты её можно слить в <tt>master</tt>. Эта ветка используется для объединения завершённых задач из тематических веток (временных веток наподобие <tt>iss53</tt>), чтобы удостовериться, что эти изменения проходят все тесты и не вызывают ошибок.</p>
<p>В действительности же, мы говорим об указателях, передвигающихся вверх по линии коммитов, которые вы делаете. Стабильные ветки далеко внизу линии вашей истории коммитов, наиболее свежие ветки находятся ближе к верхушке этой линии (см. рис. 3-18).</p>
<p><img src="images/000005.jpg"></img></p>
<p>В общем, об этом проще думать как о силосных башнях, где набор коммитов переходит в более стабильную башню только тогда, когда он полностью протестирован (см. рис. 3-19).</p>
<p><img src="images/000006.jpg"></img></p>
<p>Вы можете применять эту идею для нескольких разных уровней стабильности. Некоторые большие проекты также имеют ветку <tt>proposed</tt> или <tt>pu</tt> (proposed updates &mdash; предлагаемые изменения), которые включают в себя ветки, не готовые для перехода в ветку <tt>next</tt> или <tt>master</tt>. Идея такова, что ваши ветки находятся на разных уровнях стабильности; когда они достигают более высокого уровня стабильности, они сливаются с веткой, стоящей на более высоком уровне. Опять-таки, иметь долгоживущие ветки не обязательно, но зачастую это полезно, особенно когда вы имеете дело с очень большими и сложными проектами.</p>
<p id="calibre_link-75"><span><span><b>Тематические ветки</b></span></span></p>
<p>Тематические ветки, однако, полезны в проектах любого размера. Тематическая ветка &mdash; недолговечная ветка, которую вы создаёте и используете для работы над некоторой отдельной функциональностью или для вспомогательной работы. Это то, чего вы, вероятно, никогда не делали с системами контроля версий раньше, так как создание и слияние веток обычно слишком затратно. Но в Git'е принято создавать ветки, работать над ними, сливать и удалять их по несколько раз в день.</p>
<p>Мы видели подобное в последнем разделе, где вы создавали ветки <tt>iss53</tt> и <tt>hotfix</tt>. Вы сделали всего несколько коммитов на этих ветках и удалили их сразу же после слияния с основной веткой. Такая техника позволяет быстро и полноценно переключать контекст. Ибо когда все изменения разбиты по веткам и определённым темам, намного проще понять, что было сделано, во время проверки и просмотра кода. Вы можете сохранить там изменения на несколько минут, дней или месяцев, а затем, когда они готовы, слить их в основную ветку, независимо от порядка, в котором их создавали или работали над ними.</p>
<p>Рассмотрим пример, когда при выполнении некоторой работы в ветке <tt>master</tt>, делается новая ветка для решения некой проблемы (<tt>iss91</tt>), выполняется немного работы на ней, от неё ответвляется ещё одна ветка для другого пути решения той же задачи (<tt>iss91v2</tt>), потом осуществляется переход назад на основную ветку (<tt>master</tt>), и некоторое время работа ведётся на ней, затем делается ответвление от неё для выполнения чего-то, в чём вы не уверены, что это хорошая идея (ветка <tt>dumbidea</tt>). Ваша история коммитов будет выглядеть примерно так как на рисунке 3-20.</p>
<p><img src="images/000011.jpg"></img></p>
<p>Теперь представим, вы решили, что вам больше нравится второе решение для вашей задачи (<tt>iss91v2</tt>); и вы показываете ветку <tt>dumbidea</tt> вашим коллегам и оказывается, что она просто гениальна. Так что вы можете выбросить оригинальную ветку <tt>iss91</tt> (теряя при этом коммиты C5 и C6) и слить две другие. Тогда ваша история будет выглядеть как на рисунке 3-21.</p>
<p><img src="images/000013.jpg"></img></p>
<p>Важно запомнить, что когда вы выполняете все эти действия, ветки являются полностью локальными. Когда вы выполняете ветвление и слияние, всё происходит только в вашем репозитории &mdash; связь с сервером не осуществляется.</p>
<div></div><p id="calibre_link-76"><span><span><b>Удалённые ветки</b></span></span></p>
<p>Удалённые ветки &mdash; это ссылки на состояние веток в ваших удалённых репозиториях. Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети. Удалённые ветки действуют как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.</p>
<p>Они выглядят как <tt>(имя удал. репоз.)/(ветка)</tt>. Например, если вы хотите посмотреть, как выглядела ветка <tt>master</tt> на сервере <tt>origin</tt> во время последнего соединения с ним, проверьте ветку <tt>origin/master</tt>. Если вы с партнёром работали над одной проблемой, и он выложил ветку <tt>iss53</tt>, у вас может быть своя локальная ветка <tt>iss53</tt>; но та ветка на сервере будет указывать на коммит в <tt>origin/iss53</tt>.</p>
<p>Всё это, возможно, сбивает с толку, поэтому давайте рассмотрим пример. Скажем, у вас в сети есть свой Git-сервер на <tt>git.ourcompany.com</tt>. Если вы с него что-то склонируете (clone), Git автоматически назовёт его <tt>origin</tt>, заберёт оттуда все данные, создаст указатель на то, на что там указывает ветка <tt>master</tt>, и назовёт его локально <tt>origin/master</tt> (но вы не можете его двигать). Git также сделает вам вашу собственную ветку <tt>master</tt>, которая будет начинаться там же, где и ветка <tt>master</tt> в origin, так что вам будет с чем работать (см. рис. 3-22).</p>
<p><img src="images/000015.jpg"></img></p>
<p>Если вы сделаете что-то в своей локальной ветке <tt>master</tt>, а тем временем кто-то ещё отправит (push) изменения на <tt>git.ourcompany.com</tt> и обновит там ветку <tt>master</tt>, то ваши истории продолжатся по-разному. Ещё, до тех пор, пока вы не свяжетесь с сервером origin, ваш указатель <tt>origin/master</tt> не будет сдвигаться (см. рис. 3-23).</p>
<p><img src="images/000090.jpg"></img></p>
<p>Для синхронизации вашей работы выполняется команда <tt>git fetch origin</tt>. Эта команда ищет, какому серверу соответствует origin (в нашем случае это <tt>git.ourcompany.com</tt>); извлекает оттуда все данные, которых у вас ещё нет, и обновляет ваше локальное хранилище данных; сдвигает указатель <tt>origin/master</tt> на новую позицию (см. рис. 3-24).</p>
<p><img src="images/000032.jpg"></img></p>
<p>Чтобы продемонстрировать то, как будут выглядеть удалённые ветки в ситуации с несколькими удалёнными серверами, предположим, что у вас есть ещё один внутренний Git-сервер, который используется для разработки только одной из ваших команд разработчиков. Этот сервер находится на <tt>git.team1.ourcompany.com</tt>. Вы можете добавить его в качестве новой удалённой ссылки на проект, над которым вы сейчас работаете с помощью команды <tt>git remote add</tt> так же, как было описано в главе 2. Дайте этому удалённому серверу имя <tt>teamone</tt>, которое будет сокращением для полного URL (см. рис. 3-25).</p>
<p><img src="images/000064.jpg"></img></p>
<p>Теперь можете выполнить <tt>git fetch teamone</tt>, чтобы извлечь всё, что есть на сервере и нет у вас. Так как в данный момент на этом сервере есть только часть данных, которые есть на сервере <tt>origin</tt>, Git не получает никаких данных, но выставляет удалённую ветку с именем <tt>teamone/master</tt>, которая указывает на тот же коммит, что и ветка <tt>master</tt> на сервере <tt>teamone</tt> (см. рис. 3-26).</p>
<p><img src="images/000038.jpg"></img></p>
<p id="calibre_link-77"><span><span><b>Отправка изменений</b></span></span></p>
<p>Когда вы хотите поделиться веткой с окружающими, вам необходимо отправить (push) её на удалённый сервер, на котором у вас есть права на запись. Ваши локальные ветки автоматически не синхронизируются с удалёнными серверами &mdash; вам нужно явно отправить те ветки, которыми вы хотите поделиться. Таким образом, вы можете использовать свои личные ветки для работы, которую вы не хотите показывать, и отправлять только те тематические ветки, над которыми вы хотите работать с кем-то совместно.</p>
<p>Если у вас есть ветка <tt>serverfix</tt>, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно так же, как вы отправляли вашу первую ветку. Выполните <tt>git push (удал. сервер) (ветка)</tt>:</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;serverfix<br></br>Counting&nbsp;objects:&nbsp;20,&nbsp;done.<br></br>Compressing&nbsp;objects:&nbsp;100%&nbsp;(14/14),&nbsp;done.<br></br>Writing&nbsp;objects:&nbsp;100%&nbsp;(15/15),&nbsp;1.74&nbsp;KiB,&nbsp;done.<br></br>Total&nbsp;15&nbsp;(delta&nbsp;5),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)<br></br>To&nbsp;git@github.com:schacon/simplegit.git<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverfix&nbsp;-&gt;&nbsp;serverfix<br></br></tt></p>
<p>Это в некотором роде сокращение. Git автоматически разворачивает имя ветки <tt>serverfix</tt> до <tt>refs/heads/serverfix:refs/heads/serverfix</tt>, что означает “возьми мою локальную ветку serverfix и обнови из неё удалённую ветку serverfix”. Мы подробно обсудим часть с <tt>refs/heads/</tt> в главе 9, но обычно её можно опустить. Вы также можете выполнить <tt>git push origin serverfix:serverfix</tt> &mdash; произойдёт то же самое &mdash; здесь говорится “возьми мой serverfix и сделай его удалённым serverfix”. Можно использовать этот формат для отправки локальной ветки в удалённую ветку с другим именем. Если вы не хотите, чтобы ветка называлась <tt>serverfix</tt> на удалённом сервере, то вместо предыдущей команды выполните <tt>git push origin serverfix:awesomebranch</tt>. Так ваша локальная ветка <tt>serverfix</tt> отправится в ветку <tt>awesomebranch</tt> удалённого проекта.</p>
<p>В следующий раз, когда один из ваших соавторов будет получать обновления с сервера, он получит ссылку на то, на что указывает <tt>serverfix</tt> на сервере, как удалённую ветку <tt>origin/serverfix</tt>:</p>
<p><tt>$&nbsp;git&nbsp;fetch&nbsp;origin<br></br>remote:&nbsp;Counting&nbsp;objects:&nbsp;20,&nbsp;done.<br></br>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100%&nbsp;(14/14),&nbsp;done.<br></br>remote:&nbsp;Total&nbsp;15&nbsp;(delta&nbsp;5),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)<br></br>Unpacking&nbsp;objects:&nbsp;100%&nbsp;(15/15),&nbsp;done.<br></br>From&nbsp;git@github.com:schacon/simplegit<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverfix&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;origin/serverfix<br></br></tt></p>
<p>Важно отметить, что когда при получении данных у вас появляются новые удалённые ветки, вы не получаете автоматически для них локальных редактируемых копий. Другими словами, в нашем случае вы не получите новую ветку <tt>serverfix</tt> &mdash; только указатель <tt>origin/serverfix</tt>, который вы не можете менять.</p>
<p>Чтобы слить эти наработки в свою текущую рабочую ветку, выполните <tt>git merge origin/serverfix</tt>. Если вам нужна своя собственная ветка <tt>serverfix</tt>, над которой вы сможете работать, то вы можете создать её на основе удалённой ветки:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;serverfix&nbsp;origin/serverfix<br></br>Branch&nbsp;serverfix&nbsp;set&nbsp;up&nbsp;to&nbsp;track&nbsp;remote&nbsp;branch&nbsp;refs/remotes/origin/serverfix.<br></br>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;"serverfix"<br></br></tt></p>
<p>Это даст вам локальную ветку, на которой можно работать. Она будет начинаться там, где и <tt>origin/serverfix</tt>.</p>
<p id="calibre_link-78"><span><span><b>Отслеживание веток</b></span></span></p>
<p>Получение локальной ветки с помощью <tt>git checkout</tt> из удалённой ветки автоматически создаёт то, что называется <span><i>отслеживаемой веткой</i></span>. Отслеживаемые ветки &mdash; это локальные ветки, которые напрямую связаны с удалённой веткой. Если, находясь на отслеживаемой ветке, вы наберёте <tt>git push</tt>, Git уже будет знать, на какой сервер и в какую ветку отправлять изменения. Аналогично выполнение <tt>git pull</tt> на одной из таких веток сначала получает все удалённые ссылки, а затем автоматически делает слияние с соответствующей удалённой веткой.</p>
<p>При клонировании репозитория, как правило, автоматически создаётся ветка <tt>master</tt>, которая отслеживает <tt>origin/master</tt>, поэтому <tt>git push</tt> и <tt>git pull</tt> работают для этой ветки "из коробки" и не требуют дополнительных аргументов. Однако, вы можете настроить отслеживание и других веток удалённого репозитория. Простой пример, как это сделать, вы увидели только что &mdash; <tt>git checkout -b [ветка] [удал. сервер]/[ветка]</tt>. Если вы используете Git версии 1.6.2 или более позднюю, можете также воспользоваться сокращением <tt>--track</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;--track&nbsp;origin/serverfix<br></br>Branch&nbsp;serverfix&nbsp;set&nbsp;up&nbsp;to&nbsp;track&nbsp;remote&nbsp;branch&nbsp;refs/remotes/origin/serverfix.<br></br>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;"serverfix"<br></br></tt></p>
<p>Чтобы настроить локальную ветку с именем, отличным от имени удалённой ветки, вы можете легко использовать первую версию с другим именем локальной ветки:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;sf&nbsp;origin/serverfix<br></br>Branch&nbsp;sf&nbsp;set&nbsp;up&nbsp;to&nbsp;track&nbsp;remote&nbsp;branch&nbsp;refs/remotes/origin/serverfix.<br></br>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;"sf"<br></br></tt></p>
<p>Теперь ваша локальная ветка sf будет автоматически отправлять (push) и получать (pull) изменения из origin/serverfix.</p>
<p id="calibre_link-79"><span><span><b>Удаление веток на удалённом сервере</b></span></span></p>
<p>Скажем, вы и ваши соавторы закончили с нововведением и слили его в ветку <tt>master</tt> на удалённом сервере (или в какую-то другую ветку, где хранится стабильный код). Вы можете удалить ветку на удалённом сервере, используя несколько бестолковый синтаксис <tt>git push [удал. сервер] :[ветка]</tt>. Чтобы удалить ветку <tt>serverfix</tt> на сервере, выполните следующее:</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;:serverfix<br></br>To&nbsp;git@github.com:schacon/simplegit.git<br></br>&nbsp;-&nbsp;[deleted]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverfix<br></br></tt></p>
<p>Хлоп. Нет больше ветки на вашем сервере. Вам может захотеться сделать закладку на текущей странице, так как эта команда вам понадобится, а синтаксис вы, скорее всего, забудете. Можно запомнить эту команду вернувшись к синтаксису <tt>git push [удал. сервер] [лок. ветка]:[удал. ветка]</tt>, который мы рассматривали немного раньше. Опуская часть <tt>[лок. ветка]</tt>, вы, по сути, говорите “возьми ничто в моём репозитории и сделай так, чтобы в <tt>[удал. ветка]</tt> было то же самое”.</p>
<div></div><p id="calibre_link-80"><span><span><b>Перемещение</b></span></span></p>
<p>В Git'е есть два способа включить изменения из одной ветки в другую: <tt>merge</tt> (слияние) и <tt>rebase</tt> (перемещение). В этом разделе вы узнаете, что такое перемещение, как его осуществлять, почему это удивительный инструмент и в каких случаях вам не следует его использовать.</p>
<p id="calibre_link-81"><span><span><b>Основы перемещения</b></span></span></p>
<p>Если мы вернёмся назад к одному из ранних примеров из раздела про слияние (см. рис. 3-27), увидим, что мы разделили свою работу на два направления и сделали коммиты на двух разных ветках.</p>
<p><img src="images/000041.jpg"></img></p>
<p>Наиболее простое решение для объединения веток, как мы уже выяснили, команда <tt>merge</tt>. Эта команда выполняет трёхходовое слияние между двумя последними снимками состояний из веток (C3 и C4) и последним общим предком этих двух веток (C2), создавая новый снимок состояния (и коммит), как показано на рисунке 3-28.</p>
<p><img src="images/000043.jpg"></img></p>
<p>Однако, есть и другой путь: вы можете взять изменения, представленные в C3, и применить их поверх C4. В Git'е это называется <span><i>перемещение</i></span> (rebasing). При помощи команды <tt>rebase</tt> вы можете взять все изменения, которые попали в коммиты на одной из веток, и повторить их на другой.</p>
<p>Для этого примера надо выполнить следующее:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;experiment<br></br>$&nbsp;git&nbsp;rebase&nbsp;master<br></br>First,&nbsp;rewinding&nbsp;head&nbsp;to&nbsp;replay&nbsp;your&nbsp;work&nbsp;on&nbsp;top&nbsp;of&nbsp;it...<br></br>Applying:&nbsp;added&nbsp;staged&nbsp;command<br></br></tt></p>
<p>Перемещение работает следующим образом: находится общий предок для двух веток (на которой вы находитесь сейчас и на которую вы выполняете перемещение); для каждого из коммитов в текущей ветке берётся его дельта и сохраняется во временный файл; текущая ветка устанавливается на тот же коммит, что и ветка, на которую выполняется перемещение; и, наконец, одно за другим применяются все изменения. Рисунок 3-29 иллюстрирует этот процесс.</p>
<p><img src="images/000007.jpg"></img></p>
<p>На этом этапе можно переключиться на ветку <tt>master</tt> и выполнить слияние-перемотку (fast-forward merge) (см. рис. 3-30).</p>
<p><img src="images/000057.jpg"></img></p>
<p>Теперь снимок состояния, на который указывает C3', точно такой же, как тот, на который указывал C5 в примере со слиянием. Нет никакой разницы в конечном результате объединения, но перемещение выполняется для того, чтобы история была более аккуратной. Если вы посмотрите лог для перемещённой ветки, то увидите, что он выглядит как линейная история работы: выходит, что вся работа выполнялась последовательно, когда в действительности она выполнялась параллельно.</p>
<p>Часто вы будете делать это, чтобы удостовериться, что ваши коммиты правильно применяются для удалённых веток &mdash; возможно для проекта, владельцем которого вы не являетесь, но в который вы хотите внести свой вклад. В этом случае вы будете выполнять работу в какой-нибудь ветке, а затем, когда будете готовы внести свои изменения в основной проект, выполните перемещение вашей работы на <tt>origin/master</tt>. Таким образом, владельцу проекта не придётся делать никаких действий по объединению &mdash; просто перемотка (fast-forward) или чистое применение патчей.</p>
<p>Заметьте, что снимок состояния, на который указывает последний коммит, который у вас получился, является ли этот коммит последним перемещённым коммитом (для случая выполнения перемещения) или итоговым коммитом слияния (для случая выполнения слияния), есть один и тот же снимок &mdash; разной будет только история. Перемещение применяет изменения из одной линии разработки в другую в том порядке, в котором они были представлены, тогда как слияние объединяет вместе конечные точки двух веток.</p>
<p id="calibre_link-82"><span><span><b>Более интересные перемещения</b></span></span></p>
<p>Можно также сделать так, чтобы при перемещении воспроизведение коммитов начиналось не от той ветки, на которую делается перемещение. Возьмём, например, историю разработки как на рис. 3-31. Вы создали тематическую ветку (<tt>server</tt>), чтобы добавить в проект некоторый функционал для серверной части, и сделали коммит. Затем вы выполнили ответвление, чтобы сделать изменения для клиентской части, и несколько раз выполнили коммиты. Наконец, вы вернулись на ветку <tt>server</tt> и сделали ещё несколько коммитов.</p>
<p><img src="images/000059.jpg"></img></p>
<p>Предположим, вы решили, что хотите внести свои изменения для клиентской части в основную линию разработки для релиза, но при этом хотите оставить в стороне изменения для серверной части, пока они не будут полностью протестированы. Вы можете взять изменения из ветки <tt>client</tt>, которых нет в <tt>server</tt> (C8 и C9), и применить их на ветке <tt>master</tt> при помощи опции <tt>--onto</tt> команды <tt>git rebase</tt>:</p>
<p><tt>$&nbsp;git&nbsp;rebase&nbsp;--onto&nbsp;master&nbsp;server&nbsp;client<br></br></tt></p>
<p>По сути, это указание “переключиться на ветку <tt>client</tt>, взять изменения от общего предка веток <tt>client</tt> и <tt>server</tt> и повторить их на <tt>master</tt>”. Это немного сложно; но результат, показанный на рисунке 3-32, довольно классный.</p>
<p><img src="images/000062.jpg"></img></p>
<p>Теперь вы можете выполнить перемотку (fast-forward) для ветки <tt>master</tt> (см. рис. 3-33):</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>$&nbsp;git&nbsp;merge&nbsp;client<br></br></tt></p>
<p><img src="images/000065.jpg"></img></p>
<p>Представим, что вы решили включить работу и из ветки <tt>server</tt> тоже. Вы можете выполнить перемещение ветки <tt>server</tt> на ветку <tt>master</tt> без предварительного переключения на эту ветку при помощи команды <tt>git rebase [осн. ветка] [тем. ветка]</tt> &mdash; которая устанавливает тематическую ветку (в данном случае <tt>server</tt>) как текущую и применяет её изменения на основной ветке (<tt>master</tt>):</p>
<p><tt>$&nbsp;git&nbsp;rebase&nbsp;master&nbsp;server<br></br></tt></p>
<p>Эта команда применит изменения из вашей работы над веткой <tt>server</tt> на вершину ветки <tt>master</tt>, как показано на рисунке 3-34.</p>
<p><img src="images/000067.jpg"></img></p>
<p>Затем вы можете выполнить перемотку основной ветки (<tt>master</tt>):</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>$&nbsp;git&nbsp;merge&nbsp;server<br></br></tt></p>
<p>Вы можете удалить ветки <tt>client</tt> и <tt>server</tt>, так как вся работа из них включена в основную линию разработки и они вам больше не нужны. При этом полная история вашего рабочего процесса выглядит как на рисунке 3-35:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;-d&nbsp;client<br></br>$&nbsp;git&nbsp;branch&nbsp;-d&nbsp;server<br></br></tt></p>
<p><img src="images/000052.jpg"></img></p>
<p id="calibre_link-83"><span><span><b>Возможные риски перемещения</b></span></span></p>
<p>Всё бы хорошо, но кое-что омрачает всю прелесть использования перемещения. Это выражается одной строчкой:</p>
<p><span><b>Не перемещайте коммиты, которые вы уже отправили в публичный репозиторий.</b></span></p>
<p>Если вы будете следовать этому указанию, всё будет хорошо. Если нет &mdash; люди возненавидят вас, вас будут презирать ваши друзья и семья.</p>
<p>Когда вы что-то перемещаете, вы отменяете существующие коммиты и создаёте новые, которые похожи на старые, но являются другими. Если вы выкладываете (push) свои коммиты куда-нибудь, и другие забирают (pull) их себе и в дальнейшем основывают на них свою работу, а затем вы переделываете эти коммиты командой <tt>git rebase</tt> и выкладываете их снова, ваши коллеги будут вынуждены заново выполнять слияние для своих наработок. В итоге вы получите путаницу, когда в очередной раз попытаетесь включить их работу в свою.</p>
<p>Давайте рассмотрим пример того, как перемещение публично доступных наработок может вызвать проблемы. Представьте себе, что вы склонировали себе репозиторий с центрального сервера и поработали в нём. И ваша история коммитов выглядит как на рисунке 3-36.</p>
<p><img src="images/000098.jpg"></img></p>
<p>Теперь кто-то ещё выполняет работу, причём работа включает в себя и слияние, и отправляет свои изменения на центральный сервер. Вы извлекаете их и сливаете новую удалённую ветку со своей работой. Тогда ваша история выглядит как на рисунке 3-37.</p>
<p><img src="images/000016.jpg"></img></p>
<p>Далее, человек, выложивший коммит, содержащий слияние, решает вернуться и вместо слияния (merge) переместить (rebase) свою работу; он выполняет <tt>git push --force</tt>, чтобы переписать историю на сервере. Затем вы извлекаете изменения с этого сервера, включая и новые коммиты.</p>
<p><img src="images/000003.jpg"></img></p>
<p>На этом этапе вы вынуждены объединить эту работу со своей снова, даже если вы уже сделали это ранее. Перемещение изменяет у этих коммитов SHA-1 хеши, так что для Git'а они выглядят как новые коммиты, тогда как на самом деле вы уже располагаете наработками из C4 в своей истории (см. рис. 3-39).</p>
<p><img src="images/000027.jpg"></img></p>
<p>Вы вынуждены объединить эту работу со своей на каком-либо этапе, чтобы иметь возможность продолжать работать с другими разработчиками в будущем. После того, как вы сделаете это, ваша история коммитов будет содержать оба коммита &mdash; C4 и C4', которые имеют разные SHA-1 хеши, но представляют собой одинаковые изменения и имеют одинаковые сообщения. Если вы выполните команду <tt>git log</tt>, когда ваша история выглядит таким образом, вы увидите два коммита, которые имеют одинакового автора и одни и те же сообщения. Это сбивает с толку. Более того, если вы отправите такую историю обратно на сервер, вы добавите все эти перемещенные коммиты в репозиторий центрального сервера, что может ещё больше запутать людей.</p>
<p>Если вы рассматриваете перемещение как возможность наведения порядка и работы с коммитами до того, как выложили их, и если вы перемещаете только коммиты, которые никогда не находились в публичном доступе &mdash; всё нормально. Если вы перемещаете коммиты, которые уже были представлены для общего доступа, и люди, возможно, основывали свою работу на этих коммитах, тогда вы можете получить наказание за разные неприятные проблемы.</p>
<div></div><p id="calibre_link-84"><span><span><b>Итоги</b></span></span></p>
<p>Мы рассмотрели основы ветвления и слияния в Git'е. Теперь вы должны чувствовать себя уверенно при создании и переходе на новые ветки, переключении между ветками и слиянии локальных веток. А также вы должны уметь делиться своими ветками, выкладывая их на общий сервер, работать с другими людьми над общими ветками и перемещать свои ветки, пока они не представлены для общего доступа.</p>
<div></div><p id="calibre_link-85"><span><span><b>Git на сервере</b></span></span></p>
<p>К этому моменту вы уже должны уметь решать большинство повседневных задач, для которых будете использовать Git. Однако, для совместной работы в Git'е, вам необходим удалённый репозиторий. Несмотря на то, что технически вы можете отправлять и забирать изменения непосредственно из личных репозиториев, делать это не рекомендуется. Вы легко можете испортить то, над чем работают другие, если не будете аккуратны. К тому же, вам бы наверняка хотелось, чтобы остальные имели доступ к репозиторию даже если ваш компьютер выключен, поэтому наличие более надежного репозитория обычно весьма полезно. Поэтому предпочтительный метод взаимодействия с кем-либо &mdash; это создание промежуточного репозитория, к которому вы оба будете иметь доступ, и отправка и получение изменений через него. Мы будем называть этот репозиторий "Git-сервер", но обычно размещение Git-репозитория требует очень небольшого количества ресурсов, поэтому вряд ли вам для этого будет нужен весь сервер.</p>
<p>Запустить Git-сервер просто. Для начала вам следует выбрать протокол, который вы будете использовать для связи с сервером. Первая часть этой главы описывает доступные протоколы и их достоинства и недостатки. Следующие части освещают базовые конфигурации с использованием этих протоколов, а также настройку вашего сервера для работы с ними. Наконец, мы рассмотрим несколько вариантов готового хостинга, если вы не против разместить ваш код на чьём-то сервере и вы не хотите мучиться с настройками и поддержкой вашего собственного сервера.</p>
<p>Если вас не интересует настройка собственного сервера, вы можете перейти сразу к последней части этой главы для настройки аккаунта на Git-хостинге, и затем перейти к следующей главе, где мы обсудим различные аспекты работы с распределённой системой контроля версий.</p>
<p>Удалённый репозиторий &mdash; это обычно <span><i>голый (чистый, bare) репозиторий</i></span> &mdash; Git-репозиторий, не имеющий рабочего каталога. Поскольку этот репозиторий используется только для обмена, нет причин создавать рабочую копию на диске, и он содержит только данные Git'а. Проще говоря, голый репозиторий содержит только каталог <tt>.git</tt> вашего проекта и ничего больше.</p>
<div></div><p id="calibre_link-86"><span><span><b>Протоколы</b></span></span></p>
<p>Git умеет работать с четырьмя сетевыми протоколами для передачи данных: локальный, Secure Shell (SSH), Git и HTTP. В этой части мы обсудим каждый из них и в каких случаях стоит (или не стоит) их использовать.</p>
<p>Важно понимать, что за исключением протокола HTTP, все эти протоколы требуют, чтобы Git был установлен и работал на сервере.</p>
<p id="calibre_link-87"><span><span><b>Локальный протокол</b></span></span></p>
<p>Базовым протоколом является <span><i>Локальный протокол</i></span>, при использовании которого удалённый репозиторий &mdash; другой каталог на диске. Наиболее часто он используется, если все члены команды имеют доступ к общей файловой системе, например к NFS, или, что менее вероятно, когда все работают на одном компьютере. Последний вариант не столь хорош, поскольку все копии вашего репозитория находятся на одном компьютере, делая возможность потерять всё более вероятной.</p>
<p>Если у вас смонтирована общая файловая система, вы можете клонировать, отправлять и получать изменения из локального репозитория. Чтобы склонировать такой репозиторий или добавить его в качестве удалённого в существующий проект, используйте путь к репозиторию в качестве URL. Например, для клонирования локального репозитория вы можете выполнить что-то вроде этого:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;/opt/git/project.git<br></br></tt></p>
<p>Или этого:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;file:///opt/git/project.git<br></br></tt></p>
<p>Git работает немного по-другому если вы укажете префикс <tt>file://</tt> для вашего URL. Когда вы просто указываете путь, Git пытается использовать жёсткие ссылки и копировать файлы, когда это нужно. Если вы указываете <tt>file://</tt>, Git работает с данными так же как при использовании сетевых протоколов, что в целом менее эффективный способ передачи данных. Причиной для использования <tt>file://</tt> может быть необходимость создания чистой копии репозитория без лишних внешних ссылок и объектов, обычно после импорта из другой СКВ или чего-то похожего (см. главу 9 о задачах поддержки). Мы будем использовать обычные пути, поскольку это практически всегда быстрее.</p>
<p>Чтобы добавить локальный репозиторий в существующий проект, вы можете воспользоваться командой:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;local_proj&nbsp;/opt/git/project.git<br></br></tt></p>
<p>Теперь вы можете отправлять и получать изменения из этого репозитория так, как вы это делали по сети.</p>
<p><span><b>Преимущества</b></span></p>
<p>Преимущества основанных на файлах хранилищ в том, что они просты и используют существующие разграничения прав на файлы и сетевой доступ. Если у вас уже есть общая файловая система, доступ к которой имеет вся команда, настройка репозитория очень проста. Вы помещаете голый репозиторий туда, куда все имеют доступ, и выставляете права на чтение и запись так же, как вы это делали бы для любого другого общего каталога. Мы обсудим, как экспортировать голую копию репозитория для этой цели в следующем разделе, "Настройка Git на сервере".</p>
<p>Также это хорошая возможность быстро получить наработки из чьего-то рабочего репозитория. Если вы и ваш коллега работаете над одним и тем же проектом и он хочет, чтобы вы проверили что-то, то запуск команды вроде <tt>git pull /home/john/project</tt> зачастую проще, чем если бы он отправил на удалённый сервер, а вы забрали бы оттуда.</p>
<p><span><b>Недостатки</b></span></p>
<p>Недостаток этого метода в том, что общий доступ обычно сложнее настроить и получить из разных мест, чем простой сетевой доступ. Если вы хотите отправлять со своего ноутбука, когда вы дома, вы должны смонтировать удалённый диск, что может быть сложно и медленно по сравнению с сетевым доступом.</p>
<p>Также важно упомянуть, что не всегда использование общей точки монтирования является быстрейшим вариантом. Локальный репозиторий быстрый, только если вы имеете быстрый доступ к данным. Репозиторий на NFS часто медленнее, чем репозиторий через SSH на том же сервере, позволяющий Git'у использовать на полную локальные диски на каждой системе.</p>
<p id="calibre_link-88"><span><span><b>Протокол SSH</b></span></span></p>
<p>Наверное, наиболее часто используемый транспортный протокол &mdash; это SSH. Причина этого в том, что доступ по SSH уже есть на многих серверах, а если его нет, то его очень легко настроить. Кроме того, SSH &mdash; единственный из сетевых протоколов, предоставляющий доступ и на чтение, и на запись. Два других сетевых протокола (HTTP и Git) в большинстве случаев дают доступ только на чтение, поэтому даже если они вам доступны, вам всё равно понадобится SSH для записи. К тому же SSH протокол с аутентификацией, и благодаря его распространённости обычно его легко настроить и использовать.</p>
<p>Чтобы склонировать Git-репозиторий по SSH, вы можете указать префикс ssh:// в URL, например:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;ssh://user@server/project.git<br></br></tt></p>
<p>Альтернативно для протокола SSH можно использовать более короткую запись в scp-стиле:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;user@server:project.git<br></br></tt></p>
<p>Также вы можете не указывать имя пользователя, Git будет использовать то, под которым вы вошли в систему.</p>
<p><span><b>Достоинства</b></span></p>
<p>SSH имеет множество достоинств. Во-первых, вы, по сути, вынуждены его использовать, когда нужен авторизованный доступ на запись к репозиторию через сеть. Во-вторых, SSH достаточно легко настроить &mdash; SSH-демоны распространены, многие системные администраторы имеют опыт работы с ними, и во многих дистрибутивах они уже настроены или есть утилиты для управления ими. Также доступ по SSH безопасен &mdash; данные передаются зашифрованными по авторизованным каналам. Наконец, так же как и Git-протокол и локальный протокол, SSH эффективен, делая данные перед передачей максимально компактными.</p>
<p><span><b>Недостатки</b></span></p>
<p>Недостаток SSH в том, что, используя его, вы не можете обеспечить анонимный доступ к репозиторию. Клиенты должны иметь доступ к машине по SSH, даже для работы в режиме только на чтение, что делает SSH неподходящим для проектов с открытым исходным кодом. Если вы используете Git только внутри корпоративной сети, то возможно SSH единственный протокол, с которым вам придётся иметь дело. Если же вам нужен анонимный доступ на чтение для ваших проектов, вам придётся настроить SSH для себя, чтобы выкладывать изменения, и что-нибудь другое для других, для скачивания.</p>
<p id="calibre_link-89"><span><span><b>Git-протокол</b></span></span></p>
<p>Следующий протокол &mdash; Git-протокол. Вместе с Git'ом поставляется специальный демон, который слушает порт 9418 и предоставляет сервис, схожий с протоколом ssh, но абсолютно без аутентификации. Чтобы использовать Git-протокол для репозитория, вы должны создать файл <tt>git-daemon-export-ok</tt>, иначе демон не будет работать с этим репозиторием, но следует помнить, что в протоколе отсутствуют средства безопасности. Соответственно, любой репозиторий в Git'е может быть либо доступен для клонирования всем, либо не доступен никому. Как следствие, обычно вы не можете отправлять изменения по этому протоколу. Вы можете открыть доступ на запись, но из-за отсутствия авторизации в этом случае кто угодно, зная URL вашего проекта, сможет его изменить. В общем, это редко используемая возможность.</p>
<p><span><b>Достоинства</b></span></p>
<p>Git-протокол &mdash; самый быстрый из доступных протоколов. Если у вас проект с публичным доступом и большой трафик или у вас очень большой проект, для которого не требуется авторизация пользователей для чтения, вам стоит настроить Git-демон для вашего проекта. Он использует тот же механизм передачи данных, что и протокол SSH, но без дополнительных затрат на кодирование и аутентификацию.</p>
<p><span><b>Недостатки</b></span></p>
<p>Недостатком Git-протокола является отсутствие аутентификации. Поэтому обычно не следует использовать этот протокол как единственный способ доступа к вашему проекту. Обычно он используется в паре с SSH для разработчиков, имеющих доступ на запись, тогда как все остальные используют <tt>git://</tt> с доступом только на чтение. Кроме того, это, вероятно, самый сложный для настройки протокол. Вы должны запустить собственно демон, не являющийся стандартным. Мы рассмотрим его настройку в разделе "Gitosis" этой главы. К тому же, ему необходим сервис <tt>xinetd</tt> или ему подобный, что не всегда легко сделать. Также необходимо, чтобы сетевой экран позволял доступ на порт 9418, который не является стандартным портом, всегда разрешённым в корпоративных брандмауэрах. За сетевыми экранами крупных корпораций этот неизвестный порт обычно заблокирован.</p>
<p id="calibre_link-90"><span><span><b>Протокол HTTP/S</b></span></span></p>
<p>Последний доступный протокол &mdash; HTTP. Прелесть протоколов HTTP и HTTPS в простоте их настройки. По сути, всё, что необходимо сделать &mdash; поместить голый репозиторий внутрь каталога с HTTP документами, установить перехватчик <tt>post-update</tt> и всё (подробнее о перехватчиках будет рассказано в главе 7). Теперь каждый, имеющий доступ к веб-серверу, на котором был размещён репозиторий, может его склонировать. Таким образом, чтобы открыть доступ к своему репозиторию на чтение через HTTP, нужно сделать что-то наподобие этого:</p>
<p><tt>$&nbsp;cd&nbsp;/var/www/htdocs/<br></br>$&nbsp;git&nbsp;clone&nbsp;--bare&nbsp;/path/to/git_project&nbsp;gitproject.git<br></br>$&nbsp;cd&nbsp;gitproject.git<br></br>$&nbsp;mv&nbsp;hooks/post-update.sample&nbsp;hooks/post-update<br></br>$&nbsp;chmod&nbsp;a+x&nbsp;hooks/post-update<br></br></tt></p>
<p>Вот и всё. Перехватчик <tt>post-update</tt>, входящий в состав Git'а по умолчанию, выполняет необходимую команду (<tt>git update-server-info</tt>), чтобы извлечение (fetch) и клонирование (clone) по HTTP работали правильно. Эта команда выполняется, когда вы отправляете изменения в репозиторий по SSH. Затем остальные могут склонировать его командой:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;http://example.com/gitproject.git<br></br></tt></p>
<p>В рассмотренном примере мы использовали каталог <tt>/var/www/htdocs</tt>, обычно используемый сервером Apache, но вы можете использовать любой веб-сервер, отдающий статические данные, расположив голый репозиторий в нужном каталоге. Данные Git'а представляют собой обычные файлы (в главе 9 предоставление данных рассматривается более подробно).</p>
<p>Также возможна настройка Git'а для доступа на запись через HTTP, однако этот способ мало распространён и требует от вас настройки WebDAV. Поскольку этот способ редко используется, мы не будем рассматривать его в рамках этой книги. Если вас интересует использование протокола HTTP с возможностью записи, вы можете почитать о подготовке репозитория в этой статье: <tt>http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt</tt>. Положительным моментом настройки Git'а для записи через HTTP является то, что вы можете использовать любой WebDAV-сервер, без поддержки каких-либо специфичных для Git'а возможностей. Таким образом если ваш хостинг предоставляет WebDAV, вы можете обеспечить запись обновлений репозитория на ваш веб-сайт.</p>
<p><span><b>Достоинства</b></span></p>
<p>Положительным аспектом использования протокола HTTP является простота настройки. Запуск всего нескольких команд даёт вам возможность предоставить миру доступ к вашему Git-репозиторию. Вам понадобится всего несколько минут, чтобы сделать это. Кроме того, использование протокола HTTP не потребует много ресурсов вашего сервера. Поскольку в основном используется статический HTTP-сервер, обычный сервер Apache может обрабатывать в среднем тысячи файлов в секунду &mdash; трудно перегрузить даже небольшой сервер.</p>
<p>Также вы можете выставлять ваши репозитории в режиме только для чтения через HTTPS, т.е. вы можете шифровать трафик, или вы даже можете авторизовывать клиентов по SSL-сертификату. Обычно для этих целей легче использовать открытые SSH-ключи, но в некоторых конкретных случаях лучшим решением может оказаться использование подписанных SSL-сертификатов или других методов аутентификации, основанных на HTTP, для доступа на чтение через HTTPS.</p>
<p>Другим плюсом является то, что HTTP &mdash; настолько широко используемый протокол, что корпоративные сетевые экраны часто настроены на пропускание трафика, проходящего через этот порт.</p>
<p><span><b>Недостатки</b></span></p>
<p>Обратной стороной использования протокола HTTP является его относительно низкая эффективность для клиента. Обычно клонирование или извлечение изменений из репозитория при использовании HTTP гораздо продолжительнее, а объем данных и нагрузка на сеть намного больше, чем у любого другого имеющегося сетевого протокола. Поскольку он не заботится о том, чтобы передавались только необходимые вам данные &mdash; никакой динамической обработки на стороне сервера в этом случае не происходит &mdash; протокол HTTP часто называют <span><i>тупым</i></span> (dumb) протоколом. Более подробно о разнице в эффективности протокола HTTP и других протоколов рассказывается в главе 9.</p>
<div></div><p id="calibre_link-91"><span><span><b>Настройка Git на сервере</b></span></span></p>
<p>Для того чтобы осуществить первоначальную настройку любого Git-сервера, необходимо экспортировать существующий репозиторий в новый "голый" репозиторий, т.е. репозиторий без рабочего каталога. Обычно это несложно сделать. Чтобы склонировать ваш репозиторий и создать новый "голый" репозиторий, выполните команду clone с параметром <tt>--bare</tt>. По существующему соглашению, каталоги с голыми репозиториями заканчиваются на <tt>.git</tt>, например:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;--bare&nbsp;my_project&nbsp;my_project.git<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/projects/my_project.git/<br></br></tt></p>
<p>Вывод этой команды слегка обескураживает. Поскольку <tt>clone</tt> это по сути <tt>git init</tt>, а затем <tt>git fetch</tt>, мы видим вывод от <tt>git init</tt>, который создаёт пустой каталог. Реальное перемещение объектов не даёт вывода, однако оно действительно происходит. Теперь у вас должна появиться копия данных из каталога Git'а в каталоге <tt>my_project.git</tt>.</p>
<p>Это примерно то же самое, что и это:</p>
<p><tt>$&nbsp;cp&nbsp;-Rf&nbsp;my_project/.git&nbsp;my_project.git<br></br></tt></p>
<p>Тут есть пара небольших различий в файле конфигурации, но в вашем случае эту разницу можно считать несущественной. Можно считать, что в этом случае берётся собственно Git-репозиторий без рабочего каталога и создаётся каталог только для него.</p>
<p id="calibre_link-92"><span><span><b>Размещение "голого" репозитория на сервере</b></span></span></p>
<p>Теперь, когда у вас есть голая копия репозитория, всё, что вам нужно сделать, это поместить её на сервер и настроить протоколы. Условимся, что вы уже настроили сервер <tt>git.example.com</tt>, имеете к нему доступ по SSH и хотите размещать все свои Git-репозитории в каталоге <tt>/opt/git</tt>. Вы можете сделать новый репозиторий простым копированием голого репозитория:</p>
<p><tt>$&nbsp;scp&nbsp;-r&nbsp;my_project.git&nbsp;user@git.example.com:/opt/git<br></br></tt></p>
<p>Теперь другие пользователи, имеющие доступ к серверу по SSH и право на чтение к каталогу <tt>/opt/git</tt>, могут склонировать ваш репозиторий, выполнив:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;user@git.example.com:/opt/git/my_project.git<br></br></tt></p>
<p>Если у пользователя сервера есть право на запись в каталог <tt>/opt/git/my_project.git</tt>, он автоматически получает возможность отправки изменений в репозиторий. Git автоматически добавит право на запись в репозиторий для группы, если вы запустите команду <tt>git init</tt> с параметром <tt>--shared</tt>.</p>
<p><tt>$&nbsp;ssh&nbsp;user@git.example.com<br></br>$&nbsp;cd&nbsp;/opt/git/my_project.git<br></br>$&nbsp;git&nbsp;init&nbsp;--bare&nbsp;--shared<br></br></tt></p>
<p>Видите, это просто &mdash; взять Git-репозиторий, создать его "голую" версию и поместить её на сервер, к которому у вас и ваших коллег есть доступ по SSH. Теперь вы готовы работать вместе над одним проектом.</p>
<p>Важно отметить, что это практически всё, что вам нужно сделать, чтобы получить рабочий Git-сервер, к которому несколько человек имеют доступ &mdash; просто добавьте учётные записи SSH на сервер, и положите голый репозиторий в место, к которому эти пользователи имеют доступ на чтение и запись. И всё.</p>
<p>Из нескольких последующих разделов вы узнаете, как получить более сложные конфигурации. В том числе как не создавать учётные записи для каждого пользователя, как сделать публичный доступ на чтение репозитория, как установить веб-интерфейс, как использовать Gitosis, и др. Однако, помните, что для совместной работы пары человек на закрытом проекте, всё, что вам <span><i>нужно</i></span> &mdash; это SSH-сервер и "голый" репозиторий.</p>
<p id="calibre_link-93"><span><span><b>Малые установки</b></span></span></p>
<p>Если вы небольшая фирма или вы только пробуете Git в вашей организации и у вас мало разработчиков, то всё достаточно просто. Один из наиболее сложных аспектов настройки Git-сервера &mdash; управление пользователями. Если вы хотите, чтобы некоторые репозитории были доступны некоторым пользователям только на чтение, а другие и на чтение, и на запись, вам может быть не очень просто привести права доступа в порядок.</p>
<p><span><b>Доступ по SSH</b></span></p>
<p>Если у вас уже есть сервер, к которому все ваши разработчики имеют доступ по SSH, проще всего разместить ваш первый репозиторий там, поскольку вам не нужно практически ничего делать (как мы уже обсудили в предыдущем разделе). Если вы хотите более сложного управления правами доступа к вашим репозиториям, вы можете сделать это обычными правами файловой системы, предоставляемыми операционной системой вашего сервера.</p>
<p>Если вы хотите разместить ваши репозитории на сервер, на котором нет учётных записей для каждого в вашей команде, кому нужен доступ на запись, вы должны настроить доступ по SSH для них. Будем считать, что если у вас есть сервер, на котором вы хотите это сделать, то SSH-сервер на нём уже установлен, и через него вы имеете доступ к серверу.</p>
<p>Есть несколько способов дать доступ каждому в вашей команде. Первый &mdash; настроить учётные записи для каждого. Это просто, но может быть весьма обременительно. Вероятно, вы не захотите для каждого пользователя выполнять <tt>adduser</tt> и задавать временные пароли.</p>
<p>Второй способ &mdash; создать на машине одного пользователя 'git', попросить каждого пользователя, кому нужен доступ на запись, прислать вам открытый SSH-ключ, и добавить эти ключи в файл <tt>~/.ssh/authorized_keys</tt> вашего нового пользователя 'git'. Теперь все будут иметь доступ к этой машине через пользователя 'git'. Это никак не повлияет на данные коммита &mdash; пользователь, под которым вы соединяетесь с сервером по SSH, не затрагивает сделанные вами коммиты.</p>
<p>Другой способ сделать это &mdash; использовать SSH-сервер, аутентифицирующий по LDAP-серверу или любому другому централизованному источнику, который у вас может быть уже настроен. Любой способ аутентификации по SSH, какой вы только сможете придумать, должен работать, если пользователь может получить доступ к консоли.</p>
<div></div><p id="calibre_link-94"><span><span><b>Создание открытого SSH-ключа</b></span></span></p>
<p>Как было уже сказано, многие Git-серверы используют аутентификацию по открытым SSH-ключам. Для того чтобы предоставить открытый ключ, пользователь должен его сгенерировать, если только это не было сделано ранее. Этот процесс похож во всех операционных системах. Сначала вам стоит убедиться, что у вас ещё нет ключа. По умолчанию пользовательские SSH-ключи хранятся в каталоге <tt>~/.ssh</tt> этого пользователя. Вы можете легко проверить, есть ли у вас ключ, зайдя в этот каталог и посмотрев его содержимое:</p>
<p><tt>$&nbsp;cd&nbsp;~/.ssh<br></br>$&nbsp;ls<br></br>authorized_keys2&nbsp;&nbsp;id_dsa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;known_hosts<br></br>config&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id_dsa.pub<br></br></tt></p>
<p>Ищите пару файлов с именами "что-нибудь" и "что-нибудь.pub", где "что-нибудь" &mdash; обычно <tt>id_dsa</tt> или <tt>id_rsa</tt>. Файл с расширением <tt>.pub</tt> &mdash; это ваш открытый ключ, а второй файл &mdash; ваш секретный ключ. Если у вас нет этих файлов (или даже нет каталога <tt>.ssh</tt>), вы можете создать их, запустив программу <tt>ssh-keygen</tt>, которая входит в состав пакета SSH в системах Linux/Mac, а также поставляется в составе MSysGit для Windows:</p>
<p><tt>$&nbsp;ssh-keygen&nbsp;<br></br>Generating&nbsp;public/private&nbsp;rsa&nbsp;key&nbsp;pair.<br></br>Enter&nbsp;file&nbsp;in&nbsp;which&nbsp;to&nbsp;save&nbsp;the&nbsp;key&nbsp;(/Users/schacon/.ssh/id_rsa):&nbsp;<br></br>Enter&nbsp;passphrase&nbsp;(empty&nbsp;for&nbsp;no&nbsp;passphrase):&nbsp;<br></br>Enter&nbsp;same&nbsp;passphrase&nbsp;again:&nbsp;<br></br>Your&nbsp;identification&nbsp;has&nbsp;been&nbsp;saved&nbsp;in&nbsp;/Users/schacon/.ssh/id_rsa.<br></br>Your&nbsp;public&nbsp;key&nbsp;has&nbsp;been&nbsp;saved&nbsp;in&nbsp;/Users/schacon/.ssh/id_rsa.pub.<br></br>The&nbsp;key&nbsp;fingerprint&nbsp;is:<br></br>43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a&nbsp;schacon@agadorlaptop.local<br></br></tt></p>
<p>Сначала необходимо указать расположение файла для сохранения ключа (<tt>.ssh/id_rsa</tt>), затем дважды ввести пароль, который вы можете оставить пустым, если не хотите его вводить каждый раз, когда используете ключ.</p>
<p>Теперь каждый пользователь должен послать свой открытый ключ вам или тому, кто администрирует Git-сервер (предположим, что ваш SSH-сервер уже настроен на работу с открытыми ключами). Для этого им нужно скопировать всё содержимое файла с расширением <tt>.pub</tt> и отправить его по электронной почте. Открытый ключ выглядит следующим образом:</p>
<p><tt>$&nbsp;cat&nbsp;~/.ssh/id_rsa.pub&nbsp;<br></br>ssh-rsa&nbsp;AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU<br></br>GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3<br></br>Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA<br></br>t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En<br></br>mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx<br></br>NrRFi9wrf+M7Q==&nbsp;schacon@agadorlaptop.local<br></br></tt></p>
<p>Более подробное руководство по созданию SSH-ключей на различных системах вы можете найти в руководстве GitHub по SSH-ключам на <tt>http://github.com/guides/providing-your-ssh-key</tt>.</p>
<div></div><p id="calibre_link-95"><span><span><b>Настраиваем сервер</b></span></span></p>
<p>Давайте рассмотрим настройку доступа по SSH на стороне сервера. В этом примере мы будем использовать метод <tt>authorized_keys</tt> для аутентификации пользователей. Мы подразумеваем, что вы используете стандартный дистрибутив Linux типа Ubuntu. Для начала создадим пользователя 'git' и каталог <tt>.ssh</tt> для этого пользователя:</p>
<p><tt>$&nbsp;sudo&nbsp;adduser&nbsp;git<br></br>$&nbsp;su&nbsp;git<br></br>$&nbsp;cd<br></br>$&nbsp;mkdir&nbsp;.ssh<br></br></tt></p>
<p>Затем нужно добавить открытый SSH-ключ какого-нибудь разработчика в файл <tt>authorized_keys</tt> этого пользователя. Предположим, вы уже получили несколько ключей по электронной почте и сохранили их во временные файлы. Напомню, открытые ключи выглядят вот так:</p>
<p><tt>$&nbsp;cat&nbsp;/tmp/id_rsa.john.pub<br></br>ssh-rsa&nbsp;AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L<br></br>ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k<br></br>Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez<br></br>Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv<br></br>O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq<br></br>dAv8JggJICUvax2T9va5&nbsp;gsg-keypair<br></br></tt></p>
<p>Вы просто добавляете их в свой файл <tt>authorized_keys</tt>:</p>
<p><tt>$&nbsp;cat&nbsp;/tmp/id_rsa.john.pub&nbsp;&gt;&gt;&nbsp;~/.ssh/authorized_keys<br></br>$&nbsp;cat&nbsp;/tmp/id_rsa.josie.pub&nbsp;&gt;&gt;&nbsp;~/.ssh/authorized_keys<br></br>$&nbsp;cat&nbsp;/tmp/id_rsa.jessica.pub&nbsp;&gt;&gt;&nbsp;~/.ssh/authorized_keys<br></br></tt></p>
<p>Теперь вы можете создать пустой репозиторий для них, запустив <tt>git init</tt> с параметром <tt>--bare</tt>, что инициализирует репозиторий без рабочего каталога:</p>
<p><tt>$&nbsp;cd&nbsp;/opt/git<br></br>$&nbsp;mkdir&nbsp;project.git<br></br>$&nbsp;cd&nbsp;project.git<br></br>$&nbsp;git&nbsp;--bare&nbsp;init<br></br></tt></p>
<p>Затем Джон, Джози или Джессика могут отправить первую версию своего проекта в этот репозиторий, добавив его как удалённый и отправив ветку. Заметьте, что кто-то должен заходить на сервер и создавать голый репозиторий каждый раз, когда вы хотите добавить проект. Пусть <tt>gitserver</tt> &mdash; имя хоста сервера, на котором вы создали пользователя 'git' и репозиторий. Если он находится в вашей внутренней сети, вы можете настроить DNS-запись для <tt>gitserver</tt>, ссылающуюся на этот сервер, и использовать эти команды:</p>
<p><tt>#&nbsp;на&nbsp;компьютере&nbsp;Джона&nbsp;<br></br>$&nbsp;cd&nbsp;myproject<br></br>$&nbsp;git&nbsp;init<br></br>$&nbsp;git&nbsp;add&nbsp;.<br></br>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'initial&nbsp;commit'<br></br>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;origin&nbsp;git@gitserver:/opt/git/project.git<br></br>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master<br></br></tt></p>
<p>Теперь остальные могут склонировать его и отправлять (push) туда изменения так же легко:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;git@gitserver:/opt/git/project.git<br></br>$&nbsp;cd&nbsp;project<br></br>$&nbsp;vim&nbsp;README<br></br>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'fix&nbsp;for&nbsp;the&nbsp;README&nbsp;file'<br></br>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master<br></br></tt></p>
<p>Этим способом вы можете быстро получить Git-сервер с доступом на чтение/запись для небольшой группы разработчиков.</p>
<p>В качестве дополнительной меры предосторожности вы можете ограничить возможности пользователя 'git' только действиями, связанными с Git'ом, с помощью ограниченной оболочки <tt>git-shell</tt>, поставляемой вместе с Git'ом. Если вы выставите её в качестве командного интерпретатора пользователя 'git', то этот пользователь не сможет получить доступ к обычной командной оболочке на вашем сервере. Чтобы её использовать, укажите <tt>git-shell</tt> вместо bash или csh в качестве командной оболочки пользователя. Для этого вы должны отредактировать файл <tt>/etc/passwd</tt>:</p>
<p><tt>$&nbsp;sudo&nbsp;vim&nbsp;/etc/passwd<br></br></tt></p>
<p>В конце вы должны найти строку, похожую на эту:</p>
<p><tt>git:x:1000:1000::/home/git:/bin/sh<br></br></tt></p>
<p>Замените <tt>/bin/sh</tt> на <tt>/usr/bin/git-shell</tt> (или запустите <tt>which git-shell</tt>, чтобы проверить, куда он установлен). Отредактированная строка должна выглядеть следующим образом:</p>
<p><tt>git:x:1000:1000::/home/git:/usr/bin/git-shell<br></br></tt></p>
<p>Теперь пользователь 'git' может использовать SSH-соединение только для работы с Git-репозиториями и не может зайти на машину. Вы можете попробовать и увидите, что вход в систему отклонён:</p>
<p><tt>$&nbsp;ssh&nbsp;git@gitserver<br></br>fatal:&nbsp;What&nbsp;do&nbsp;you&nbsp;think&nbsp;I&nbsp;am?&nbsp;A&nbsp;shell?<br></br>Connection&nbsp;to&nbsp;gitserver&nbsp;closed.<br></br></tt></p>
<div></div><p id="calibre_link-96"><span><span><b>Открытый доступ</b></span></span></p>
<p>Что, если вы хотите иметь анонимный доступ к вашему проекту на чтение? Возможно, вместо размещения внутреннего закрытого проекта, вы хотите разместить проект с открытым исходным кодом. Или, может быть, у вас есть автоматизированные серверы сборки или серверы непрерывной интеграции, которые часто изменяются, и вы не хотите постоянно перегенерировать SSH-ключи, а вы просто хотите добавить анонимный доступ на чтение.</p>
<p>Вероятно, наиболее простой способ для небольших конфигураций &mdash; запустить статический веб-сервер, указав в качестве корневого каталога для документов каталог, в котором расположены ваши Git-репозитории, и задействовав перехватчик <tt>post-update</tt>, как было показано в первой части этой главы. Давайте продолжим работу с предыдущего примера. Допустим, ваши репозитории расположены в каталоге <tt>/opt/git</tt>, и сервер Apache запущен на вашей машине. Повторюсь, вы можете использовать любой веб-сервер, но в качестве примера мы покажем несколько основных конфигураций Apache, которые покажут основную идею.</p>
<p>Для начала вам следует включить перехватчик:</p>
<p><tt>$&nbsp;cd&nbsp;project.git<br></br>$&nbsp;mv&nbsp;hooks/post-update.sample&nbsp;hooks/post-update<br></br>$&nbsp;chmod&nbsp;a+x&nbsp;hooks/post-update<br></br></tt></p>
<p>Что делает перехватчик <tt>post-update</tt>? Обычно он выглядит так:</p>
<p><tt>$&nbsp;cat&nbsp;.git/hooks/post-update&nbsp;<br></br>#!/bin/sh<br></br>exec&nbsp;git-update-server-info<br></br></tt></p>
<p>Это означает, что когда вы отправляете что-то с помощью <tt>git push</tt> на сервер по SSH, Git будет запускать эту команду, чтобы обновить файлы необходимые для скачивания по HTTP.</p>
<p>Затем вы должны добавить запись VirtualHost в конфигурацию вашего Apache с корневым каталогом документов в каталоге с вашими Git-проектами. Здесь мы подразумеваем, что ваш DNS-сервер настроен на отсылку <tt>*.gitserver</tt> на ту машину, на которой всё это запущено:</p>
<p><tt>&lt;VirtualHost&nbsp;*:80&gt;<br></br>&nbsp;&nbsp;&nbsp;&nbsp;ServerName&nbsp;git.gitserver<br></br>&nbsp;&nbsp;&nbsp;&nbsp;DocumentRoot&nbsp;/opt/git<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;Directory&nbsp;/opt/git/&gt;<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Order&nbsp;allow,&nbsp;deny<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow&nbsp;from&nbsp;all<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Directory&gt;<br></br>&lt;/VirtualHost&gt;<br></br></tt></p>
<p>Вам также понадобится установить Unix-группу для каталога <tt>/opt/git</tt> в <tt>www-data</tt>, чтобы ваш веб-сервер получил доступ на чтение этих каталогов, поскольку (по умолчанию) Apache запускает CGI-сценарии от имени такого пользователя:</p>
<p><tt>$&nbsp;chgrp&nbsp;-R&nbsp;www-data&nbsp;/opt/git<br></br></tt></p>
<p>После перезапуска Apache вы должны получить возможность склонировать ваши репозитории из этого каталога указывая их в URL:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;http://git.gitserver/project.git<br></br></tt></p>
<p>Таким образом, вы можете настроить доступ на чтение по HTTP к любому из ваших проектов для значительного количества пользователей за несколько минут. Другой простой способ дать открытый неаутентифицируемый доступ &mdash; использовать Git-демон, однако это требует запуска процесса демона. Мы рассмотрим этот вариант в следующем разделе, если вы предпочитаете этот вариант.</p>
<div></div><p id="calibre_link-97"><span><span><b>GitWeb</b></span></span></p>
<p>Теперь, когда у вас есть основной доступ на чтение и запись и доступ только на чтение к вашему проекту, вероятно, вы захотите настроить простой веб-визуализатор. Git поставляется в комплекте с CGI-сценарием, называющимся GitWeb, который обычно используется для этого. Вы можете увидеть GitWeb в действии на таких сайтах как <tt>http://git.kernel.org</tt> (рис. 4-1).</p>
<p><img src="images/000031.jpg"></img></p>
<p>Если вы хотите проверить, как GitWeb будет выглядеть для вашего проекта, Git поставляется с командой для быстрой установки временного экземпляра, если в вашей системе есть легковесный веб-сервер, такой как <tt>lighttpd</tt> или <tt>webrick</tt>. На машинах с Linux'ом <tt>lighttpd</tt> часто установлен, поэтому возможно вы сможете его запустить, выполнив <tt>git instaweb</tt> в каталоге с вашим проектом. Если вы используете Mac, Leopard поставляется с предустановленным Ruby, поэтому <tt>webrick</tt> может быть лучшим выбором. Чтобы запустить <tt>instaweb</tt> не с <tt>lighttpd</tt>, вы можете запустить команду с параметром <tt>--httpd</tt>.</p>
<p><tt>$&nbsp;git&nbsp;instaweb&nbsp;--httpd=webrick<br></br>[2009-02-21&nbsp;10:02:21]&nbsp;INFO&nbsp;&nbsp;WEBrick&nbsp;1.3.1<br></br>[2009-02-21&nbsp;10:02:21]&nbsp;INFO&nbsp;&nbsp;ruby&nbsp;1.8.6&nbsp;(2008-03-03)&nbsp;[universal-darwin9.0]<br></br></tt></p>
<p>Это запустит сервер HTTPD на порте 1234 и затем запустит веб-браузер, открытый на этой странице. Это очень просто. Когда вы закончили и хотите остановить сервер, вы можете запустить ту же команду с параметром <tt>--stop</tt>:</p>
<p><tt>$&nbsp;git&nbsp;instaweb&nbsp;--httpd=webrick&nbsp;--stop<br></br></tt></p>
<p>Если вы хотите иметь постоянно работающий веб-интерфейс на сервере для своей команды или для своего проекта с открытым кодом, вам необходимо установить CGI-сценарий на своём веб-сервере. В некоторых дистрибутивах Linux есть пакет <tt>gitweb</tt>, который можно установить, используя <tt>apt</tt> или <tt>yum</tt>, так что вы можете попробовать сначала этот способ. Мы рассмотрим установку GitWeb вручную очень быстро. Для начала вам нужно получить исходный код Git'а, с которым поставляется GitWeb, и сгенерировать CGI-сценарий под свою систему:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;git://git.kernel.org/pub/scm/git/git.git<br></br>$&nbsp;cd&nbsp;git/<br></br>$&nbsp;make&nbsp;GITWEB_PROJECTROOT="/opt/git"&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefix=/usr&nbsp;gitweb<br></br>$&nbsp;sudo&nbsp;cp&nbsp;-Rf&nbsp;gitweb&nbsp;/var/www/<br></br></tt></p>
<p>Помните, что вы должны указать команде, где расположены ваши Git-репозитории с помощью переменной <tt>GITWEB_PROJECTROOT</tt>. Теперь нужно настроить Apache на использование этого сценария, для чего вы можете добавить виртуальный хост:</p>
<p><tt>&lt;VirtualHost&nbsp;*:80&gt;<br></br>&nbsp;&nbsp;&nbsp;&nbsp;ServerName&nbsp;gitserver<br></br>&nbsp;&nbsp;&nbsp;&nbsp;DocumentRoot&nbsp;/var/www/gitweb<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;Directory&nbsp;/var/www/gitweb&gt;<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options&nbsp;ExecCGI&nbsp;+FollowSymLinks&nbsp;+SymLinksIfOwnerMatch<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AllowOverride&nbsp;All<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order&nbsp;allow,deny<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allow&nbsp;from&nbsp;all<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddHandler&nbsp;cgi-script&nbsp;cgi<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DirectoryIndex&nbsp;gitweb.cgi<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Directory&gt;<br></br>&lt;/VirtualHost&gt;<br></br></tt></p>
<p>Повторюсь, GitWeb может быть установлен на любой веб-сервер, совместимый с CGI. Если вы предпочитаете использовать что-то другое, настройка не должна стать для вас проблемой. К этому моменту вы должны иметь возможность зайти на <tt>http://gitserver/</tt> для просмотра ваших репозиториев онлайн, а также использовать <tt>http://git.gitserver</tt> для клонирования и извлечения данных для ваших репозиториев по HTTP.</p>
<div></div><p id="calibre_link-98"><span><span><b>Gitosis</b></span></span></p>
<p>Хранение открытых ключей всех пользователей в <tt>authorized_keys</tt> для предоставления доступа работает хорошо лишь на время. Когда у вас сотни пользователей, это скорее похоже на пытку. Вы должны заходить на сервер каждый раз, и нет никакого разграничения доступа &mdash; все перечисленные в файле имеют доступ на чтение и на запись к каждому проекту.</p>
<p>На этой стадии вы можете захотеть обратиться к широко используемому ПО под названием Gitosis. Gitosis &mdash; это просто набор сценариев (scripts), который поможет вам управляться с файлом <tt>authorized_keys</tt> и реализовать простой контроль доступа. Действительно интересно, что добавление людей и настройка доступа для них осуществляется не через веб-интерфейс, а с помощью специального git-репозитория. Вы настраиваете информацию в этом проекте и, когда вы отправляете её в репозиторий, Gitosis, исходя из неё, перенастраивает сервер, что круто.</p>
<p>Установка Gitosis'а &mdash; не самая простая задача, хотя и не слишком сложная. Проще всего использовать под него Linux-сервер &mdash; в наших примерах используется сервер Ubuntu 8.10 в начальной конфигурации.</p>
<p>Gitosis'у нужны некоторые инструменты для Python'а, так что первым делом вы должны установить для Python'а пакет setuptools, который в Ubuntu называется python-setuptools:</p>
<p><tt>$&nbsp;apt-get&nbsp;install&nbsp;python-setuptools<br></br></tt></p>
<p>Затем вы клонируете и устанавливаете Gitosis с главного сайта проекта:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;https://github.com/tv42/gitosis.git<br></br>$&nbsp;cd&nbsp;gitosis<br></br>$&nbsp;sudo&nbsp;python&nbsp;setup.py&nbsp;install<br></br></tt></p>
<p>Это установит несколько исполняемых файлов, которые Gitosis будет использовать. Затем Gitosis хочет расположить свои репозитории в каталоге <tt>/home/git</tt>, что неплохо. Но вы уже установили репозитории в <tt>/opt/git</tt>, так что вместо перенастройки всего на свете вы сделаете символическую ссылку:</p>
<p><tt>$&nbsp;ln&nbsp;-s&nbsp;/opt/git&nbsp;/home/git/repositories<br></br></tt></p>
<p>Gitosis будет управлять ключами за вас, так что вы должны удалить текущий файл, добавить ключи снова позже и предоставить Gitosis'у управлять файлом <tt>authorized_keys</tt> автоматически. Сейчас просто уберите этот файл с дороги:</p>
<p><tt>$&nbsp;mv&nbsp;/home/git/.ssh/authorized_keys&nbsp;/home/git/.ssh/ak.bak<br></br></tt></p>
<p>Затем вы должны вернуть пользователю git его командную оболочку, если вы меняли её на команду <tt>git-shell</tt>. Люди всё так же не смогут выполнить вход, но для вас это будет контролировать Gitosis. Итак, давайте поменяем эту строку в файле '/etc/passwd'</p>
<p><tt>git:x:1000:1000::/home/git:/usr/bin/git-shell<br></br></tt></p>
<p>обратно на эту:</p>
<p><tt>git:x:1000:1000::/home/git:/bin/sh<br></br></tt></p>
<p>Теперь самое время инициализировать Gitosis. Сделаете это, выполнив команду <tt>gitosis-init</tt> со своим персональным открытым ключом. Если вашего открытого ключа ещё нет на сервере, вам нужно будет скопировать его туда:</p>
<p><tt>$&nbsp;sudo&nbsp;-H&nbsp;-u&nbsp;git&nbsp;gitosis-init&nbsp;&lt;&nbsp;/tmp/id_dsa.pub<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/git/gitosis-admin.git/<br></br>Reinitialized&nbsp;existing&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/git/gitosis-admin.git/<br></br></tt></p>
<p>Это позволит пользователю с таким ключом изменять главный Git-репозиторий, который управляет настройками Gitosis'а. Затем вы должны вручную установить бит исполнения на сценарий <tt>post-update</tt> в новом управляющем репозитории.</p>
<p><tt>$&nbsp;sudo&nbsp;chmod&nbsp;755&nbsp;/opt/git/gitosis-admin.git/hooks/post-update<br></br></tt></p>
<p>Всё готово. Если вы всё настроили правильно, вы можете попытаться соединиться по SSH с вашим сервером под тем пользователем, для которого вы добавили открытый ключ, чтобы инициализировать Gitosis. Вы должны увидеть что-то вроде этого:</p>
<p><tt>$&nbsp;ssh&nbsp;git@gitserver<br></br>PTY&nbsp;allocation&nbsp;request&nbsp;failed&nbsp;on&nbsp;channel&nbsp;0<br></br>fatal:&nbsp;unrecognized&nbsp;command&nbsp;'gitosis-serve&nbsp;schacon@quaternion'<br></br>&nbsp;&nbsp;Connection&nbsp;to&nbsp;gitserver&nbsp;closed.<br></br></tt></p>
<p>Это означает, что Gitosis узнал вас, но не пустил, потому что вы не пытались выполнить ни одну из команд Git'а. Ну так давайте выполним настоящую команду Git'а &mdash; вы склонируете управляющий репозиторий Gitosis:</p>
<p><tt>#&nbsp;на&nbsp;вашем&nbsp;локальном&nbsp;компьютере<br></br>$&nbsp;git&nbsp;clone&nbsp;git@gitserver:gitosis-admin.git<br></br></tt></p>
<p>Теперь у вас есть каталог с именем <tt>gitosis-admin</tt>, в котором есть две главные части:</p>
<p><tt>$&nbsp;cd&nbsp;gitosis-admin<br></br>$&nbsp;find&nbsp;.<br></br>./gitosis.conf<br></br>./keydir<br></br>./keydir/scott.pub<br></br></tt></p>
<p>Файл <tt>gitosis.conf</tt> &mdash; файл настройки, который используется, чтобы указать пользователей, репозитории и права доступа. В каталоге <tt>keydir</tt> должны храниться открытые ключи всех пользователей, у которых есть какой-либо доступ к вашим репозиториям &mdash; по файлу на пользователя. Имя файла в <tt>keydir</tt> (в предыдущем примере <tt>scott.pub</tt>) у вас будет отличаться &mdash; Gitosis берёт это имя из описания в конце открытого ключа, который был импортирован сценарием <tt>gitosis-init</tt>.</p>
<p>Если вы посмотрите в файл <tt>gitosis.conf</tt>, там должна быть указана только информация о проекте <tt>gitosis-admin</tt>, который вы только что склонировали:</p>
<p><tt>$&nbsp;cat&nbsp;gitosis.conf&nbsp;<br></br>[gitosis]<br></br><br></br>[group&nbsp;gitosis-admin]<br></br>writable&nbsp;=&nbsp;gitosis-admin<br></br>members&nbsp;=&nbsp;scott<br></br></tt></p>
<p>Это показывает, что пользователь 'scott' &mdash; пользователь, чьим открытым ключом вы инициализировали Gitosis &mdash; единственный, кто имеет доступ к проекту <tt>gitosis-admin</tt>.</p>
<p>А теперь давайте добавим новый проект. Добавьте новую секцию с названием <tt>mobile</tt> и перечислите в ней всех разработчиков из команды, занимающейся мобильными устройствами, а также проекты, к которым этим разработчикам нужно иметь доступ. Поскольку <tt>scott</tt> &mdash; пока что единственный пользователь в системе, добавьте его как единственного члена и создайте новый проект под названием <tt>iphone_project</tt>, чтобы ему было с чем начать работать:</p>
<p><tt>[group&nbsp;mobile]<br></br>writable&nbsp;=&nbsp;iphone_project<br></br>members&nbsp;=&nbsp;scott<br></br></tt></p>
<p>Когда вы вносите изменения в проект <tt>gitosis-admin</tt>, вы должны зафиксировать изменения и отправить их на сервер, чтобы они возымели эффект:</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'add&nbsp;iphone_project&nbsp;and&nbsp;mobile&nbsp;group'<br></br>[master]:&nbsp;created&nbsp;8962da8:&nbsp;"changed&nbsp;name"<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;4&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br>$&nbsp;git&nbsp;push<br></br>Counting&nbsp;objects:&nbsp;5,&nbsp;done.<br></br>Compressing&nbsp;objects:&nbsp;100%&nbsp;(2/2),&nbsp;done.<br></br>Writing&nbsp;objects:&nbsp;100%&nbsp;(3/3),&nbsp;272&nbsp;bytes,&nbsp;done.<br></br>Total&nbsp;3&nbsp;(delta&nbsp;1),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)<br></br>To&nbsp;git@gitserver:/opt/git/gitosis-admin.git<br></br>&nbsp;&nbsp;&nbsp;fb27aec..8962da8&nbsp;&nbsp;master&nbsp;-&gt;&nbsp;master<br></br></tt></p>
<p>Вы можете сделать свой первый push в новый проект <tt>iphone_project</tt>, добавив свой сервер в качестве удалённого (remote) в локальную версию проекта и выполнив <tt>git push</tt>. Вам больше не нужно вручную создавать голые репозитории на сервере для новых проектов &mdash; Gitosis создаёт их сам автоматически, когда видит первый push:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;origin&nbsp;git@gitserver:iphone_project.git<br></br>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/git/iphone_project.git/<br></br>Counting&nbsp;objects:&nbsp;3,&nbsp;done.<br></br>Writing&nbsp;objects:&nbsp;100%&nbsp;(3/3),&nbsp;230&nbsp;bytes,&nbsp;done.<br></br>Total&nbsp;3&nbsp;(delta&nbsp;0),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)<br></br>To&nbsp;git@gitserver:iphone_project.git<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;-&gt;&nbsp;master<br></br></tt></p>
<p>Заметьте, что вам не нужно указывать путь (фактически, если вы это сделаете, то оно не сработает), только двоеточие и имя проекта &mdash; Gitosis найдёт его за вас.</p>
<p>Вы хотите работать над проектом с вашими друзьями, так что вам нужно снова добавить их открытые ключи. Но вместо того, чтобы вручную добавлять их к файлу <tt>~/.ssh/authorized_keys</tt> на вашем сервере, добавьте их, один файл на ключ, в каталог <tt>keydir</tt>. То, как вы назовёте ключи, определит, как вы будете ссылаться на пользователей в <tt>gitosis.conf</tt>. Давайте по-новому добавим открытые ключи для Джона, Джози и Джессики:</p>
<p><tt>$&nbsp;cp&nbsp;/tmp/id_rsa.john.pub&nbsp;keydir/john.pub<br></br>$&nbsp;cp&nbsp;/tmp/id_rsa.josie.pub&nbsp;keydir/josie.pub<br></br>$&nbsp;cp&nbsp;/tmp/id_rsa.jessica.pub&nbsp;keydir/jessica.pub<br></br></tt></p>
<p>Теперь вы можете добавить их всех в вашу 'мобильную' команду, чтобы они имели доступ на чтение и запись в <tt>iphone_project</tt>:</p>
<p><tt>[group&nbsp;mobile]<br></br>writable&nbsp;=&nbsp;iphone_project<br></br>members&nbsp;=&nbsp;scott&nbsp;john&nbsp;josie&nbsp;jessica<br></br></tt></p>
<p>После того, как вы зафиксируете и отправите изменения, все четыре пользователя будут иметь возможность читать и писать в проект.</p>
<p>В Gitosis'е также есть простой контроль доступа. Если вы хотите, чтобы Джон имел только доступ на чтение к этому проекту, вы можете вместо этого сделать:</p>
<p><tt>[group&nbsp;mobile]<br></br>writable&nbsp;=&nbsp;iphone_project<br></br>members&nbsp;=&nbsp;scott&nbsp;josie&nbsp;jessica<br></br><br></br>[group&nbsp;mobile_ro]<br></br>readonly&nbsp;=&nbsp;iphone_project<br></br>members&nbsp;=&nbsp;john<br></br></tt></p>
<p>Теперь Джон может клонировать проект и получать обновления, но Gitosis не позволит ему отправлять изменения обратно в проект. Вы можете создать таких групп сколько хотите, каждую содержащую разные проекты и пользователей. Вы также можете указать другую группу в качестве одного из пользователей (используя <tt>@</tt> как префикс), чтобы автоматически добавить всех её членов:</p>
<p><tt>[group&nbsp;mobile_committers]<br></br>members&nbsp;=&nbsp;scott&nbsp;josie&nbsp;jessica<br></br><br></br>[group&nbsp;mobile]<br></br>writable&nbsp;&nbsp;=&nbsp;iphone_project<br></br>members&nbsp;&nbsp;&nbsp;=&nbsp;@mobile_committers<br></br><br></br>[group&nbsp;mobile_2]<br></br>writable&nbsp;&nbsp;=&nbsp;another_iphone_project<br></br>members&nbsp;&nbsp;&nbsp;=&nbsp;@mobile_committers&nbsp;john<br></br></tt></p>
<p>Если у вас возникли какие-то проблемы, полезным может быть добавить <tt>loglevel=DEBUG</tt> в секции <tt>[gitosis]</tt>. Если вы потеряли доступ к отправке, отправив неверную конфигурацию, вы можете вручную поправить файл <tt>/home/git/.gitosis.conf</tt> на сервере &mdash; файл, из которого Gitosis читает свою информацию. Отправка в проект берёт файл <tt>gitosis.conf</tt>, который вы только что отправили, и помещает его туда. Если вы отредактируете этот файл вручную, он останется таким до следующей успешной отправки в проект <tt>gitosis-admin</tt>.</p>
<div></div><p id="calibre_link-99"><span><span><b>Gitolite</b></span></span></p>
<p>В этом разделе мы вкратце рассмотрим Gitolite, научимся его устанавливать и настраивать. Gitolite представляет собой дополнительную прослойку поверх Git'а, обеспечивающую широкие возможности по управлению правами доступа. Gitolite для авторизации использует <tt>sshd</tt> или <tt>httpd</tt>.</p>
<p>Gitolite даёт возможность назначать права доступа не только для всего репозитория, но и для отдельных веток или имён меток внутри любого репозитория. То есть вы можете указать, что определённые люди (или группы людей) могут отправлять (push) определённые "ссылки" (ветки или метки), а остальные нет.</p>
<p id="calibre_link-100"><span><span><b>Установка</b></span></span></p>
<p>Установить Gitolite очень просто, даже не читая идущую с ним обширную документацию. Вам понадобится аккаунт на сервере с каким-нибудь Unix'ом. Вам не нужен root-доступ, если Git, Perl и OpenSSH-совместимый SSH-сервер уже установлены. Далее в примерах мы будем использовать аккаунт <tt>git</tt> на хосте с именем <tt>gitserver</tt>.</p>
<p>Gitolite несколько необычен, по крайней мере, в сравнении с другим "серверным" ПО &mdash; доступ осуществляется по SSH, и, следовательно, каждый пользователь на сервере является потенциальным "gitolite-хостом". В этом разделе мы рассмотрим самый простой метод установки; про остальные методы можно прочитать в документации.</p>
<p>Для начала, создайте пользователя с именем <tt>git</tt> на своём сервере и войдите в систему под этим пользователем. Скопируйте свой открытый ключ (это файл <tt>~/.ssh/id_rsa.pub</tt>, если вы сгенерировали его с помощью просто <tt>ssh-keygen</tt> без изменения параметров) со своего рабочего компьютера и переименуйте его в <tt>&lt;вашеимя&gt;.pub</tt> (в нашем примере это будет файл <tt>scott.pub</tt>). Затем выполните следующие команды:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;git://github.com/sitaramc/gitolite<br></br>$&nbsp;gitolite/install&nbsp;-ln<br></br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;предполагает,&nbsp;что&nbsp;$HOME/bin&nbsp;существует&nbsp;и&nbsp;находится&nbsp;в&nbsp;$PATH<br></br>$&nbsp;gitolite&nbsp;setup&nbsp;-pk&nbsp;$HOME/scott.pub<br></br></tt></p>
<p>Последняя из команд создаст на сервере новый Git-репозиторий с именем <tt>gitolite-admin</tt>.</p>
<p>В завершение, вернитесь на свой рабочий компьютер и выполните там <tt>git clone git@gitserver:gitolite-admin</tt>. И всё! Gitolite теперь установлен на сервере, а на вашей рабочей станции теперь есть новый репозиторий, который называется <tt>gitolite-admin</tt>. Администрировать свой установленный Gitolite нужно, внося изменения в этот репозиторий и отправляя их на сервер.</p>
<p id="calibre_link-101"><span><span><b>Изменение параметров установки</b></span></span></p>
<p>Хотя быстрая установка с параметрами по умолчанию подходит для большинства людей, есть несколько способов изменения параметров установки, если вам это нужно. Если опустить опцию <tt>-q</tt>, вы получите "подробную" установку с детальной информацией о том, что происходит на каждом шаге. Подробный режим также позволяет изменить некоторые параметры на стороне сервера такие, как расположение репозиториев, с помощью редактирования "rc" файла, используемого сервером. Этот "rc" файл содержит развёрнутые комментарии так, чтобы вы легко смогли сделать любые изменения, сохранить их и продолжить. Этот файл также содержит различные настройки, которые вы можете изменить, чтобы активировать или выключить некоторые "продвинутые" функции Gitolite'а.</p>
<p id="calibre_link-102"><span><span><b>Конфигурационный файл и правила контроля доступа</b></span></span></p>
<p>Теперь, когда установка завершена, перейдите в клон репозитория <tt>gitolite-admin</tt> на вашем рабочем компьютере и осмотритесь, чтобы выяснить, что же вы получили:</p>
<p><tt>$&nbsp;cd&nbsp;~/gitolite-admin/<br></br>$&nbsp;ls<br></br>conf/&nbsp;&nbsp;keydir/<br></br>$&nbsp;find&nbsp;conf&nbsp;keydir&nbsp;-type&nbsp;f<br></br>conf/gitolite.conf<br></br>keydir/scott.pub<br></br>$&nbsp;cat&nbsp;conf/gitolite.conf<br></br><br></br>repo&nbsp;gitolite-admin<br></br>&nbsp;&nbsp;&nbsp;&nbsp;RW+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;scott<br></br><br></br>repo&nbsp;testing<br></br>&nbsp;&nbsp;&nbsp;&nbsp;RW+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;@all<br></br></tt></p>
<p>Заметьте, что "scott" (имя файла открытого ключа, использовавшееся ранее при запуске команды <tt>gitolite setup</tt>) имеет права на чтение и запись в репозиторий <tt>gitolite-admin</tt>, а также файл с открытым ключом с таким же именем.</p>
<p>Добавить нового пользователя просто. Чтобы добавить пользователя "alice", возьмите её ключ, переименуйте его в <tt>alice.pub</tt> и положите в каталог <tt>keydir</tt> клона репозитория <tt>gitolite-admin</tt> на вашем компьютере. Выполните <tt>add</tt>, <tt>commit</tt>, отправьте изменения, и пользователь добавлен.</p>
<p>Синтаксис конфигурационного файла для Gitolite'а подробно продокументирован, так что мы рассмотрим здесь только основные моменты.</p>
<p>Вы можете сгруппировать пользователей или репозитории для удобства. Имена групп совсем как макросы; когда вы их определяете, даже неважно, определяют ли они проекты или пользователей; это различие делается, только когда вы <span><i>используете</i></span> "макрос".</p>
<p><tt>@oss_repos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;linux&nbsp;perl&nbsp;rakudo&nbsp;git&nbsp;gitolite<br></br>@secret_repos&nbsp;&nbsp;&nbsp;=&nbsp;fenestra&nbsp;pear<br></br><br></br>@admins&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;scott<br></br>@interns&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;ashok<br></br>@engineers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;sitaram&nbsp;dilbert&nbsp;wally&nbsp;alice<br></br>@staff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;@admins&nbsp;@engineers&nbsp;@interns<br></br></tt></p>
<p>Вы можете контролировать права доступа на уровне "ссылок" (то, что находится в .git/refs/). В следующем примере стажёры (группа @interns) могут отправлять (push) только ветку "int". Инженеры (группа @engineers) могут отправлять любую ветку, чьё имя начинается с "eng-", а также метки, начинающиеся с "rc" и затем содержащие цифры. Администраторы (группа @admins) могут делать всё с любыми ссылками (в том числе откатывать назад).</p>
<p><tt>repo&nbsp;@oss_repos<br></br>&nbsp;&nbsp;&nbsp;&nbsp;RW&nbsp;&nbsp;int$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;@interns<br></br>&nbsp;&nbsp;&nbsp;&nbsp;RW&nbsp;&nbsp;eng-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;@engineers<br></br>&nbsp;&nbsp;&nbsp;&nbsp;RW&nbsp;&nbsp;refs/tags/rc[0-9]&nbsp;&nbsp;&nbsp;=&nbsp;@engineers<br></br>&nbsp;&nbsp;&nbsp;&nbsp;RW+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;@admins<br></br></tt></p>
<p>Выражение после <tt>RW</tt> или <tt>RW+</tt> &mdash; это регулярное выражение (regex), с которым сопоставляется имя отправляемой ссылки (ref). Поэтому мы называем его "refex"! Конечно, "refex" может быть гораздо более сложным, чем показано здесь, так что не переусердствуйте с ними, если вы не очень хорошо знакомы с регулярными выражениями Perl.</p>
<p>К тому же, как вы уже, наверное, догадались, Gitolite для удобства дописывает в начале регулярного выражения <tt>refs/heads/</tt>, если оно не начинается с <tt>refs/</tt>.</p>
<p>Важной особенностью синтаксиса конфигурационного файла является то, что все правила для репозитория не обязательно должны находиться в одном месте. Вы можете держать все общие вещи вместе, как, например, правила для всех <tt>oss_repos</tt> выше, а потом добавить уточняющие правила для отдельных случаев следующим образом:</p>
<p><tt>repo&nbsp;gitolite<br></br>&nbsp;&nbsp;&nbsp;&nbsp;RW+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;sitaram<br></br></tt></p>
<p>Это правило будет добавлено к набору правил для репозитория <tt>gitolite</tt>.</p>
<p>В данный момент вы, возможно, задаётесь вопросом: "Каким образом правила контроля доступа применяются на самом деле?" &mdash; так что давайте вкратце рассмотрим это.</p>
<p>В Gitolite'е есть два уровня контроля доступа. Первый &mdash; на уровне репозитория; если у вас есть доступ на чтение (или запись) к <span><i>любой</i></span> ссылке в репозитории, то у вас есть доступ на чтение (или запись) к этому репозиторию.</p>
<p>Второй уровень применим только к доступу на запись и осуществляется по веткам или меткам внутри репозитория. Имя пользователя, запрашиваемый уровень доступа (<tt>W</tt> или <tt>+</tt>) и имя ссылки, которая будет обновлена, известны. Правила доступа проверяются в порядке их появления в конфигурационном файле, в поисках совпадений для этой комбинации (но помните, что имя ссылки сопоставляется с регулярным выражением, а не просто строкой). Если совпадение найдено, отправка (push) проходит успешно. При неудачном исходе доступ запрещается.</p>
<p id="calibre_link-103"><span><span><b>Продвинутый контроль доступа с запрещающими правилами</b></span></span></p>
<p>До сих пор у нас были только права вида <tt>R</tt>, <tt>RW</tt> или <tt>RW+</tt>. Однако в Gitolite'е есть другие права доступа: <tt>-</tt> означающий "запретить". Это даёт гораздо больше возможностей в обмен на большую сложность, так как теперь отсутствие разрешающего правила &mdash; не <span><i>единственный</i></span> вариант, при котором пользователю может быть отказано в доступе, так что <span><i>порядок правил теперь имеет значение</i></span>!</p>
<p>Предположим, в описанной выше ситуации мы хотим, чтобы инженеры могли откатить назад любую ветку, <span><i>кроме</i></span>
<tt>master</tt> и <tt>integ</tt>. Вот как это сделать:</p>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;RW&nbsp;&nbsp;master&nbsp;integ&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;@engineers<br></br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;master&nbsp;integ&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;@engineers<br></br>&nbsp;&nbsp;&nbsp;&nbsp;RW+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;@engineers<br></br></tt></p>
<p>Снова, вы просто идёте по правилам сверху вниз, пока не наткнётесь на соответствующее вашему режиму доступа или на запрет. Неоткатывающий push в <tt>master</tt> или <tt>integ</tt> разрешается первым правилом. Откатывающий push для этих ссылок не соответствует первому правилу, переходит ко второму и поэтому запрещается. Любой push (откатывающий или неоткатывающий) по ссылкам, отличным от <tt>master</tt> и <tt>integ</tt>, не совпадёт с первыми двумя правилами, а третье правило его разрешает.</p>
<p id="calibre_link-104"><span><span><b>Ограничение push'ей на основе изменённых файлов</b></span></span></p>
<p>Вдобавок к ограничению веток, в которые пользователю можно отправлять изменения, вы можете также ограничить файлы, которые он может трогать. Например, возможно, Makefile (или какая-то другая программа) не предназначен для изменения кем угодно, так как многие вещи зависят от него или сломаются, если изменения не будут сделаны <span><i>правильно</i></span>. Вы можете сказать Gitolite'у:</p>
<p><tt>repo&nbsp;foo<br></br>&nbsp;&nbsp;&nbsp;&nbsp;RW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;@junior_devs&nbsp;@senior_devs<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;VREF/NAME/Makefile&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;@junior_devs<br></br></tt></p>
<p>Стоит предостеречь тех, кто пользовался старыми версиями Gitolite'а, о том, что в новых версиях поведение этой функции было сильно изменено. Подробнее об этих изменениях можно узнать в руководстве по миграции.</p>
<p id="calibre_link-105"><span><span><b>Персональные ветки</b></span></span></p>
<p>Gitolite также имеет средство, которое называется "персональные ветки" (или даже "персональное пространство имён веток"), которое может быть весьма полезным в корпоративных средах.</p>
<p>Очень часто обмен кодом в мире Git'а происходит через запросы "пожалуйста, заберите (pull)". В корпоративных средах, однако, неаутентифицированный доступ под строгим запретом, и рабочая станция разработчика не может выполнить аутентификацию. Так что вы вынуждены отправить (push) работу на центральный сервер и попросить кого-нибудь забрать (pull) её оттуда.</p>
<p>Это обычно вызывает такой же беспорядок с именами веток, что и в централизованных СКВ, плюс настройка прав доступа для этого становится ежедневной обязанностью админа.</p>
<p>Gitolite позволяет определить "персональный" или "рабочий" префикс пространства имён для каждого разработчика (например, <tt>refs/personal/&lt;devname&gt;/*</tt>); подробное описание этой функциональности есть в документации.</p>
<p id="calibre_link-106"><span><span><b>"Шаблонные" репозитории</b></span></span></p>
<p>Gitolite позволяет указывать репозитории с помощью шаблонов (на самом деле регулярных выражений Perl'а), таких как, например, <tt>assignments/s[0-9][0-9]/a[0-9][0-9]</tt>. Это позволяет назначать новый режим доступа (<tt>C</tt>), который позволяет пользователям создавать репозитории на основе подобных шаблонов, автоматически назначает владельцем пользователя, который создал репозиторий, позволяет ему раздавать <tt>R</tt> и <tt>RW</tt> права другим пользователям и т.п.</p>
<p id="calibre_link-107"><span><span><b>Другие функции</b></span></span></p>
<p>Мы закончим это обсуждение рассмотрением подборки других функций, все они и многие другие описаны в мельчайших подробностях в документации.</p>
<p><span><b>Логирование</b></span>: Gitolite регистрирует все успешные действия. Если вы несколько легкомысленно раздали людям права на откатывание изменений (<tt>RW+</tt>) и кто-то снёс <tt>master</tt>, лог-файл спасёт вам жизнь, и вы легко и быстро найдёте потерянный SHA.</p>
<p><span><b>Уведомление о правах доступа</b></span>: Другая удобная функция проявляется в момент, когда вы просто проверяете и заходите по ssh на сервер. Gitolite показывает, к каким репозиториям у вас есть доступ и какого типа доступ может быть получен. Вот пример:</p>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;scott,&nbsp;this&nbsp;is&nbsp;git@git&nbsp;running&nbsp;gitolite3&nbsp;v3.01-18-g9609868&nbsp;on&nbsp;git&nbsp;1.7.4.4<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;anu-wsd<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entrans<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;W&nbsp;&nbsp;git-notes<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;W&nbsp;&nbsp;gitolite<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;W&nbsp;&nbsp;gitolite-admin<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indic_web_input<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shreelipi_converter<br></br></tt></p>
<p><span><b>Делегирование</b></span>: При действительно больших установках вы можете делегировать ответственность за группы репозиториев различным людям, которые будут независимо управлять этими частями. Это уменьшает нагрузку на главного админа и делает его не таким критичным элементом.</p>
<p><span><b>Зеркалирование</b></span>: Gitolite может помочь вам поддерживать несколько зеркал, и легко переключаться между ними, если основной сервер упадёт.</p>
<div></div><p id="calibre_link-108"><span><span><b>Git-демон</b></span></span></p>
<p>Для предоставления публичного неаутентифицируемого доступа на чтение к своим проектам стоит продвинуться дальше, чем протокол HTTP, и начать использовать Git-протокол. Основное его преимущество &mdash; скорость. Git-протокол гораздо эффективнее и следовательно быстрее чем HTTP, поэтому, используя его, вы можете сэкономить своим пользователям время.</p>
<p>Напомним, что он годится только для доступа на чтение без аутентификации. Если вы запустили его на сервере не загороженном сетевым экраном, то он должен использоваться только для проектов, которые публично видны внешнему миру. Если сервер, на котором вы его запускаете, находится за сетевым экраном, тогда его вполне можно использовать для проектов, к которым нужно иметь доступ только на чтение для большого числа людей или компьютеров (серверов непрерывной интеграции или сборки), если вы не хотите для каждого из них заводить свой SSH-ключ.</p>
<p>В любом случае, Git-протокол относительно просто настроить. По сути, вам нужно запустить следующую команду в демонизированной форме:</p>
<p><tt>git&nbsp;daemon&nbsp;--reuseaddr&nbsp;--base-path=/opt/git/&nbsp;/opt/git/<br></br></tt></p>
<p>Опция <tt>--reuseaddr</tt> позволит серверу перезапускаться без ожидания окончания старых соединений, <tt>--base-path</tt> позволит людям не указывать полный путь при клонировании проекта, а путь в конце говорит Git-демону, где искать экспортируемые репозитории. Если у вас запущен сетевой экран, то ещё необходимо проделать в нём дырочку, открыв порт 9418 на машине, на которой это всё запущено.</p>
<p>Вы можете демонизировать этот процесс несколькими путями, в зависимости от операционной системы. На машине с Ubuntu используйте Upstart-сценарий. Итак, в этот файл</p>
<p><tt>/etc/event.d/local-git-daemon<br></br></tt></p>
<p>поместите такой сценарий:</p>
<p><tt>start&nbsp;on&nbsp;startup<br></br>stop&nbsp;on&nbsp;shutdown<br></br>exec&nbsp;/usr/bin/git&nbsp;daemon&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;&nbsp;--user=git&nbsp;--group=git&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;&nbsp;--reuseaddr&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;&nbsp;--base-path=/opt/git/&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;&nbsp;/opt/git/<br></br>respawn<br></br></tt></p>
<p>По соображениям безопасности крайне желательно, чтобы вы запускали этот демон от пользователя с правами только на чтение на репозитории &mdash; вы легко можете сделать это, создав пользователя 'git-ro' и запустив этот демон из-под него. Для простоты мы запустим его от того же пользователя 'git', от которого запущен Gitosis.</p>
<p>Когда вы перезапустите машину, Git-демон запустится автоматически, и возродится, если вдруг завершится. Чтобы запустить его без перезагрузки машины, выполните следующее:</p>
<p><tt>initctl&nbsp;start&nbsp;local-git-daemon<br></br></tt></p>
<p>На других системах вы можете использовать <tt>xinetd</tt>, сценарий для системы <tt>sysvinit</tt>, или что-то другое &mdash; главное, чтобы вы могли эту команду как-либо демонизировать и перезапускать в случае завершения.</p>
<p>Затем, вы должны указать Gitosis-серверу, к каким репозиториям предоставить неаутентифицируемый доступ через Git-сервер. Если вы добавили по секции для каждого репозитория, вы можете указать, из каких из них Git-демону позволено читать. Если вы хотите предоставить доступ по Git-протоколу к <tt>iphone_project</tt>, добавьте следующее в конец своего файла <tt>gitosis.conf</tt>:</p>
<p><tt>[repo&nbsp;iphone_project]<br></br>daemon&nbsp;=&nbsp;yes<br></br></tt></p>
<p>Когда это зафиксировано и отправлено, ваш запущенный демон должен начать обслуживать запросы к проекту от всех, у кого есть доступ к порту 9418 на вашем сервере.</p>
<p>Если вы решили не использовать Gitosis, но хотите установить Git-демон, вам необходимо выполнить следующее в каждом проекте, который должен обслуживаться Git-демоном:</p>
<p><tt>$&nbsp;cd&nbsp;/path/to/project.git<br></br>$&nbsp;touch&nbsp;git-daemon-export-ok<br></br></tt></p>
<p>Наличие этого файла скажет Git'у, что этот проект можно обслуживать без аутентификации.</p>
<p>Gitosis также может контролировать, какие проекты будет показывать GitWeb. Вам нужно добавить что-то вроде этого в файл <tt>/etc/gitweb.conf</tt>:</p>
<p><tt>$projects_list&nbsp;=&nbsp;"/home/git/gitosis/projects.list";<br></br>$projectroot&nbsp;=&nbsp;"/home/git/repositories";<br></br>$export_ok&nbsp;=&nbsp;"git-daemon-export-ok";<br></br>@git_base_url_list&nbsp;=&nbsp;('git://gitserver');<br></br></tt></p>
<p>Вы можете контролировать, какие проекты GitWeb будет позволять просматривать пользователям, добавляя или удаляя пункт настройки <tt>gitweb</tt> в конфигурационном файле Gitosis'а. Например, если вы хотите, чтобы <tt>iphone_project</tt> просматривался в GitWeb, сделайте так, чтобы секция настроек <tt>repo</tt> выглядела следующим образом:</p>
<p><tt>[repo&nbsp;iphone_project]<br></br>daemon&nbsp;=&nbsp;yes<br></br>gitweb&nbsp;=&nbsp;yes<br></br></tt></p>
<p>Теперь, если вы зафиксируете и отправите изменения, GitWeb автоматически начнёт показывать ваш проект для iphone.</p>
<div></div><p id="calibre_link-109"><span><span><b>Git-хостинг</b></span></span></p>
<p>Если вы не хотите связываться со всей работой по установке собственного Git-сервера, у вас есть несколько вариантов размещения ваших Git-проектов на внешних специальных хостинг сайтах. Это предоставляет множество преимуществ: на хостинг сайте обычно быстро настроить и запустить проект и нет никакого мониторинга или поддержки сервера. Даже если вы установили и запустили свой собственный внутренний сервер, вы можете захотеть использовать публичный хостинг сайт для вашего открытого кода &mdash; обычно сообществу открытого кода так будет проще вас найти и помочь.</p>
<p>В наши дни у вас есть огромное количество вариантов хостинга на выбор, все со своими преимуществами и недостатками. Актуальный список можно найти на следующей странице:</p>
<p><tt>https://git.wiki.kernel.org/index.php/GitHosting<br></br></tt></p>
<p>Поскольку мы не можем рассмотреть их все, и поскольку я работаю на один из них, мы в этом разделе рассмотрим процесс создания учётной записи и нового проекта на GitHub'е. Это даст вам представление о вовлечённых в него вещах.</p>
<p>GitHub &mdash; крупнейший на сегодняшний день сайт, предоставляющий Git-хостинг для проектов с открытым исходным кодом, а также один из немногих, предоставляющих одновременно и публичный, и приватный хостинг, так что вы можете хранить ваш открытый и коммерческий код в одном месте. На самом деле, мы использовали GitHub, чтобы закрыто совместно писать эту книгу (прим. переводчика: и открыто переводить после её издания).</p>
<p id="calibre_link-110"><span><span><b>GitHub</b></span></span></p>
<p>GitHub немного отличается от других хостингов кода способом группировки проектов. Вместо того, чтобы брать за основу проекты, GitHub ориентируется на пользователей. Это значит, что если я размещаю свой проект <tt>grit</tt> на GitHub'е, вы не найдёте его в <tt>github.com/grit</tt>, он будет в <tt>github.com/schacon/grit</tt>. Здесь нет никакой канонической версии проекта, что позволяет проектам беспрепятственно переходить от одного пользователя к другому, если начальный автор забросил проект.</p>
<p>GitHub &mdash; это коммерческая компания, которая взимает плату с учётных записей, использующих приватные репозитории, но любой может хоть сейчас получить бесплатную учётную запись и разместить сколько ему угодно открытых проектов. Мы быстро рассмотрим, как это делается.</p>
<p id="calibre_link-111"><span><span><b>Настройка учётной записи</b></span></span></p>
<p>Первое, что вам нужно сделать, это настроить учётную запись. Если вы посетите страницу Plans &amp; Pricing по адресу <tt>http://github.com/plans</tt> и нажмёте на кнопку "Create a free account" (см. рисунок 4-2), вы попадёте на страницу регистрации.</p>
<p><img src="images/000028.jpg"></img></p>
<p>Здесь вы должны выбрать имя пользователя, которое ещё не занято в системе, ввести адрес электронной почты, который будет сопоставлен аккаунту, и пароль (см. рис. 4-3).</p>
<p><img src="images/000036.jpg"></img></p>
<p>Если есть возможность, сейчас также самое время добавить свой открытый SSH-ключ. Мы рассмотрели, как создать ключ, ранее, в разделе "Создание открытого SSH-ключа". Возьмите содержимое открытого ключа из своей пары и вставьте в поле для ввода открытого SSH-ключа. Ссылка "explain ssh keys" направит вас к подробным инструкциям о том, как это сделать на всех основных операционных системах. Нажатие на кнопку "I agree, sign me up" откроет инструментальную панель вашего нового пользователя (см. рис. 4-4).</p>
<p><img src="images/000087.jpg"></img></p>
<p>После этого вы можете создать новый репозиторий.</p>
<p id="calibre_link-112"><span><span><b>Создание нового репозитория</b></span></span></p>
<p>Начните с нажатия на "New repository" рядом с разделом "Your Repositories" на странице инструментальной панели. Вы попадёте к форме для создания нового репозитория (см. рис. 4-5).</p>
<p><img src="images/000091.jpg"></img></p>
<p>Единственное, что вам обязательно нужно сделать, это указать имя проекта, но вы также можете добавить и описание. Когда сделаете это, нажмите на кнопку "Create Repository". Теперь у вас есть новый репозиторий на GitHub'е (см. рис. 4-6).</p>
<p><img src="images/000046.jpg"></img></p>
<p>Поскольку у вас ещё нет кода, GitHub покажет вам инструкцию, как создать совершенно новый проект, отправить существующий или импортировать проект из публичного репозитория Subversion (см. рис. 4-7).</p>
<p><img src="images/000095.jpg"></img></p>
<p>Эти инструкции похожи на то, что мы проходили раньше. Чтобы инициализировать проект, если это ещё не Git-проект, используйте:</p>
<p><tt>$&nbsp;git&nbsp;init<br></br>$&nbsp;git&nbsp;add&nbsp;.<br></br>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'initial&nbsp;commit'<br></br></tt></p>
<p>Если у вас есть локальный Git-репозиторий, добавьте GitHub как удалённый сервер и отправьте туда свою ветку master:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;origin&nbsp;git@github.com:testinguser/iphone_project.git<br></br>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master<br></br></tt></p>
<p>Теперь ваш проект размещён на GitHub'е, и вы можете дать ссылку на него любому, с кем вы захотите разделить проект. В этом случае, это <tt>http://github.com/testinguser/iphone_project</tt>. Вы также можете видеть в заголовке каждой страницы проекта, что у вас две Git-ссылки (см. рис. 4-8).</p>
<p><img src="images/000002.jpg"></img></p>
<p>Ссылка "Public Clone URL" &mdash; это публичная ссылка только для чтения, через которую кто угодно может склонировать проект. Можете опубликовать эту ссылку или разместить её на своём сайте &mdash; где угодно.</p>
<p>"Your Clone URL" &mdash; это SSH-ссылка на чтение и запись, через которую вы можете читать и писать только в том случае, если вы подключаетесь с использованием секретного ключа из пары открытого SSH-ключа, загруженного в вашу учётную запись. Если другие пользователи посетят страницу этого проекта, они не увидят этой ссылки &mdash; только публичную.</p>
<p id="calibre_link-113"><span><span><b>Импорт из Subversion</b></span></span></p>
<p>Если у вас есть существующий публичный Subversion-проект, который вы хотите импортировать в Git, GitHub часто может сделать это за вас. Внизу страницы инструкций есть ссылка на импорт из Subversion. Если вы кликнете по ней, вы увидите форму с информацией о процессе импорта и текстовое поле, где вы можете вставить ссылку на ваш публичный Subversion-проект (см. рис. 4-9).</p>
<p><img src="images/000014.jpg"></img></p>
<p>Если ваш проект очень большой, нестандартный или приватный, этот процесс, возможно, не сработает для вас. В главе 7 вы узнаете, как делать более сложные импорты вручную.</p>
<p id="calibre_link-114"><span><span><b>Добавление участников</b></span></span></p>
<p>Давайте добавим остальную команду. Если Джон, Джози и Джессика зарегистрированы на GitHub'е, и вы хотите дать им доступ на отправку изменений в свой репозиторий, вы можете добавить их в свой проект как участников. Это позволит им отправлять изменения, используя свои открытые ключи.</p>
<p>Нажмите на кнопку "edit" в заголовке проекта или вкладку "Admin" вверху, чтобы попасть на страницу администратора вашего проекта на GitHub'е (см. рис. 4-10).</p>
<p><img src="images/000029.jpg"></img></p>
<p>Чтобы дать другому пользователю доступ на запись в проект, кликните по ссылке “Add another collaborator”. Появится новое текстовое поле, в котором вы можете набрать имя пользователя. По мере набора всплывёт подсказка, показывающая возможные совпадения имён. Когда найдёте нужного пользователя, нажмите на кнопку Add, чтобы добавить пользователя как участника вашего проекта (см. рис. 4-11).</p>
<p><img src="images/000045.jpg"></img></p>
<p>Когда закончите добавлять участников, вы должны увидеть их список в разделе Repository Collaborators (см. рис. 4-12).</p>
<p><img src="images/000083.jpg"></img></p>
<p>Если вам нужно отозвать чей-то доступ, можете кликнуть по ссылке "revoke", и его доступ на отправку будет удалён. Для будущих проектов вы также можете скопировать группы участников, скопировав права доступа из существующего проекта.</p>
<p id="calibre_link-115"><span><span><b>Ваш проект</b></span></span></p>
<p>После того как вы отправили ваш проект или импортировали его из Subversion, у вас есть главная страница проекта, которая выглядит как на рис. 4-13.</p>
<p><img src="images/000093.jpg"></img></p>
<p>Когда люди посещают ваш проект, они видят эту страницу. Она содержит вкладки, касающиеся различных аспектов вашего проекта. Вкладка Commits показывает список коммитов в обратном хронологическом порядке наподобие вывода команды <tt>git log</tt>. Вкладка Network показывает всех людей, отделивших ваш проект и вернувших свои наработки. Вкладка Downloads позволяет выложить бинарные файлы проекта и ссылки на архивы каких-нибудь отмеченных точек проекта. Вкладка Wiki предоставляет вики, где вы можете написать документацию или другую информацию о своём проекте. Вкладка Graphs показывает некоторую информацию о вкладе участников и статистику проекта. Главная вкладка Source показывает листинг корневого каталога проекта и автоматически выводит под ним содержимое файла README, если он у вас есть. Эта вкладка также показывает информацию о последнем коммите.</p>
<p id="calibre_link-116"><span><span><b>Ответвления проектов</b></span></span></p>
<p>Если вы хотите внести вклад в существующий проект, на отправку изменений в который у вас нет прав, GitHub приветствует ответвления. Когда вы смотрите на страницу заинтересовавшего вас проекта и хотите немного поработать над ним, вы можете нажать на кнопку "Fork" в заголовке проекта, чтобы GitHub скопировал проект вашему пользователю, и вы смогли отправлять туда свои изменения.</p>
<p>Таким образом, проектам не нужно беспокоиться о добавлении пользователей в качестве участников для предоставления им доступа на отправку изменений. Люди могут ответвить проект и отправлять изменения в свою копию. А мейнтейнер главного проекта может вернуть эти изменения, добавляя форки как удалённые серверы и сливая из них наработки.</p>
<p>Чтобы ответвить проект, посетите страницу проекта (в нашем случае mojombo/chronic) и нажмите на кнопку "Fork" в его заголовке (см. рис. 4-14).</p>
<p><img src="images/000089.jpg"></img></p>
<p>Через несколько секунд вы будете направлены на страницу своего нового проекта, на которой указано, что данный проект является ответвлением другого проекта (см. рис. 4-15).</p>
<p><img src="images/000051.jpg"></img></p>
<p id="calibre_link-117"><span><span><b>Заключение о GitHub</b></span></span></p>
<p>Это всё, что мы хотели бы рассказать про GitHub, но важно отметить, как быстро вы можете всё сделать. Вы можете создать аккаунт, добавить новый проект и отправить изменения в него за минуты. Если ваш проект с открытым исходным кодом, вы также получите огромное сообщество разработчиков, которые смогут увидеть ваш проект, ответвить его и внести в него свой вклад. Во всяком случае, это хороший способ получить готовую к работе с Git'ом среду, чтобы быстренько испытать его в деле.</p>
<div></div><p id="calibre_link-118"><span><span><b>Итоги</b></span></span></p>
<p>У вас есть несколько вариантов получения удалённого Git-репозитория так, чтобы вы могли принимать участие в проекте вместе с другими или поделиться работой.</p>
<p>Запуск своего сервера даёт полный контроль и позволяет запускать сервер за вашим сетевым экраном, но такой сервер обычно требует значительной части вашего времени на настройку и поддержку. Если вы разместите ваши данные на хостинге, его просто настроить и поддерживать; однако вам необходимо иметь возможность хранить код на чужом сервере, а некоторые организации этого не позволяют.</p>
<p>Выбор решения или комбинации решений, которые подойдут вам и вашей организации, не должен вызвать затруднений.</p>
<div></div><p id="calibre_link-119"><span><span><b>Распределённый Git</b></span></span></p>
<p>Теперь, когда вы обзавелись настроенным удалённым Git-репозиторием, являющимся местом, где разработчики могут обмениваться своим кодом, а также познакомились с основными командами Git'а для локальной работы, мы рассмотрим, как задействовать некоторые распределённые рабочие процессы, предлагаемые Git'ом.</p>
<p>В этой главе мы рассмотрим работу с Git'ом в распределённой среде как в роли рядового разработчика, так и в роли системного интегратора. То есть вы научитесь успешно вносить свой код в проект, делая это как можно более просто и для вас, и для владельца проекта, а также научитесь тому, как сопровождать проекты, в работе над которыми участвует множество человек.</p>
<div></div><p id="calibre_link-120"><span><span><b>Распределённые рабочие процессы</b></span></span></p>
<p>В отличие от централизованных систем контроля версий, распределённая природа Git'а позволяет вам быть гораздо более гибким в отношении участия разработчиков в работе над проектами. В централизованных системах все разработчики являются узлами сети, более или менее одинаково работающими на центральном хабе. Однако, в Git'е каждый разработчик потенциально является и узлом, и хабом. То есть каждый разработчик может как вносить код в другие репозитории, так и содержать публичный репозиторий, на основе которого работают другие разработчики, и в который они вносят свои изменения. Это даёт вашей команде возможность использовать любой из множества различных способов осуществления рабочего процесса в ваших проектах, поэтому мы рассмотрим несколько распространённых подходов, пользующихся гибкостью Git'а. Мы рассмотрим сильные стороны и возможные недостатки каждого подхода; вы можете выбрать для себя один из них, а можете совместить особенности сразу нескольких подходов.</p>
<p id="calibre_link-121"><span><span><b>Централизованный рабочий процесс</b></span></span></p>
<p>В централизованных системах существует, как правило, одна модель совместной разработки &mdash; централизованный рабочий процесс. Один центральный хаб, или репозиторий, может принимать код, а все остальные синхронизируют свою работу с ним. Некоторое число разработчиков являются узлами &mdash; клиентами этого хаба &mdash; и синхронизируются с ним одним (см. рис. 5-1).</p>
<p><img src="images/000053.jpg"></img></p>
<p>Это значит, что если два разработчика выполняют клонирование с хаба и оба делают изменения в проекте, то первый из них, кто отправит свои изменения обратно на хаб, сделает это без проблем. Второй разработчик должен взять наработки первого и выполнить слияние перед тем, как отправить свои изменения, так чтобы не перезаписать изменения первого разработчика. Этот принцип справедлив для Git'а точно так же, как и для Subversion (или любой другой ЦСКВ), и в Git'е такая модель работает отлично.</p>
<p>Если у вас небольшая команда или вас полностью устраивает рабочий процесс централизованного типа, применяемый в вашей компании, вы можете просто продолжить использовать такой рабочий процесс и в Git'е. Просто настройте один репозиторий и дайте каждому в вашей команде права на отправку изменений; Git не позволит пользователям перезаписывать наработки друг друга. Если какой-то разработчик склонирует репозиторий, сделает в нём изменения, а затем попытается выложить эти изменения, в то время как другой разработчик уже успел отправить свои, сервер отклонит изменения этого разработчика. Ему будет сказано, что он пытается выложить изменения, для которых невозможно выполнить перемотку (fast-forward), и что надо сначала извлечь данные с сервера, выполнить слияние, а уже потом отправлять свои изменения. Такой рабочий процесс привлекателен для большого количества людей, так как это та модель, с которой многие знакомы и которая многим понятна.</p>
<p id="calibre_link-122"><span><span><b>Рабочий процесс с менеджером по интеграции</b></span></span></p>
<p>Так как Git позволяет иметь несколько удалённых репозиториев, существует возможность ведения такого рабочего процесса, при котором каждый разработчик имеет права на запись в свой собственный публичный репозиторий и права на чтение для всех остальных. Этот сценарий часто подразумевает существование канонического репозитория, который представляет собой "официальный" проект. Чтобы принять участие в работе над этим проектом, надо создать свою собственную публичную копию проекта и выложить туда свои изменения. Потом вы можете отправить запрос владельцу основного проекта на внесение в него ваших изменений. Он может добавить ваш репозиторий в качестве удалённого, протестировать локально ваши изменения, слить их со своей веткой и затем отправить обратно в публичный репозиторий. Этот процесс осуществляется следующим образом (см. рис. 5-2):</p>
<div>&nbsp;</div><ol><li value="1">Владелец проекта выкладывает файлы в публичный репозиторий.</li><li value="2">Участники проекта клонируют этот репозиторий и делают изменения.</li><li value="3">Участники выкладывают изменения в свои собственные публичные репозитории.</li><li value="4">Участник проекта отправляет владельцу письмо с просьбой включения его изменений.</li><li value="5">Владелец проекта добавляет репозиторий участника как удалённый и локально выполняет слияние.</li><li value="6">Владелец отправляет слитые изменения в основной репозиторий.</li></ol><p><img src="images/000061.jpg"></img></p>
<p>Это очень распространённый тип рабочего процесса для сайтов вроде GitHub, где можно легко форкнуть проект и выложить свои изменения на всеобщее обозрение в собственную копию. Одно из главных преимуществ такого подхода &mdash; возможность продолжать работать, в то время как владелец основного репозитория может включить себе ваши изменения, когда ему угодно. Участникам проекта не придётся ждать включения своих изменений в проект &mdash; каждый может работать в своём собственном ритме.</p>
<p id="calibre_link-123"><span><span><b>Рабочий процесс с диктатором и его помощниками</b></span></span></p>
<p>Это одна из разновидностей рабочего процесса с множеством репозиториев. В основном он используется в огромных проектах с сотнями участников; ядро Linux &mdash; яркий тому пример. Несколько менеджеров по интеграции заведуют разными частями репозитория; этих людей называют помощниками. У всех этих помощников есть только один менеджер по интеграции, которого называют благосклонным диктатором. Репозиторий благосклонного диктатора служит эталонным репозиторием, откуда все участники проекта должны брать изменения. Этот процесс происходит так (см. рис. 5-3):</p>
<div>&nbsp;</div><ol><li value="1">Обычные разработчики работают над своими тематическими ветками и перемещают свою работу на вершину ветки master. Ветка master &mdash; это та ветка, которая находится у диктатора.</li><li value="2">Помощники сливают тематические ветки разработчиков в свои ветки master.</li><li value="3">Диктатор выполняет слияние веток master своих помощников со своей веткой master.</li><li value="4">Диктатор отправляет свою ветку master в эталонный репозиторий, чтобы остальные разработчики могли выполнять перемещение на неё.</li></ol><p><img src="images/000069.jpg"></img></p>
<p>Этот тип рабочего процесса не является распространённым, но он может быть полезен в очень больших проектах или в сильно иерархическом окружении, так как он позволяет лидеру проекта (диктатору) передать другим полномочия по выполнению большой части работ и собирать код большими порциями с нескольких мест перед его интеграцией.</p>
<p>Мы рассмотрели несколько широко используемых типов рабочих процессов, доступных при работе с распределёнными системами вроде Git'а, но, как видите, возможны различные вариации для подгонки под ваш конкретный тип рабочего процесса. Теперь, когда вы в состоянии определить, какая комбинация рабочих процессов сработает для вас лучше, мы рассмотрим несколько более специфичных примеров действий, выполняемых основными ролями участников различных процессов.</p>
<div></div><p id="calibre_link-124"><span><span><b>Содействие проекту</b></span></span></p>
<p>Мы узнали, что представляют собой различные рабочие процессы, также у вас должно быть достаточно хорошее понимание основ использования Git'а. В этом разделе вы узнаете о нескольких типичных способах внести свой вклад в проект.</p>
<p>Главная трудность в описании этого процесса состоит в том, что существует огромное количество вариаций того, как он организован. Так как Git очень гибок, люди могут осуществлять совместную работу по-разному, и проблематично описать то, как вы должны содействовать проекту &mdash; все проекты немного разные. Многое зависит от количества активных участников, от выбранного типа рабочего процесса, от ваших прав доступа к репозиториям, и, возможно, от метода принятия изменений от внешних разработчиков.</p>
<p>Первый фактор &mdash; это количество активных участников. Как много пользователей активно вносят свой вклад в проект и как часто? Во многих случаях это два-три разработчика с несколькими коммитами в день, возможно, меньше, для вялотекущих проектов. В по-настоящему больших компаниях или проектах число разработчиков может измеряться тысячами, с десятками или даже сотнями ежедневно поступающих патчей. Это важно, поскольку с увеличением числа разработчиков вам становится труднее убедиться, что ваши изменения можно будет чисто применить или беспрепятственно слить. Изменения, которые вы отправляете, могут оказаться устаревшими или частично сломанными той работой, которая была влита, пока вы работали, или пока ваши изменения ожидали утверждения или применения. Как сохранить свой код согласованным, а патчи применимыми?</p>
<p>Следующий фактор &mdash; это рабочий процесс, используемый в проекте. Он централизован, и каждый разработчик имеет равные права на запись в главный репозиторий? Есть у проекта мейнтейнер или менеджер по интеграции, который проверяет патчи? Все ли патчи проверяются и утверждаются экспертами? Вы вовлечены в этот процесс? Присутствует ли система помощников и должны ли вы сначала отправлять свою работу им?</p>
<p>Следующий пункт &mdash; это доступ на отправку изменений. Рабочий процесс, требуемый для внесения вклада в проект, сильно отличается в зависимости от того, имеете ли вы доступ на запись или нет. Если у вас нет доступа на запись, то как в проекте принято принимать вклад в работу? Вообще, существует ли какая-либо политика? Какой объём работы вы вносите за раз? Как часто вы это делаете?</p>
<p>Все эти вопросы могут повлиять на то, как эффективно вы будете вносить вклад в проект и какой рабочий процесс предпочтителен или доступен вам. Я расскажу об аспектах каждого из них на серии примеров, продвигаясь от простых к более сложным; на основе этих примеров вы сможете создать специфический нужный вам в вашей работе тип рабочего процесса.</p>
<p id="calibre_link-125"><span><span><b>Рекомендации по созданию коммитов</b></span></span></p>
<p>Прежде чем мы приступим к рассмотрению специфичных примеров использования, сделаем короткое замечание о сообщениях коммитов. Обладание хорошим руководством по созданию коммитов и следование ему значительно облегчает работу с Git'ом и сотрудничество с другими разработчиками. У проекта Git имеется документ с хорошими советами по созданию коммитов, из которых делаются патчи &mdash; прочитать его можно в исходном коде Git'а в файле <tt>Documentation/SubmittingPatches</tt>.</p>
<p>Во-первых, не стоит отсылать ничего с ошибками в пробельных символах. Git предоставляет простой способ их обнаружения &mdash; перед коммитом, запустите <tt>git diff --check</tt>, это определит возможные проблемы и перечислит их вам. Вот пример, в котором я заменил красный цвет терминала символами <tt>X</tt>:</p>
<p><tt>$&nbsp;git&nbsp;diff&nbsp;--check<br></br>lib/simplegit.rb:5:&nbsp;trailing&nbsp;whitespace.<br></br>+&nbsp;&nbsp;&nbsp;&nbsp;@git_dir&nbsp;=&nbsp;File.expand_path(git_dir)XX<br></br>lib/simplegit.rb:7:&nbsp;trailing&nbsp;whitespace.<br></br>+&nbsp;XXXXXXXXXXX<br></br>lib/simplegit.rb:26:&nbsp;trailing&nbsp;whitespace.<br></br>+&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;command(git_cmd)XXXX<br></br></tt></p>
<p>Если выполните эту команду перед коммитом, то сможете понять, собираетесь ли вы сделать коммит с раздражающими разработчиков ошибками в пробельных символах.</p>
<p>Далее, старайтесь делать так, чтобы каждый коммит был логически отдельным набором изменений. Если можете, старайтесь делать ваши изменения обозримыми &mdash; не стоит писать код все выходные, работая над пятью задачами, а затем отправлять их все в понедельник одним массивным коммитом. Даже если вы не делали коммитов в течение выходных, воспользуйтесь индексом, чтобы разбить свою работу на части, как минимум по одному коммиту для каждой проблемы с полезным сообщением к каждому. Если некоторые из изменений затрагивают один и тот же файл, попробуйте использовать <tt>git add --patch</tt> для индексирования файла по частям (это подробно рассмотрено в главе 6). Снимок состояния проекта на верхушке ветки будет идентичным, сделаете ли вы один коммит или пять, покуда все ваши изменения добавлены в какой-то момент, так что попытайтесь облегчить жизнь вашим коллегам разработчикам, когда они будут просматривать ваши изменения. При таком подходе будет проще выделить или отменить одно из изменений, если возникнет такая необходимость. В главе 6 описано множество полезных ухищрений для переписывания истории и интерактивного индексирования файлов &mdash; пользуйтесь этими инструментами для изготовления ясной и понятной истории.</p>
<p>Последняя вещь, которую стоит иметь в виду, &mdash; это сообщение коммита. Написание качественных сообщений коммитов должно войти в привычку, это сделает сотрудничество с использованием Git'а гораздо проще. По общему правилу, ваши сообщения должны начинаться с одной строки не длиннее 50 символов, лаконично описывающей набор изменений, затем пустая строка, затем более детальное описание. Проект Git требует, чтобы детальное объяснение включало в себя мотивацию на изменения и противопоставляло вашу реализацию с предыдущим поведением &mdash; это хорошее руководство к действию. Если вы пишете сообщения к коммитам на английском языке, то хорошей идеей является использование повелительного наклонения глаголов в настоящем времени. Другими словами, пишите команды. Вместо "I added tests for" или "Adding tests for" используйте "Add tests for".</p>
<p>Вот шаблон, изначально написанный Тимом Поупом на сайте tpope.net:</p>
<p><tt>Краткое&nbsp;(до&nbsp;50&nbsp;символов)&nbsp;описание&nbsp;изменений<br></br><br></br>Более&nbsp;детальное&nbsp;объяснение,&nbsp;если&nbsp;необходимо.&nbsp;Перенос&nbsp;на&nbsp;72&nbsp;символе<br></br>или&nbsp;около&nbsp;того.&nbsp;В&nbsp;некоторых&nbsp;контекстах&nbsp;первая&nbsp;строка&nbsp;рассматривается<br></br>как&nbsp;тема&nbsp;письма,&nbsp;а&nbsp;остальное&nbsp;как&nbsp;тело.&nbsp;Пустая&nbsp;строка,&nbsp;отделяющая&nbsp;сводку<br></br>от&nbsp;тела,&nbsp;важна&nbsp;(если&nbsp;вы&nbsp;не&nbsp;опустили&nbsp;тело&nbsp;целиком);&nbsp;если&nbsp;вы&nbsp;оставите&nbsp;их<br></br>вместе,&nbsp;инструменты,&nbsp;такие&nbsp;как&nbsp;rebase,&nbsp;могут&nbsp;воспринять&nbsp;это&nbsp;неправильно.<br></br><br></br>Дальнейшие&nbsp;параграфы&nbsp;идут&nbsp;после&nbsp;пустых&nbsp;строк<br></br><br></br>&nbsp;-&nbsp;также&nbsp;можно&nbsp;применять&nbsp;маркеры&nbsp;списков<br></br><br></br>&nbsp;-&nbsp;обычно&nbsp;в&nbsp;качестве&nbsp;маркера&nbsp;списка&nbsp;используется&nbsp;дефис&nbsp;или&nbsp;звёздочка<br></br>&nbsp;&nbsp;&nbsp;с&nbsp;одним&nbsp;пробелом&nbsp;перед&nbsp;ним&nbsp;и&nbsp;пустыми&nbsp;строками&nbsp;между&nbsp;пунктами,<br></br>&nbsp;&nbsp;&nbsp;хотя&nbsp;соглашения&nbsp;в&nbsp;этом&nbsp;аспекте&nbsp;могут&nbsp;разниться<br></br></tt></p>
<p>Если все ваши сообщения о коммитах будут выглядеть как это, всё будет намного проще для вас и для разработчиков, с которыми вы работаете. Проект Git содержит хорошо отформатированные сообщения о коммитах &mdash; я советую вам запустить <tt>git log --no-merges</tt> там, чтобы увидеть, как выглядит хорошо отформатированная история коммитов проекта.</p>
<p>В последующих примерах и почти везде в этой книге для краткости я не форматирую сообщения так красиво, как это; вместо этого я использую опцию <tt>-m</tt> для команды <tt>git commit</tt>. Делайте, как я говорю, а не как я делаю.</p>
<p id="calibre_link-126"><span><span><b>Отдельная маленькая команда</b></span></span></p>
<p>Наиболее простой тип организации, с которой вы легко можете столкнуться &mdash; частный проект с одним или двумя другими разработчиками. Под термином частный я подразумеваю закрытый код, недоступный для чтения остальному миру. Вы и все остальные разработчики имеете право записи в репозиторий.</p>
<p>В этой среде вы можете придерживаться рабочего процесса, похожего на тот, который вы бы использовали в Subversion или другой централизованной системе. Вы по-прежнему получите такие преимущества, как локальные коммиты (коммиты в offline) и возможность гораздо более простого ветвления и слияния, но сам рабочий процесс может оставаться очень похожим; главное отличие &mdash; во время выполнения коммита слияние происходит на стороне клиента, а не на сервере. Давайте посмотрим, как выглядел бы процесс, когда два разработчика начинают работать вместе с общим репозиторием. Первый разработчик, Джон, клонирует репозиторий, делает изменения и создаёт локальный коммит. (Я заменяю служебные сообщения знаком <tt>...</tt> в этих примерах, чтобы немного их сократить.)</p>
<p><tt>#&nbsp;Машина&nbsp;Джона<br></br>$&nbsp;git&nbsp;clone&nbsp;john@githost:simplegit.git<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/home/john/simplegit/.git/<br></br>...<br></br>$&nbsp;cd&nbsp;simplegit/<br></br>$&nbsp;vim&nbsp;lib/simplegit.rb<br></br>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'removed&nbsp;invalid&nbsp;default&nbsp;value'<br></br>[master&nbsp;738ee87]&nbsp;removed&nbsp;invalid&nbsp;default&nbsp;value<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br></tt></p>
<p>Второй разработчик, Джессика, выполняет то же самое &mdash; клонирует репозиторий и делает коммит с изменениями:</p>
<p><tt>#&nbsp;Машина&nbsp;Джессики<br></br>$&nbsp;git&nbsp;clone&nbsp;jessica@githost:simplegit.git<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/home/jessica/simplegit/.git/<br></br>...<br></br>$&nbsp;cd&nbsp;simplegit/<br></br>$&nbsp;vim&nbsp;TODO<br></br>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'add&nbsp;reset&nbsp;task'<br></br>[master&nbsp;fbff5bc]&nbsp;add&nbsp;reset&nbsp;task<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p>Теперь Джессика отправляет свою работу на сервер:</p>
<p><tt>#&nbsp;Машина&nbsp;Джессики<br></br>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master<br></br>...<br></br>To&nbsp;jessica@githost:simplegit.git<br></br>&nbsp;&nbsp;&nbsp;1edee6b..fbff5bc&nbsp;&nbsp;master&nbsp;-&gt;&nbsp;master<br></br></tt></p>
<p>Джон также пытается выложить свои изменения:</p>
<p><tt>#&nbsp;Машина&nbsp;Джона<br></br>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master<br></br>To&nbsp;john@githost:simplegit.git<br></br>&nbsp;!&nbsp;[rejected]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;-&gt;&nbsp;master&nbsp;(non-fast&nbsp;forward)<br></br>error:&nbsp;failed&nbsp;to&nbsp;push&nbsp;some&nbsp;refs&nbsp;to&nbsp;'john@githost:simplegit.git'<br></br></tt></p>
<p>Джон не может выполнить отправку изменений, так как за это время Джессика уже отправила свои. Это очень важно понять, особенно если вы привыкли к Subversion, так как мы видим, что эти два разработчика не редактировали один и тот же файл. Хотя Subversion и выполняет автоматическое слияние на сервере, если редактировались разные файлы, при использовании Git'а вы должны слить коммиты локально. Прежде чем Джон сможет отправить свои изменения на сервер, он должен извлечь наработки Джессики и выполнить слияние:</p>
<p><tt>$&nbsp;git&nbsp;fetch&nbsp;origin<br></br>...<br></br>From&nbsp;john@githost:simplegit<br></br>&nbsp;+&nbsp;049d078...fbff5bc&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;origin/master<br></br></tt></p>
<p>На этот момент, локальный репозиторий Джона выглядит так, как показано на рисунке 5-4.</p>
<p><img src="images/000079.jpg"></img></p>
<p>У Джона есть ссылка на изменения, выложенные Джессикой, и он должен слить их со своей работой перед тем, как ему разрешат её отправить:</p>
<p><tt>$&nbsp;git&nbsp;merge&nbsp;origin/master<br></br>Merge&nbsp;made&nbsp;by&nbsp;recursive.<br></br>&nbsp;TODO&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p>Слияние прошло без проблем &mdash; история коммитов Джона теперь выглядит как на рисунке 5-5.</p>
<p><img src="images/000081.jpg"></img></p>
<p>Теперь Джон может протестировать свой код, дабы удостовериться, что он по-прежнему работает нормально, а затем выложить свою работу, уже объединённую с работой Джессики, на сервер:</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master<br></br>...<br></br>To&nbsp;john@githost:simplegit.git<br></br>&nbsp;&nbsp;&nbsp;fbff5bc..72bbc59&nbsp;&nbsp;master&nbsp;-&gt;&nbsp;master<br></br></tt></p>
<p>В результате история коммитов Джона выглядит, как показано на рисунке 5-6.</p>
<p><img src="images/000086.jpg"></img></p>
<p>Тем временем, Джессика работала над тематической веткой. Она создала тематическую ветку с названием <tt>issue54</tt> и сделала три коммита в этой ветке. Она ещё не извлекала изменения Джона, так что её история коммитов выглядит, как показано на рисунке 5-7.</p>
<p><img src="images/000049.jpg"></img></p>
<p>Джессика хочет синхронизировать свою работу с Джоном, так что она извлекает изменения с сервера:</p>
<p><tt>#&nbsp;Машина&nbsp;Джессики<br></br>$&nbsp;git&nbsp;fetch&nbsp;origin<br></br>...<br></br>From&nbsp;jessica@githost:simplegit<br></br>&nbsp;&nbsp;&nbsp;fbff5bc..72bbc59&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;origin/master<br></br></tt></p>
<p>Эта команда извлекает наработки Джона, которые он успел выложить. История коммитов Джессики теперь выглядит как на рисунке 5-8.</p>
<p><img src="images/000077.jpg"></img></p>
<p>Джессика полагает, что её тематическая ветка закончена, но она хочет узнать, с чем ей нужно слить свою работу, чтобы она могла выложить её на сервер. Она запускает <tt>git log</tt>, чтобы выяснить это:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--no-merges&nbsp;origin/master&nbsp;^issue54<br></br>commit&nbsp;738ee872852dfaa9d6634e0dea7a324040193016<br></br>Author:&nbsp;John&nbsp;Smith&nbsp;&lt;jsmith@example.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;May&nbsp;29&nbsp;16:01:27&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;invalid&nbsp;default&nbsp;value<br></br></tt></p>
<p>Теперь Джессика может слить свою тематическую ветку в ветку <tt>master</tt>, слить работу Джона (<tt>origin/master</tt>) в свою ветку <tt>master</tt> и затем отправить изменения на сервер. Сначала она переключается на свою основную ветку, чтобы объединить всю эту работу:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>Switched&nbsp;to&nbsp;branch&nbsp;"master"<br></br>Your&nbsp;branch&nbsp;is&nbsp;behind&nbsp;'origin/master'&nbsp;by&nbsp;2&nbsp;commits,&nbsp;and&nbsp;can&nbsp;be&nbsp;fast-forwarded.<br></br></tt></p>
<p>Она может слить сначала ветку <tt>origin/master</tt>, а может и <tt>issue54</tt> &mdash; обе они находятся выше в истории коммитов, так что не важно какой порядок слияния она выберет. Конечное состояние репозитория должно получиться идентичным независимо от того, какой порядок слияния она выберет; только история коммитов будет немного разная. Она решает слить ветку <tt>issue54</tt> первой:</p>
<p><tt>$&nbsp;git&nbsp;merge&nbsp;issue54<br></br>Updating&nbsp;fbff5bc..4af4298<br></br>Fast&nbsp;forward<br></br>&nbsp;README&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+<br></br>&nbsp;lib/simplegit.rb&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;+++++-<br></br>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;6&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br></tt></p>
<p>Никаких проблем не возникло; как видите, это была обычная перемотка. Теперь Джессика сливает работу Джона (<tt>origin/master</tt>):</p>
<p><tt>$&nbsp;git&nbsp;merge&nbsp;origin/master<br></br>Auto-merging&nbsp;lib/simplegit.rb<br></br>Merge&nbsp;made&nbsp;by&nbsp;recursive.<br></br>&nbsp;lib/simplegit.rb&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;+-<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br></tt></p>
<p>Слияние проходит нормально, и теперь история коммитов Джессики выглядит так, как показано на рисунке 5-9.</p>
<p><img src="images/000092.jpg"></img></p>
<p>Теперь указатель <tt>origin/master</tt> доступен из ветки <tt>master</tt> Джессики, так что она может спокойно выполнить <tt>git push</tt> (полагая, что Джон не выкладывал свои изменения за это время):</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master<br></br>...<br></br>To&nbsp;jessica@githost:simplegit.git<br></br>&nbsp;&nbsp;&nbsp;72bbc59..8059c15&nbsp;&nbsp;master&nbsp;-&gt;&nbsp;master<br></br></tt></p>
<p>Каждый разработчик несколько раз выполнял коммиты и успешно сливал свою работу с работой другого; смотри рисунок 5-10.</p>
<p><img src="images/000001.jpg"></img></p>
<p>Это один из простейших рабочих процессов. Вы работаете некоторое время, преимущественно в тематической ветке, и, когда приходит время, сливаете её в свою ветку <tt>master</tt>. Когда вы готовы поделиться этой работой с другими, вы сливаете её в ветку <tt>master</tt>, извлекаете изменения с сервера и сливаете <tt>origin/master</tt> (если за это время произошли изменения), и, наконец, отправляете свои изменения в ветку <tt>master</tt> на сервер. Общая последовательность действий выглядит так, как показано на рисунке 5-11.</p>
<p><img src="images/000009.jpg"></img></p>
<p id="calibre_link-127"><span><span><b>Отдельная команда с менеджером</b></span></span></p>
<p>В этом сценарии мы рассмотрим роли участников проекта в закрытых группах большего размера. Вы научитесь работе в окружении, где маленькие группы совместно работают над задачами, а затем результаты их деятельности интегрируются отдельным субъектом.</p>
<p>Давайте представим, что Джон и Джессика работают вместе над одной задачей, в то время как Джессика с Джози работают над другой. В этом случае компания использует рабочий процесс с менеджером по интеграции, при котором работа частных групп объединяется только определёнными инженерами (обновление ветки <tt>master</tt> главного репозитория может осуществляться только этими инженерами). В этом случае вся работа выполняется в ветках отдельных команд разработчиков и впоследствии объединяется воедино менеджерами по интеграции.</p>
<p>Давайте проследим за рабочим процессом Джессики, которая работает над двумя задачами, сотрудничая одновременно с двумя разными разработчиками. Положим, что она уже имеет свою собственную копию репозитория. Джессика решает сначала взяться за задачу <tt>featureA</tt>. Для этого она создаёт новую ветку и выполняет в ней некоторую работу:</p>
<p><tt>#&nbsp;Машина&nbsp;Джессики<br></br>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;featureA<br></br>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;"featureA"<br></br>$&nbsp;vim&nbsp;lib/simplegit.rb<br></br>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'add&nbsp;limit&nbsp;to&nbsp;log&nbsp;function'<br></br>[featureA&nbsp;3300904]&nbsp;add&nbsp;limit&nbsp;to&nbsp;log&nbsp;function<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br></tt></p>
<p>На этом этапе ей требуется поделиться своей работой с Джоном, так что она отправляет коммиты, выполненные на ветке <tt>featureA</tt>, на сервер. Так как Джессика не имеет права на изменение ветки <tt>master</tt> на сервере &mdash; только менеджеры по интеграции могут делать это &mdash; она вынуждена отправлять свои изменения в другую ветку, чтобы обмениваться работой с Джоном:</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;featureA<br></br>...<br></br>To&nbsp;jessica@githost:simplegit.git<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;featureA&nbsp;-&gt;&nbsp;featureA<br></br></tt></p>
<p>Джессика сообщает по электронной почте Джону, что она выложила некоторые наработки в ветку <tt>featureA</tt>, и что он может проверить их. Пока Джессика ждёт ответа от Джона, она решает начать работу над веткой <tt>featureB</tt> вместе с Джози. Для начала она создаёт новую ветку для этой задачи, используя в качестве основы ветку <tt>master</tt> на сервере:</p>
<p><tt>#&nbsp;Машина&nbsp;Джессики<br></br>$&nbsp;git&nbsp;fetch&nbsp;origin<br></br>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;featureB&nbsp;origin/master<br></br>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;"featureB"<br></br></tt></p>
<p>Теперь Джессика делает пару коммитов в ветке <tt>featureB</tt>:</p>
<p><tt>$&nbsp;vim&nbsp;lib/simplegit.rb<br></br>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'made&nbsp;the&nbsp;ls-tree&nbsp;function&nbsp;recursive'<br></br>[featureB&nbsp;e5b0fdc]&nbsp;made&nbsp;the&nbsp;ls-tree&nbsp;function&nbsp;recursive<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br>$&nbsp;vim&nbsp;lib/simplegit.rb<br></br>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'add&nbsp;ls-files'<br></br>[featureB&nbsp;8512791]&nbsp;add&nbsp;ls-files<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;5&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p>Репозиторий Джессики выглядит, как показано на рисунке 5-12.</p>
<p><img src="images/000012.jpg"></img></p>
<p>Джессика уже готова отправить свою работу на сервер, но получает от Джози сообщение о том, что некоторые наработки уже были выложены на сервер в ветку <tt>featureBee</tt>. Поэтому Джессика должна сначала слить эти изменения со своими, прежде чем она сможет отправить свою работу на сервер. Она может извлечь изменения Джози командой <tt>git fetch</tt>:</p>
<p><tt>$&nbsp;git&nbsp;fetch&nbsp;origin<br></br>...<br></br>From&nbsp;jessica@githost:simplegit<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;featureBee&nbsp;-&gt;&nbsp;origin/featureBee<br></br></tt></p>
<p>Теперь Джессика может слить эти изменения в свои наработки командой <tt>git merge</tt>:</p>
<p><tt>$&nbsp;git&nbsp;merge&nbsp;origin/featureBee<br></br>Auto-merging&nbsp;lib/simplegit.rb<br></br>Merge&nbsp;made&nbsp;by&nbsp;recursive.<br></br>&nbsp;lib/simplegit.rb&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;++++<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;4&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p>Есть небольшая проблема &mdash; ей нужно выложить изменения из своей ветки <tt>featureB</tt> в ветку <tt>featureBee</tt> на сервере. Она может сделать это при помощи команды <tt>git push</tt>, указав название локальной и удалённой ветки, разделённые двоеточием:</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;featureB:featureBee<br></br>...<br></br>To&nbsp;jessica@githost:simplegit.git<br></br>&nbsp;&nbsp;&nbsp;fba9af8..cd685d1&nbsp;&nbsp;featureB&nbsp;-&gt;&nbsp;featureBee<br></br></tt></p>
<p>Это называется <span><i>refspec</i></span>. Смотри главу 9, где более детально обсуждаются спецификации ссылок и различные вещи, которые вы можете делать с ними.</p>
<p>Далее, Джон сообщает Джессике по почте, что он добавил некоторые изменения в ветку <tt>featureA</tt> и просит её проверить их. Она выполняет <tt>git fetch</tt>, чтобы получить внесённые Джоном изменения:</p>
<p><tt>$&nbsp;git&nbsp;fetch&nbsp;origin<br></br>...<br></br>From&nbsp;jessica@githost:simplegit<br></br>&nbsp;&nbsp;&nbsp;3300904..aad881d&nbsp;&nbsp;featureA&nbsp;&nbsp;&nbsp;-&gt;&nbsp;origin/featureA<br></br></tt></p>
<p>Затем, используя команду <tt>git log</tt>, она смотрит, что же было изменено:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;origin/featureA&nbsp;^featureA<br></br>commit&nbsp;aad881d154acdaeb2b6b18ea0e827ed8a6d671e6<br></br>Author:&nbsp;John&nbsp;Smith&nbsp;&lt;jsmith@example.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;May&nbsp;29&nbsp;19:57:33&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;changed&nbsp;log&nbsp;output&nbsp;to&nbsp;30&nbsp;from&nbsp;25<br></br></tt></p>
<p>Наконец, она сливает работу Джона в свою собственную ветку <tt>featureA</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;featureA<br></br>Switched&nbsp;to&nbsp;branch&nbsp;"featureA"<br></br>$&nbsp;git&nbsp;merge&nbsp;origin/featureA<br></br>Updating&nbsp;3300904..aad881d<br></br>Fast&nbsp;forward<br></br>&nbsp;lib/simplegit.rb&nbsp;|&nbsp;&nbsp;&nbsp;10&nbsp;+++++++++-<br></br>1&nbsp;files&nbsp;changed,&nbsp;9&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br></tt></p>
<p>Джессика хочет кое-что подправить, так что она опять делает коммит и затем отправляет изменения на сервер:</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'small&nbsp;tweak'<br></br>[featureA&nbsp;774b3ed]&nbsp;small&nbsp;tweak<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;featureA<br></br>...<br></br>To&nbsp;jessica@githost:simplegit.git<br></br>&nbsp;&nbsp;&nbsp;3300904..774b3ed&nbsp;&nbsp;featureA&nbsp;-&gt;&nbsp;featureA<br></br></tt></p>
<p>История коммитов Джессики теперь выглядит так, как показано на рисунке 5-13.</p>
<p><img src="images/000018.jpg"></img></p>
<p>Джессика, Джози и Джон информируют менеджеров по интеграции, что ветки <tt>featureA</tt> и <tt>featureBee</tt> на сервере готовы к интеграции в основную ветку разработки. После того, как они интегрируют эти ветки в основную версию, извлечение данных с сервера приведёт к появлению новых коммитов слияния. Таким образом, история коммитов станет выглядеть так, как на рисунке 5-14.</p>
<p><img src="images/000010.jpg"></img></p>
<p>Множество групп переходят на Git именно из-за возможности параллельной работы нескольких команд с последующим объединением разных линий разработки. Огромное преимущество Git'а &mdash; возможность маленьких подгрупп большой команды работать вместе через удалённые ветки, не мешая при этом всей команде. Последовательность событий в рассмотренном здесь рабочем процессе представлена на рисунке 5-15.</p>
<p><img src="images/000096.jpg"></img></p>
<p id="calibre_link-128"><span><span><b>Небольшой открытый проект</b></span></span></p>
<p>Внести вклад в открытый проект &mdash; это немного другое. Из-за того, что у вас нет прав на прямое изменение веток проекта, требуется какой-нибудь другой путь для обмена наработками с мейнтейнерами. Первый пример описывает участие в проекте через разветвление (fork) на Git-хостингах, на которых это делается достаточно просто. Сайты repo.or.cz и GitHub оба поддерживают такую возможность, и большая часть мейнтейнеров проектов придерживаются такого способа сотрудничества. В следующем разделе рассматриваются проекты, которые предпочитают принимать патчи по e-mail.</p>
<p>Сначала вы скорее всего захотите склонировать основной репозиторий, создать тематическую ветку для одного или нескольких патчей, которые вы собираетесь внести в проект, и выполнить свою работу в ней. Последовательность действий выглядит следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;(url)<br></br>$&nbsp;cd&nbsp;project<br></br>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;featureA<br></br>$&nbsp;(выполнение&nbsp;работы)<br></br>$&nbsp;git&nbsp;commit<br></br>$&nbsp;(выполнение&nbsp;работы)<br></br>$&nbsp;git&nbsp;commit<br></br></tt></p>
<p>Возможно, у вас возникнет желание воспользоваться <tt>rebase -i</tt>, чтобы сплющить (squash) свои наработки в единый коммит, или реорганизовать наработки в коммитах таким образом, чтобы их было проще воспринимать мейнтейнерам проекта &mdash; об интерактивном перемещении будет рассказано в главе 6.</p>
<p>Если вы закончили работу со своей веткой и готовы поделиться наработками с мейнтейнерами, перейдите на страницу исходного проекта и нажмите кнопку "Fork", создав таким образом свою собственную копию проекта, доступную на запись. Затем вам нужно добавить URL этого нового репозитория в список удалённых репозиториев, в нашем случае мы назовём его <tt>myfork</tt>:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;myfork&nbsp;(url)<br></br></tt></p>
<p>Вам нужно отправить свои наработки в этот репозиторий. Проще всего будет отправить в удалённый репозиторий ту ветку, над которой вы работаете, а не сливать её в ветку <tt>master</tt> и отправлять потом её. Это объясняется следующим образом &mdash; если ваша работа не будет принята или будет принята только частично, вам не придётся откатывать назад свою ветку <tt>master</tt>. Если мейнтейнеры сольют, переместят или частично включат вашу работу, вы, в конечном счёте, получите её обратно при получении изменений из их репозитория:</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;myfork&nbsp;featureA<br></br></tt></p>
<p>Когда ваши наработки будут отправлены в ваш форк, вам нужно будет послать уведомление мейнтейнеру. Его часто называют запросом на включение (pull request), вы можете либо сгенерировать его через сайт &mdash; на GitHub'е есть кнопка "pull request", автоматически уведомляющая мейнтейнера, либо выполнить команду <tt>git request-pull</tt> и вручную отправить её вывод по почте мейнтейнеру.</p>
<p>Команда <tt>request-pull</tt> принимает в качестве аргумента имя базовой ветки, в которую вы хотите включить свою работу, и URL репозитория, из которого мейнтейнер может получить ваши наработки. Команда выводит короткую сводку всех изменений, которые вы просите включить в проект. Например, если Джессика хочет послать Джону запрос на включение, когда она сделала пару коммитов в тематической ветке и уже отправила её на сервер, ей следует выполнить следующее:</p>
<p><tt>$&nbsp;git&nbsp;request-pull&nbsp;origin/master&nbsp;myfork<br></br>The&nbsp;following&nbsp;changes&nbsp;since&nbsp;commit&nbsp;1edee6b1d61823a2de3b09c160d7080b8d1b3a40:<br></br>&nbsp;&nbsp;John&nbsp;Smith&nbsp;(1):<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;added&nbsp;a&nbsp;new&nbsp;function<br></br><br></br>are&nbsp;available&nbsp;in&nbsp;the&nbsp;git&nbsp;repository&nbsp;at:<br></br><br></br>&nbsp;&nbsp;git://githost/simplegit.git&nbsp;featureA<br></br><br></br>Jessica&nbsp;Smith&nbsp;(2):<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;limit&nbsp;to&nbsp;log&nbsp;function<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change&nbsp;log&nbsp;output&nbsp;to&nbsp;30&nbsp;from&nbsp;25<br></br><br></br>&nbsp;lib/simplegit.rb&nbsp;|&nbsp;&nbsp;&nbsp;10&nbsp;+++++++++-<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;9&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br></tt></p>
<p>Вывод может быть отправлен мейнтейнеру &mdash; он содержит список коммитов, информацию о том, где начинается ветка с изменениями, и указывает, откуда можно забрать эти изменения.</p>
<p>Для проекта, мейнтейнером которого вы не являетесь, проще иметь ветку <tt>master</tt>, которая отслеживает ветку <tt>origin/master</tt>, и выполнять работу в тематических ветках, которые вы легко сможете удалить, в случае если они будут отклонены. Если вы распределяете свои наработки по различным темам в тематических ветках, вам будет проще выполнить перемещение своей работы, в случае если верхушка главного репозитория переместится за время работы и ваши коммиты уже не получится применить без конфликтов. Например, если вы планируете отправить в проект работу по другой теме, не продолжайте работать внутри тематической ветки, которую вы только что отправили, начните снова с ветки <tt>master</tt> главного репозитория:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;featureB&nbsp;origin/master<br></br>$&nbsp;(выполнение&nbsp;работы)<br></br>$&nbsp;git&nbsp;commit<br></br>$&nbsp;git&nbsp;push&nbsp;myfork&nbsp;featureB<br></br>$&nbsp;(отправка&nbsp;письма&nbsp;мейнтейнеру)<br></br>$&nbsp;git&nbsp;fetch&nbsp;origin<br></br></tt></p>
<p>Теперь каждая из ваших тем представляет собой нечто похожее на очередь из патчей, которую вы можете перезаписывать, перемещать, модифицировать, не оказывая влияния на остальные, как на рисунке 5-16.</p>
<p><img src="images/000080.jpg"></img></p>
<p>Давайте представим, что мейнтейнер проекта включил в основную версию чью-то группу патчей. Затем он попытался включить вашу первую ветку, но слияние уже не проходит гладко. В этом случае вы можете попробовать переместить эту ветку на верхушку ветки <tt>origin/master</tt>, разрешить конфликты для мейнтейнера и затем заново представить свои изменения на рассмотрение:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;featureA<br></br>$&nbsp;git&nbsp;rebase&nbsp;origin/master<br></br>$&nbsp;git&nbsp;push&nbsp;-f&nbsp;myfork&nbsp;featureA<br></br></tt></p>
<p>Так вы перепишете свою историю коммитов, чтобы она выглядела так, как на рисунке 5-17.</p>
<p><img src="images/000088.jpg"></img></p>
<p>Так как вы переместили ветку, команде push вы должны передать опцию <tt>-f</tt>, чтобы иметь возможность заменить ветку <tt>featureA</tt> на сервере. Есть альтернатива &mdash; выложить новую работу на сервер в другую ветку (возможно, назвав её <tt>featureAv2</tt>).</p>
<p>Давайте рассмотрим более вероятный сценарий: мейнтейнер просмотрел вашу работу во второй ветке, и ему понравилась ваша идея, но он хотел бы, чтобы вы изменили некоторые детали реализации. Воспользуемся этой возможностью, чтобы заодно переместить вашу работу так, чтобы она базировалась на текущей версии ветки <tt>master</tt> в проекте. Создадим новую ветку, базирующуюся на текущей ветке <tt>origin/master</tt>, уплотним (squash) здесь изменения из ветки <tt>featureB</tt>, разрешим все конфликты, которые могут возникнуть, сделаем необходимые изменения в реализации вашей идеи и затем выложим всё это в виде новой ветки:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;featureBv2&nbsp;origin/master<br></br>$&nbsp;git&nbsp;merge&nbsp;--no-commit&nbsp;--squash&nbsp;featureB<br></br>$&nbsp;(изменение&nbsp;реализации)<br></br>$&nbsp;git&nbsp;commit<br></br>$&nbsp;git&nbsp;push&nbsp;myfork&nbsp;featureBv2<br></br></tt></p>
<p>Опция <tt>--squash</tt> берёт всю работу на сливаемой ветке (featureB) и сжимает её в один коммит, не являющийся коммитом-слиянием, и помещает его на верхушку текущей ветки. Опция <tt>--no-commit</tt> сообщает Git'у, что не нужно автоматически записывать коммит. Это позволит вам внести все изменения с другой ветки и затем сделать ещё ряд изменений перед записью нового коммита.</p>
<p>Теперь вы можете отправить мейнтейнеру сообщение о том, что вы сделали требуемые изменения, и они могут быть найдены в вашей ветке <tt>featureBv2</tt> (см. рис. 5-18).</p>
<p><img src="images/000085.jpg"></img></p>
<p id="calibre_link-129"><span><span><b>Большой открытый проект</b></span></span></p>
<p>Во многих крупных проектах есть установленные процедуры принятия патчей &mdash; вам потребуется выяснить точные правила для каждого проекта отдельно, так как они везде разные. Однако, многие крупные открытые проекты принимают патчи через списки рассылки для разработчиков, так что мы сейчас рассмотрим пример использования этого способа.</p>
<p>Рабочий процесс похож на описанный ранее &mdash; вы создаёте тематическую ветку для каждой серии патчей, над которой работаете. Отличие состоит в процессе внесения этих изменений в проект. Вместо того, чтобы создавать ответвление (fork) от проекта и отправлять наработки в свой собственный репозиторий с правами на запись, вы генерируете e-mail версию каждой серии коммитов и отправляете её в список рассылки для разработчиков:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;topicA<br></br>$&nbsp;(выполнение&nbsp;работы)<br></br>$&nbsp;git&nbsp;commit<br></br>$&nbsp;(выполнение&nbsp;работы)<br></br>$&nbsp;git&nbsp;commit<br></br></tt></p>
<p>Теперь у нас есть два коммита, которые нужно отправить в список рассылки. Воспользуемся командой <tt>git format-patch</tt>, чтобы сгенерировать файлы в формате mbox, которые вы сможете отправить по почте. Эта команда превращает каждый коммит в электронное письмо, темой которого является первая строка сообщения коммита, а оставшаяся часть сообщения коммита и патч, который он представляет, являются телом письма. Хорошей особенностью этого является то, что применение патча из сгенерированного командой <tt>format-patch</tt> электронного письма сохраняет всю информацию о коммите. Мы увидим это в следующем разделе, когда будем применять такие патчи:</p>
<p><tt>$&nbsp;git&nbsp;format-patch&nbsp;-M&nbsp;origin/master<br></br>0001-add-limit-to-log-function.patch<br></br>0002-changed-log-output-to-30-from-25.patch<br></br></tt></p>
<p>Команда <tt>format-patch</tt> создаёт файлы с патчами и выводит их названия. Опция <tt>-M</tt> сообщает Git'у о необходимости отслеживания переименований файлов. Итоговые патчи выглядят так:</p>
<p><tt>$&nbsp;cat&nbsp;0001-add-limit-to-log-function.patch<br></br>From&nbsp;330090432754092d704da8e76ca5c05c198e71a8&nbsp;Mon&nbsp;Sep&nbsp;17&nbsp;00:00:00&nbsp;2001<br></br>From:&nbsp;Jessica&nbsp;Smith&nbsp;&lt;jessica@example.com&gt;<br></br>Date:&nbsp;Sun,&nbsp;6&nbsp;Apr&nbsp;2008&nbsp;10:17:23&nbsp;-0700<br></br>Subject:&nbsp;[PATCH&nbsp;1/2]&nbsp;add&nbsp;limit&nbsp;to&nbsp;log&nbsp;function<br></br><br></br>Limit&nbsp;log&nbsp;functionality&nbsp;to&nbsp;the&nbsp;first&nbsp;20<br></br><br></br>---<br></br>&nbsp;lib/simplegit.rb&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;+-<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br><br></br>diff&nbsp;--git&nbsp;a/lib/simplegit.rb&nbsp;b/lib/simplegit.rb<br></br>index&nbsp;76f47bc..f9815f1&nbsp;100644<br></br>---&nbsp;a/lib/simplegit.rb<br></br>+++&nbsp;b/lib/simplegit.rb<br></br>@@&nbsp;-14,7&nbsp;+14,7&nbsp;@@&nbsp;class&nbsp;SimpleGit<br></br>&nbsp;&nbsp;&nbsp;end<br></br><br></br>&nbsp;&nbsp;&nbsp;def&nbsp;log(treeish&nbsp;=&nbsp;'master')<br></br>-&nbsp;&nbsp;&nbsp;&nbsp;command("git&nbsp;log&nbsp;#{treeish}")<br></br>+&nbsp;&nbsp;&nbsp;&nbsp;command("git&nbsp;log&nbsp;-n&nbsp;20&nbsp;#{treeish}")<br></br>&nbsp;&nbsp;&nbsp;end<br></br><br></br>&nbsp;&nbsp;&nbsp;def&nbsp;ls_tree(treeish&nbsp;=&nbsp;'master')<br></br>--<br></br>1.6.2.rc1.20.g8c5b.dirty<br></br></tt></p>
<p>Вы также можете отредактировать эти файлы с патчами, чтобы добавить в электронное письмо какую-то информацию, которую вы не хотите показывать в сообщении коммита. Если вы добавите текст между строкой <tt>---</tt> и началом патча (строка <tt>lib/simplegit.rb</tt>), то разработчик сможет его прочитать, а при применении патча он будет выброшен.</p>
<p>Чтобы отправить эти файлы в список рассылки, вы можете либо вставить файл в своём почтовом клиенте, либо отправить его через специальную программу из командной строки. Вставка текста часто приводит к ошибкам форматирования, особенно в "умных" клиентах, которые не сохраняют символы перевода строки и пробельные символы в исходном виде. К счастью, Git предоставляет инструмент, позволяющий вам передавать через IMAP правильно отформатированные патчи. Для вас применение этого инструмента может оказаться более простым. Я покажу, как отсылать патчи через Gmail, так как именно этот агент я и использую; вы можете прочесть подробные инструкции для множества почтовых программ в вышеупомянутом файле <tt>Documentation/SubmittingPatches</tt>, находящемся в исходном коде Git'а.</p>
<p>Для начала нам необходимо настроить секцию imap в файле <tt>~/.gitconfig</tt>. Можете добавить все значения по одному несколькими командами <tt>git config</tt>, или можете добавить их все сразу вручную; но в итоге ваш файл конфигурации должен выглядеть примерно так:</p>
<p><tt>[imap]<br></br>&nbsp;&nbsp;folder&nbsp;=&nbsp;"[Gmail]/Drafts"<br></br>&nbsp;&nbsp;host&nbsp;=&nbsp;imaps://imap.gmail.com<br></br>&nbsp;&nbsp;user&nbsp;=&nbsp;user@gmail.com<br></br>&nbsp;&nbsp;pass&nbsp;=&nbsp;p4ssw0rd<br></br>&nbsp;&nbsp;port&nbsp;=&nbsp;993<br></br>&nbsp;&nbsp;sslverify&nbsp;=&nbsp;false<br></br></tt></p>
<p>Если ваш IMAP-сервер не использует SSL, две последние строки могут отсутствовать, а параметр host примет значение <tt>imap://</tt> вместо <tt>imaps://</tt>. Когда закончите с настройками, воспользуйтесь командой <tt>git send-email</tt>, чтобы поместить свою серию патчей в папку Drafts на указанном IMAP-сервере:</p>
<p><tt>$&nbsp;git&nbsp;send-email&nbsp;*.patch<br></br>0001-added-limit-to-log-function.patch<br></br>0002-changed-log-output-to-30-from-25.patch<br></br>Who&nbsp;should&nbsp;the&nbsp;emails&nbsp;appear&nbsp;to&nbsp;be&nbsp;from?&nbsp;[Jessica&nbsp;Smith&nbsp;&lt;jessica@example.com&gt;]<br></br>Emails&nbsp;will&nbsp;be&nbsp;sent&nbsp;from:&nbsp;Jessica&nbsp;Smith&nbsp;&lt;jessica@example.com&gt;<br></br>Who&nbsp;should&nbsp;the&nbsp;emails&nbsp;be&nbsp;sent&nbsp;to?&nbsp;jessica@example.com<br></br>Message-ID&nbsp;to&nbsp;be&nbsp;used&nbsp;as&nbsp;In-Reply-To&nbsp;for&nbsp;the&nbsp;first&nbsp;email?&nbsp;y<br></br></tt></p>
<p>Затем Git выдаёт кучу служебных сообщений, которые для каждого отсылаемого патча выглядят следующим образом:</p>
<p><tt>(mbox)&nbsp;Adding&nbsp;cc:&nbsp;Jessica&nbsp;Smith&nbsp;&lt;jessica@example.com&gt;&nbsp;from<br></br>&nbsp;&nbsp;\line&nbsp;'From:&nbsp;Jessica&nbsp;Smith&nbsp;&lt;jessica@example.com&gt;'<br></br>OK.&nbsp;Log&nbsp;says:<br></br>Sendmail:&nbsp;/usr/sbin/sendmail&nbsp;-i&nbsp;jessica@example.com<br></br>From:&nbsp;Jessica&nbsp;Smith&nbsp;&lt;jessica@example.com&gt;<br></br>To:&nbsp;jessica@example.com<br></br>Subject:&nbsp;[PATCH&nbsp;1/2]&nbsp;added&nbsp;limit&nbsp;to&nbsp;log&nbsp;function<br></br>Date:&nbsp;Sat,&nbsp;30&nbsp;May&nbsp;2009&nbsp;13:29:15&nbsp;-0700<br></br>Message-Id:&nbsp;&lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;<br></br>X-Mailer:&nbsp;git-send-email&nbsp;1.6.2.rc1.20.g8c5b.dirty<br></br>In-Reply-To:&nbsp;&lt;y&gt;<br></br>References:&nbsp;&lt;y&gt;<br></br><br></br>Result:&nbsp;OK<br></br></tt></p>
<p>Если всё прошло успешно, то сейчас вы можете перейти в свою папку Drafts, изменить поле 'To' на адрес списка рассылки, в который вы собираетесь послать патчи, возможно, указать адрес мейнтейнера или лица, отвечающего за нужную часть проекта, в поле 'CC' и отправить сообщение.</p>
<p id="calibre_link-130"><span><span><b>Итоги</b></span></span></p>
<p>В этом разделе мы рассмотрели ряд общепринятых рабочих процессов, применяемых в разных типах проектов, использующих Git, c которыми вы наверняка столкнётесь. Также были представлены несколько новых инструментов, призванных помочь вам в организации этих процессов. Далее мы рассмотрим, как осуществляется работа с противоположной стороны баррикады &mdash; как сопровождать проект, использующий Git. Вы научитесь роли благосклонного диктатора или роли менеджера по интеграции.</p>
<div></div><p id="calibre_link-131"><span><span><b>Сопровождение проекта</b></span></span></p>
<p>В дополнение к тому, как эффективно работать над проектом, вам, наверняка, необходимо также знать, как самому поддерживать проект. Сопровождение проекта может заключаться в принятии и применении патчей, сгенерированных с помощью 'format-patch' и отправленных вам по почте, или в интеграции изменений из веток тех репозиториев, которые вы добавили в качестве удалённых (remotes) для вашего проекта. Неважно, поддерживаете ли вы эталонный репозиторий проекта или хотите помочь с проверкой и утверждением патчей, вам необходимо выработать метод приёма наработок, который будет наиболее понятным для других участников и не будет изменяться в течение длительного срока.</p>
<p id="calibre_link-132"><span><span><b>Работа с тематическими ветками</b></span></span></p>
<p>Если вы решаете, интегрировать ли новые наработки, как правило, неплохо было бы опробовать их в какой-нибудь временной тематической ветке, специально созданной для их тестирования. Так будет легче подправить отдельные патчи или забросить их до лучших времён, если что-то не работает. Если вы дадите ветке простое имя, основанное на теме содержащейся в ней работы, например, <tt>ruby_client</tt>, или как-нибудь так же наглядно, то вы сможете легко вспомнить, для чего эта ветка, если вам вдруг придётся отложить работу с ней и вернуться к ней позднее. В проекте Git мейнтейнер, как правило, создаёт ветки с добавлением пространства имён &mdash; к примеру, 'sc/ruby_client', где 'sc' &mdash; это сокращённое имя автора, приславшего свою работу. Как вы уже знаете, создать ветку, основанную на вашей ветке <tt>master</tt>, можно следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;sc/ruby_client&nbsp;master<br></br></tt></p>
<p>Или, если вы хотите сразу переключиться на создаваемую ветку, можно воспользоваться командой <tt>checkout -b</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;sc/ruby_client&nbsp;master<br></br></tt></p>
<p>Теперь вы готовы к тому, чтобы принять изменения в данную тематическую ветку и определить, хотите ли вы влить их в свои стабильные ветки или нет.</p>
<p id="calibre_link-133"><span><span><b>Применение патчей, отправленных по почте</b></span></span></p>
<p>Если вы получили по электронной почте патч, который вам нужно интегрировать в свой проект, вам необходимо применить патч в тематической ветке, чтобы его оценить. Есть два способа применения отправленных по почте патчей: с помощью команды <tt>git apply</tt> или команды <tt>git am</tt>.</p>
<p><span><b>Применение патчей с помощью команды apply</b></span></p>
<p>Если вы получили чей-то патч, сгенерированный с помощью команды <tt>git diff</tt> или Unix-команды <tt>diff</tt>, вы можете применить его при помощи команды <tt>git apply</tt>. Полагая, что вы сохранили патч в <tt>/tmp/patch-ruby-client.patch</tt>, вы можете применить его следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;apply&nbsp;/tmp/patch-ruby-client.patch<br></br></tt></p>
<p>Эта команда внесёт изменения в файлы в рабочем каталоге. Она практически идентична выполнению команды <tt>patch -p1</tt> для применения патча, хотя она более параноидальна и допускает меньше нечётких совпадений, чем <tt>patch</tt>. К тому же она способна справиться с добавлением, удалением и переименованием файлов, описанными в формате <tt>git diff</tt>, чего команда <tt>patch</tt> сделать не сможет. И, наконец, <tt>git apply</tt> реализует модель "применить всё или ничего", тогда как <tt>patch</tt> позволяет частично применять патч-файлы, оставляя ваш рабочий каталог в странном и непонятном состоянии. Команда <tt>git apply</tt> в целом гораздо более параноидальна, чем <tt>patch</tt>. Она не создаст для вас коммит &mdash; после выполнения команды вы должны вручную проиндексировать внесённые изменения и сделать коммит.</p>
<p>Кроме того, вы можете использоваться <tt>git apply</tt>, чтобы узнать, чисто ли накладывается патч, ещё до того, как вы будете применять его на самом деле &mdash; для этого выполните <tt>git apply --check</tt>, указав нужный патч:</p>
<p><tt>$&nbsp;git&nbsp;apply&nbsp;--check&nbsp;0001-seeing-if-this-helps-the-gem.patch<br></br>error:&nbsp;patch&nbsp;failed:&nbsp;ticgit.gemspec:1<br></br>error:&nbsp;ticgit.gemspec:&nbsp;patch&nbsp;does&nbsp;not&nbsp;apply<br></br></tt></p>
<p>Если никакого вывода нет, то патч должен наложиться без ошибок. Если проверка прошла неудачно, то команда завершится с ненулевым статусом, так что вы можете использовать её при написании сценариев.</p>
<p><span><b>Применение патчей с помощью команды am</b></span></p>
<p>Если разработчик является достаточно хорошим пользователем Git'а и применил команду <tt>format-patch</tt> для создания своего патча, то ваша задача становится проще, так как такой патч содержит информацию об авторе и сообщение коммита. По возможности поощряйте участников проекта на использование команды <tt>format-patch</tt> вместо <tt>diff</tt> при генерировании патчей для вас. Команду <tt>git apply</tt> стоит использовать, только если нет другого выхода, и патчи уже созданы при помощи <tt>diff</tt>.</p>
<p>Чтобы применить патч, созданный при помощи <tt>format-patch</tt>, используйте команду <tt>git am</tt>. С технической точки зрения, <tt>git am</tt> читает mbox-файл, который является простым текстовым форматом для хранения одного или нескольких электронных писем в одном текстовом файле. Он выглядит примерно следующим образом:</p>
<p><tt>From&nbsp;330090432754092d704da8e76ca5c05c198e71a8&nbsp;Mon&nbsp;Sep&nbsp;17&nbsp;00:00:00&nbsp;2001<br></br>From:&nbsp;Jessica&nbsp;Smith&nbsp;&lt;jessica@example.com&gt;<br></br>Date:&nbsp;Sun,&nbsp;6&nbsp;Apr&nbsp;2008&nbsp;10:17:23&nbsp;-0700<br></br>Subject:&nbsp;[PATCH&nbsp;1/2]&nbsp;add&nbsp;limit&nbsp;to&nbsp;log&nbsp;function<br></br><br></br>Limit&nbsp;log&nbsp;functionality&nbsp;to&nbsp;the&nbsp;first&nbsp;20<br></br></tt></p>
<p>Это начало вывода команды <tt>format-patch</tt>, который мы уже видели в предыдущем разделе. Это одновременно и правильный mbox формат для e-mail. Если кто-то прислал вам по почте патч, правильно воспользовавшись для этого командой <tt>git send-email</tt>, и вы сохранили это сообщение в mbox-формате, тогда вы можете указать этот mbox-файл команде <tt>git am</tt>&nbsp;&mdash; в результате команда начнёт применять все патчи, которые найдёт. Если вы пользуетесь почтовым клиентом, способным сохранять несколько электронных писем в один mbox-файл, то можете сохранить всю серию патчей в один файл и затем использовать команду <tt>git am</tt> для применения всех патчей сразу.</p>
<p>Однако, если кто-нибудь загрузил патч, созданный через <tt>format-patch</tt>, в тикет-систему или что-либо подобное, вы можете сохранить файл локально и затем передать его команде <tt>git am</tt>, чтобы его наложить:</p>
<p><tt>$&nbsp;git&nbsp;am&nbsp;0001-limit-log-function.patch<br></br>Applying:&nbsp;add&nbsp;limit&nbsp;to&nbsp;log&nbsp;function<br></br></tt></p>
<p>Как видите, патч был применён без ошибок, и за вас автоматически был создан новый коммит. Информация об авторе берётся из полей <tt>From</tt> и <tt>Date</tt> письма, а сообщение коммита извлекается из поля <tt>Subject</tt> и тела (до начала самого патча) электронного письма. Например, если применить патч из mbox-файла приведённого выше примера, то созданный для него коммит будет выглядеть следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=fuller&nbsp;-1<br></br>commit&nbsp;6c5e70b984a60b3cecd395edd5b48a7575bf58e0<br></br>Author:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jessica&nbsp;Smith&nbsp;&lt;jessica@example.com&gt;<br></br>AuthorDate:&nbsp;Sun&nbsp;Apr&nbsp;6&nbsp;10:17:23&nbsp;2008&nbsp;-0700<br></br>Commit:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>CommitDate:&nbsp;Thu&nbsp;Apr&nbsp;9&nbsp;09:19:06&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;add&nbsp;limit&nbsp;to&nbsp;log&nbsp;function<br></br><br></br>&nbsp;&nbsp;&nbsp;Limit&nbsp;log&nbsp;functionality&nbsp;to&nbsp;the&nbsp;first&nbsp;20<br></br></tt></p>
<p>В поле <tt>Commit</tt> указан человек, применивший патч, а в <tt>CommitDate</tt> &mdash; время его применения. Информация <tt>Author</tt> определяет человека, создавшего патч изначально, и время его создания.</p>
<p>Однако возможна ситуация, когда патч не наложится без ошибок. Возможно, ваша основная ветка слишком далеко ушла вперёд относительно той, на которой патч был основан, или этот патч зависит от другого патча, который вы ещё не применили. В этом случае выполнение команды <tt>git am</tt> будет приостановлено, а у вас спросят, что вы хотите сделать:</p>
<p><tt>$&nbsp;git&nbsp;am&nbsp;0001-seeing-if-this-helps-the-gem.patch<br></br>Applying:&nbsp;seeing&nbsp;if&nbsp;this&nbsp;helps&nbsp;the&nbsp;gem<br></br>error:&nbsp;patch&nbsp;failed:&nbsp;ticgit.gemspec:1<br></br>error:&nbsp;ticgit.gemspec:&nbsp;patch&nbsp;does&nbsp;not&nbsp;apply<br></br>Patch&nbsp;failed&nbsp;at&nbsp;0001.<br></br>When&nbsp;you&nbsp;have&nbsp;resolved&nbsp;this&nbsp;problem&nbsp;run&nbsp;"git&nbsp;am&nbsp;--resolved".<br></br>If&nbsp;you&nbsp;would&nbsp;prefer&nbsp;to&nbsp;skip&nbsp;this&nbsp;patch,&nbsp;instead&nbsp;run&nbsp;"git&nbsp;am&nbsp;--skip".<br></br>To&nbsp;restore&nbsp;the&nbsp;original&nbsp;branch&nbsp;and&nbsp;stop&nbsp;patching&nbsp;run&nbsp;"git&nbsp;am&nbsp;--abort".<br></br></tt></p>
<p>Эта команда выставляет отметки о конфликтах в каждый файл, с которым возникают проблемы, точно так же, как это происходит при операции слияния или перемещения с конфликтами. И разрешается данная ситуация тем же способом &mdash; отредактируйте файл, чтобы разрешить конфликт, добавьте новый файл в индекс, а затем выполните команду <tt>git am --resolved</tt>, чтобы перейти к следующему патчу:</p>
<p><tt>$&nbsp;(исправление&nbsp;файла)<br></br>$&nbsp;git&nbsp;add&nbsp;ticgit.gemspec<br></br>$&nbsp;git&nbsp;am&nbsp;--resolved<br></br>Applying:&nbsp;seeing&nbsp;if&nbsp;this&nbsp;helps&nbsp;the&nbsp;gem<br></br></tt></p>
<p>Если вы хотите, чтобы Git постарался разрешить конфликт более умно, воспользуйтесь опцией <tt>-3</tt>, при использовании которой Git попытается выполнить трёхходовую операцию слияния. Эта опция не включена по умолчанию, так как она не работает в случае, если коммита, на котором был основан патч, нет в вашем репозитории. Если этот коммит всё же у вас есть &mdash; в случае когда патч был основан на публичном коммите &mdash; то опция <tt>-3</tt>, как правило, гораздо умнее в наложении конфликтных патчей:</p>
<p><tt>$&nbsp;git&nbsp;am&nbsp;-3&nbsp;0001-seeing-if-this-helps-the-gem.patch<br></br>Applying:&nbsp;seeing&nbsp;if&nbsp;this&nbsp;helps&nbsp;the&nbsp;gem<br></br>error:&nbsp;patch&nbsp;failed:&nbsp;ticgit.gemspec:1<br></br>error:&nbsp;ticgit.gemspec:&nbsp;patch&nbsp;does&nbsp;not&nbsp;apply<br></br>Using&nbsp;index&nbsp;info&nbsp;to&nbsp;reconstruct&nbsp;a&nbsp;base&nbsp;tree...<br></br>Falling&nbsp;back&nbsp;to&nbsp;patching&nbsp;base&nbsp;and&nbsp;3-way&nbsp;merge...<br></br>No&nbsp;changes&nbsp;--&nbsp;Patch&nbsp;already&nbsp;applied.<br></br></tt></p>
<p>В этом случае я пытался применить патч, который я уже применил. Без опции <tt>-3</tt> это привело бы к конфликту.</p>
<p>При применении серии патчей из mbox-файла, вы также можете запустить команду <tt>am</tt> в интерактивном режиме &mdash; в этом случае команда останавливается на каждом найденном патче и спрашивает вас, хотите ли вы его применить:</p>
<p><tt>$&nbsp;git&nbsp;am&nbsp;-3&nbsp;-i&nbsp;mbox<br></br>Commit&nbsp;Body&nbsp;is:<br></br>--------------------------<br></br>seeing&nbsp;if&nbsp;this&nbsp;helps&nbsp;the&nbsp;gem<br></br>--------------------------<br></br>Apply?&nbsp;[y]es/[n]o/[e]dit/[v]iew&nbsp;patch/[a]ccept&nbsp;all<br></br></tt></p>
<p>Это удобно, если у вас накопилось множество патчей, так как вы сможете сначала просмотреть патч, если вы забыли, что он из себя представляет, или отказаться применять патч, если он уже применён.</p>
<p>После того как вы примените все патчи по интересующей вас теме и сделаете для них коммиты в своей ветке, вы можете принять решение &mdash; интегрировать ли их в свои стабильные ветки и если да, то каким образом.</p>
<p id="calibre_link-134"><span><span><b>Проверка удалённых веток</b></span></span></p>
<p>Если к вам поступили наработки от человека, использующего Git и имеющего свой собственный репозиторий, в который он и отправил свои изменения, а вам он прислал ссылку на свой репозиторий и имя удалённой ветки, в которой находятся изменения, то вы можете добавить его репозиторий в качестве удалённого и выполнить слияния локально.</p>
<p>Например, если Джессика присылает вам письмо, в котором говорится, что у неё есть классная новая функция в ветке <tt>ruby-client</tt> в её репозитории, вы можете протестировать её, добавив её репозиторий в качестве удалённого для вашего проекта и выгрузив содержимое этой ветки в рабочий каталог:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;jessica&nbsp;git://github.com/jessica/myproject.git<br></br>$&nbsp;git&nbsp;fetch&nbsp;jessica<br></br>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;rubyclient&nbsp;jessica/ruby-client<br></br></tt></p>
<p>Если она снова пришлёт вам письмо с другой веткой и с новой замечательной функцией, вы сможете сразу извлечь эти наработки и переключиться на эту ветку, так как её репозиторий уже прописан в ваших удалённых репозиториях.</p>
<p>Этот метод наиболее удобен, если вы работаете с человеком постоянно. Если кто-то изредка представляет вам по одному патчу, то менее затратно по времени будет принимать их по e-mail, чем заставлять всех иметь свои собственные репозитории и постоянно добавлять и удалять удалённые репозитории, чтобы получить пару патчей. Также вы, скорее всего, не захотите иметь у себя сотни удалённых репозиториев &mdash; для всех, кто предоставил вам один или два патча. Хотя сценарии и функции хостингов могут упростить эту ситуацию &mdash; всё зависит от того, как ведёте разработку вы и участники вашего проекта.</p>
<p>Другим преимуществом данного подхода является тот факт, что вы получаете не только патчи, но и историю коммитов. Если вы даже обнаружите проблемы со слиянием, то вы, по крайней мере, будете знать, на каком коммите в вашей истории основана их работа. Правильное трёхходовое слияние в этом случае используется по умолчанию, что лучше, чем передать <tt>-3</tt> и надеяться, что патч был сгенерирован на основе публичного коммита, к которому у вас есть доступ.</p>
<p>Если вы не работаете с человеком постоянно, но всё же хотите принять его изменения таким способом, можете указать URL его удалённого репозитория команде <tt>git pull</tt>. Так вы получите нужные изменения, а URL не будет сохранён в списке удалённых репозиториев:</p>
<p><tt>$&nbsp;git&nbsp;pull&nbsp;git://github.com/onetimeguy/project.git<br></br>From&nbsp;git://github.com/onetimeguy/project<br></br>&nbsp;*&nbsp;branch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HEAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;FETCH_HEAD<br></br>Merge&nbsp;made&nbsp;by&nbsp;recursive.<br></br></tt></p>
<p id="calibre_link-135"><span><span><b>Определение вносимых изменений</b></span></span></p>
<p>Сейчас у вас есть тематическая ветка, содержащая наработки участников проекта. На этом этапе вы можете определить, что бы вы хотели с ними сделать. В этом разделе мы снова рассмотрим несколько команд, которые, как вы увидите, можно использовать для точного определения того, что вы собираетесь слить в свою основную ветку.</p>
<p>Часто полезно просмотреть все коммиты, которые есть в этой ветке, но нет в вашей ветке <tt>master</tt>. Исключить коммиты из ветки <tt>master</tt> можно добавив опцию <tt>--not</tt> перед именем ветки. Например, если участник вашего проекта прислал вам два патча, и вы создали ветку с именем <tt>contrib</tt> и применили эти патчи в ней, вы можете выполнить следующее:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;contrib&nbsp;--not&nbsp;master<br></br>commit&nbsp;5b6235bd297351589efc4d73316f0a68d484f118<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Oct&nbsp;24&nbsp;09:53:59&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;seeing&nbsp;if&nbsp;this&nbsp;helps&nbsp;the&nbsp;gem<br></br><br></br>commit&nbsp;7482e0d16d04bea79d0dba8988cc78df655f16a0<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Mon&nbsp;Oct&nbsp;22&nbsp;19:38:36&nbsp;2008&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;updated&nbsp;the&nbsp;gemspec&nbsp;to&nbsp;hopefully&nbsp;work&nbsp;better<br></br></tt></p>
<p>Чтобы увидеть какие изменения вносит каждый коммит, если помните, можно передать опцию <tt>-p</tt> команде <tt>git log</tt> &mdash; к каждому коммиту будет добавлен его diff.</p>
<p>Чтобы посмотреть полный diff того, что добавится при слиянии вашей тематической ветки с другой веткой, вам может понадобиться использовать странный трюк, чтобы получить нужный результат. Вы, возможно, решите выполнить такую команду:</p>
<p><tt>$&nbsp;git&nbsp;diff&nbsp;master<br></br></tt></p>
<p>Эта команда выведет вам diff, но результат может ввести вас в заблуждение. Если ваша ветка <tt>master</tt> была промотана вперёд с того момента, когда вы создали на её основе тематическую ветку, вы, наверняка, увидите странный результат. Это происходит по той причине, что Git напрямую сравнивает снимок состояния последнего коммита тематической ветки, на которой вы находитесь, и снимок последнего коммита ветки <tt>master</tt>. Например, если вы добавили строку в файл в ветке <tt>master</tt>, прямое сравнение снимков покажет, что изменения в тематической ветке собираются эту строку удалить.</p>
<p>Если <tt>master</tt> является прямым предком вашей тематической ветки, то проблем нет. Но если две линии истории разошлись, то diff будет выглядеть так, будто вы добавляете всё новое из вашей тематической ветки и удаляете всё уникальное в ветке <tt>master</tt>.</p>
<p>То, что вы действительно хотели бы видеть &mdash; это изменения, добавленные в тематической ветке, то есть те наработки, которые вы внесёте при слиянии этой ветки с веткой <tt>master</tt>. Это выполняется путём сравнения последнего коммита в вашей тематической ветке с первым общим с веткой <tt>master</tt> предком.</p>
<p>Технически, вы можете сделать это, выделив общего предка явным образом и выполнив затем команду <tt>diff</tt>:</p>
<p><tt>$&nbsp;git&nbsp;merge-base&nbsp;contrib&nbsp;master<br></br>36c7dba2c95e6bbb78dfa822519ecfec6e1ca649<br></br>$&nbsp;git&nbsp;diff&nbsp;36c7db<br></br></tt></p>
<p>Однако это не очень удобно, так что в Git'е есть отдельное сокращённое обозначение для выполнения того же самого &mdash; запись с тремя точками. В контексте команды <tt>diff</tt>, вы можете поставить три точки после названия одной из веток, чтобы увидеть дельту между последним коммитом ветки, на которой вы находитесь, и их общим предком с другой веткой:</p>
<p><tt>$&nbsp;git&nbsp;diff&nbsp;master...contrib<br></br></tt></p>
<p>Эта команда покажет вам только те наработки в вашей текущей тематической ветке, которые были внесены после её ответвления от ветки <tt>master</tt>. Это очень удобный синтаксис, и его надо запомнить.</p>
<p id="calibre_link-136"><span><span><b>Интегрирование чужих наработок</b></span></span></p>
<p>Когда все наработки в вашей тематической ветке готовы к интегрированию в более стабильную ветку, встаёт вопрос &mdash; как это сделать? Более того &mdash; какой рабочий процесс в целом вы хотите использовать, занимаясь поддержкой своего проекта? Есть множество вариантов, так что рассмотрим некоторые из них.</p>
<p><span><b>Процессы слияния</b></span></p>
<p>Один из простых рабочих процессов заключается в слиянии наработок в ветку <tt>master</tt>. В этом случае ваша ветка <tt>master</tt> содержит основную стабильную версию кода. Если у вас в тематической ветке находится работа, которую вы уже доделали, или полученные от кого-то наработки, которые вы уже проверили, вы сливаете её в свою ветку <tt>master</tt>, удаляете тематическую ветку, а затем продолжаете работу. Если в вашем репозитории наработки находятся в двух ветках, названия которых <tt>ruby_client</tt> и <tt>php_client</tt> (см. рис. 5-19), и вы выполняете слияние сначала для ветки <tt>ruby_client</tt>, в потом для <tt>php_client</tt>, то ваша история коммитов в итоге будет выглядеть, как показано на рисунке 5-20.</p>
<p><img src="images/000044.jpg"></img></p>
<p><img src="images/000050.jpg"></img></p>
<p>Это, по всей видимости, наиболее простой рабочий процесс, но при работе с большими проектами здесь возникает ряд проблем.</p>
<p>Если ваш проект более крупный, или вы работаете с большим количеством разработчиков, вы, вероятно, будете применять по крайней мере двухэтапный цикл слияний. При этом сценарии у вас есть две долгоживущие ветки, <tt>master</tt> и <tt>develop</tt>, и вы решили, что ветка <tt>master</tt> обновляется только тогда, когда выходит очень стабильный релиз, а весь новый код включается в ветку <tt>develop</tt>. Изменения в обеих этих ветках регулярно отправляются в публичный репозиторий. Каждый раз, когда у вас появляется новая тематическая ветка для слияния (рисунок 5-21), вы сначала сливаете её в <tt>develop</tt> (рисунок 5-22); затем, когда вы выпускаете релиз, вы делаете перемотку (fast-forward) ветки <tt>master</tt> на нужный стабильный коммит ветки <tt>develop</tt> (рисунок 5-23).</p>
<p><img src="images/000055.jpg"></img></p>
<p><img src="images/000058.jpg"></img></p>
<p><img src="images/000063.jpg"></img></p>
<p>При таком подходе, клонируя ваш репозиторий, люди могут либо выгрузить ветку <tt>master</tt>, чтобы получить последний стабильный релиз и легко поддерживать этот код обновлённым, либо переключиться на ветку <tt>develop</tt>, которая включает в себя всё самое свежее. Вы также можете развить данный подход, создав ветку для интегрирования, в которой будет происходить слияние всех наработок. И когда код на этой ветке станет стабилен и пройдёт все тесты, вы сольёте её в ветку <tt>develop</tt>; и если всё будет работать как надо в течение некоторого времени, вы выполните перемотку ветки <tt>master</tt>.</p>
<p><span><b>Рабочие процессы с крупными слияниями</b></span></p>
<p>В проекте Git имеются четыре долгоживущие ветки: <tt>master</tt>, <tt>next</tt>, <tt>pu</tt> (proposed updates) для новых наработок и <tt>maint</tt> для ретроподдержки (backports). Когда участники проекта подготавливают свои наработки, они собираются в тематических ветках в репозитории мейнтейнера проекта примерно так, как мы уже описывали (см. рис. 5-24). На этом этапе проводится оценка проделанной работы &mdash; всё ли работает как положено, стабилен ли код, или ему требуется доработка. Если всё в порядке, то тематические ветки сливаются в ветку <tt>next</tt>, которая отправляется на сервер, чтобы у каждого была возможность опробовать интегрированные воедино изменения из тематических веток.</p>
<p><img src="images/000076.jpg"></img></p>
<p>Если тематические ветки требуют доработки, они сливаются в ветку <tt>pu</tt>. Когда будет установлено, что тематические ветки полностью стабильны, они переливаются в <tt>master</tt>, а ветки <tt>pu</tt> и <tt>next</tt> перестраиваются на основе тематических веток, находившихся в <tt>next</tt>, но ещё не дозревших до <tt>master</tt>. Это означает, что <tt>master</tt> практически всегда движется в прямом направлении, ветка <tt>next</tt> перемещается (rebase) иногда, а ветка <tt>pu</tt> перемещается чаще всех (см. рис. 5-25).</p>
<p><img src="images/000019.jpg"></img></p>
<p>Когда тематическая ветка была полностью слита в ветку <tt>master</tt>, она удаляется из репозитория. В проекте Git есть ещё ветка <tt>maint</tt>, которая ответвлена от последнего релиза и предоставляет backport-патчи, на случай если потребуется выпуск корректировочной версии. Таким образом, когда вы клонируете Git-репозиторий, вы получаете четыре ветки, переключаясь на которые вы можете оценить проект на разных стадиях разработки (в зависимости от того, насколько свежую версию вы хотите получить, или от того, каким образом вы хотите внести в проект свою работу); а мейнтейнер, в свою очередь, имеет структурированный рабочий процесс, который помогает ему изучать новые присланные патчи.</p>
<p><span><b>Рабочие процессы с перемещениями и отбором лучшего</b></span></p>
<p>Другие мейнтейнеры вместо слияния предпочитают выполнять перемещение или отбор лучших наработок участников проекта на верхушку своей ветки <tt>master</tt>, чтобы иметь практически линейную историю разработки. Когда у вас есть наработки в тематической ветке, которые вы хотите интегрировать в проект, вы переходите на эту ветку и запускаете команду <tt>rebase</tt>, которая перемещает изменения на верхушку вашей текущей ветки <tt>master</tt> (или <tt>develop</tt>, и т.п.). Если всё прошло хорошо, то можете выполнить перемотку ветки <tt>master</tt>, получив тем самым линейную историю работы над проектом.</p>
<p>Другой вариант перемещения сделанных наработок из одной ветки в другую &mdash; отбор лучшего (cherry-pick). Отбор лучшего в Git'е является чем-то наподобие перемещения для отдельных коммитов. Берётся патч, который был представлен в коммите, и делается попытка применить его на ветке, на которой вы сейчас находитесь. Это удобно в том случае, если у вас в тематической ветке находится несколько коммитов, а вы хотите включить в проект только один из них, или если у вас только один коммит в тематической ветке, но вы предпочитаете выполнять отбор лучшего вместо перемещения. Например, предположим, ваш проект выглядит так, как показано на рисунке 5-26.</p>
<p><img src="images/000097.jpg"></img></p>
<p>Если вы хотите вытащить коммит <tt>e43a6</tt> в ветку <tt>master</tt>, выполните:</p>
<p><tt>$&nbsp;git&nbsp;cherry-pick&nbsp;e43a6fd3e94888d76779ad79fb568ed180e5fcdf<br></br>Finished&nbsp;one&nbsp;cherry-pick.<br></br>[master]:&nbsp;created&nbsp;a0a41a9:&nbsp;"More&nbsp;friendly&nbsp;message&nbsp;when&nbsp;locking&nbsp;the&nbsp;index&nbsp;fails."<br></br>&nbsp;3&nbsp;files&nbsp;changed,&nbsp;17&nbsp;insertions(+),&nbsp;3&nbsp;deletions(-)<br></br></tt></p>
<p>Эта команда включит в ветку <tt>master</tt> такие же изменения, которые были добавлены в <tt>e43a6</tt>, но вы получите новое значение SHA-1 для этого коммита, так как у него будет другая дата применения. Теперь ваша история коммитов выглядит, как показано на рисунке 5-27.</p>
<p><img src="images/000070.jpg"></img></p>
<p>Теперь вы можете удалить свою тематическую ветку и отбросить коммиты, которые вы не захотели включить в проект.</p>
<p id="calibre_link-137"><span><span><b>Отметка релизов</b></span></span></p>
<p>Если вы решили выпустить релиз, вы, вероятно, захотите присвоить ему метку, так чтобы вы потом смогли восстановить этот релиз в любой момент. Процесс создания новой метки обсуждался в главе 2. Если вы решили подписать вашу метку как мейнтейнер, то процедура будет выглядеть примерно следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;tag&nbsp;-s&nbsp;v1.5&nbsp;-m&nbsp;'my&nbsp;signed&nbsp;1.5&nbsp;tag'<br></br>You&nbsp;need&nbsp;a&nbsp;passphrase&nbsp;to&nbsp;unlock&nbsp;the&nbsp;secret&nbsp;key&nbsp;for<br></br>user:&nbsp;"Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;"<br></br>1024-bit&nbsp;DSA&nbsp;key,&nbsp;ID&nbsp;F721C45A,&nbsp;created&nbsp;2009-02-09<br></br></tt></p>
<p>Если вы подписываете свои метки, у вас может возникнуть проблема с распространением открытого PGP-ключа, используемого для подписи ваших меток. Мейнтейнер проекта Git решил эту проблему, добавив свой публичный ключ в виде блоба (blob) прямо в репозиторий и затем выставив метку, указывающую прямо на содержимое ключа. Чтобы сделать это, определите, какой ключ вам нужен, выполнив <tt>gpg --list-keys</tt>:</p>
<p><tt>$&nbsp;gpg&nbsp;--list-keys<br></br>/Users/schacon/.gnupg/pubring.gpg<br></br>---------------------------------<br></br>pub&nbsp;&nbsp;&nbsp;1024D/F721C45A&nbsp;2009-02-09&nbsp;[expires:&nbsp;2010-02-09]<br></br>uid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>sub&nbsp;&nbsp;&nbsp;2048g/45D02282&nbsp;2009-02-09&nbsp;[expires:&nbsp;2010-02-09]<br></br></tt></p>
<p>Затем вы можете напрямую импортировать ключ в базу данных Git'а, экспортировав его и передав по конвейеру команде <tt>git hash-object</tt>, которая создаст новый блоб с содержимым ключа и вернёт вам SHA-1 этого блоба:</p>
<p><tt>$&nbsp;gpg&nbsp;-a&nbsp;--export&nbsp;F721C45A&nbsp;|&nbsp;git&nbsp;hash-object&nbsp;-w&nbsp;--stdin<br></br>659ef797d181633c87ec71ac3f9ba29fe5775b92<br></br></tt></p>
<p>Теперь, когда у вас в Git'е хранится ваш ключ, вы можете создать метку, напрямую указывающую на него, использовав значение SHA-1, возвращённое командой <tt>hash-object</tt>:</p>
<p><tt>$&nbsp;git&nbsp;tag&nbsp;-a&nbsp;maintainer-pgp-pub&nbsp;659ef797d181633c87ec71ac3f9ba29fe5775b92<br></br></tt></p>
<p>Если вы запустите команду <tt>git push --tags</tt>, то метка <tt>maintainer-pgp-pub</tt> станет доступна каждому. Если кто-нибудь захочет проверить какую-нибудь метку, он сможет напрямую импортировать ваш PGP-ключ, вытащив блоб прямо из базы данных и импортировав его в GPG:</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;maintainer-pgp-pub&nbsp;|&nbsp;gpg&nbsp;--import<br></br></tt></p>
<p>Этот ключ может быть использован для проверки любых подписанных вами меток. Кроме того, если вы включите инструкции в сообщение метки, запуск <tt>git show &lt;метка&gt;</tt> позволит конечному пользователю получить инструкции по проверке меток.</p>
<p id="calibre_link-138"><span><span><b>Генерация номера сборки</b></span></span></p>
<p>Так как коммитам в Git'е не присваиваются монотонно возрастающие номера наподобие 'v123' или чего-то аналогичного, то в случае, если вы хотите присвоить коммиту имя, удобное для восприятия, запустите команду <tt>git describe</tt> для этого коммита. Git вернёт вам имя ближайшей метки с числом коммитов, сделанных поверх этой метки и частичное значения SHA-1 описываемого коммита:</p>
<p><tt>$&nbsp;git&nbsp;describe&nbsp;master<br></br>v1.6.2-rc1-20-g8c5b85c<br></br></tt></p>
<p>Таким образом, при экспорте снимка состояния проекта или его сборки вы можете дать им имя, понятное для людей. На самом деле, если вы собираете Git из исходного кода, склонированного из Git-репозитория, <tt>git --version</tt> вернёт вам что-то подобное. Если вы описываете коммит, которому вы напрямую присвоили метку, команда вернёт вам имя метки.</p>
<p>Команду <tt>git describe</tt> хорошо использовать с аннотированными метками (метками, созданными при помощи опций <tt>-a</tt> или <tt>-s</tt>), так что если вы используете <tt>git describe</tt>, то метки для релизов должны создаваться этим способом &mdash; в этом случае вы сможете удостовериться, что при описании коммиту было дано правильное имя. Вы также можете использовать эту строку в командах <tt>checkout</tt> и <tt>show</tt> для указания нужного коммита, однако в будущем она может перестать работать правильно в силу того, что в строке присутствует сокращённое значение SHA-1. Например, в ядре Linux недавно перешли от 8 к 10 символам, необходимым для обеспечения уникальности SHA-1 объектов, и поэтому старые имена, сгенерированные командой <tt>git describe</tt>, стали недействительными.</p>
<p id="calibre_link-139"><span><span><b>Подготовка релиза</b></span></span></p>
<p>Теперь хотелось бы выпустить релиз сборки. Вероятно, вам захочется сделать архив последнего состояния вашего кода для тех бедолаг, которые не используют Git. Для этого используется команда <tt>git archive</tt>:</p>
<p><tt>$&nbsp;git&nbsp;archive&nbsp;master&nbsp;--prefix='project/'&nbsp;|&nbsp;gzip&nbsp;&gt;&nbsp;`git&nbsp;describe&nbsp;master`.tar.gz<br></br>$&nbsp;ls&nbsp;*.tar.gz<br></br>v1.6.2-rc1-20-g8c5b85c.tar.gz<br></br></tt></p>
<p>Если кто-нибудь откроет этот tarball, он получит последний снимок состояния вашего проекта внутри каталога <tt>project</tt>. Таким же способом вы можете создать zip-архив, указав команде <tt>git archive</tt> опцию <tt>--format=zip</tt>:</p>
<p><tt>$&nbsp;git&nbsp;archive&nbsp;master&nbsp;--prefix='project/'&nbsp;--format=zip&nbsp;&gt;&nbsp;`git&nbsp;describe&nbsp;master`.zip<br></br></tt></p>
<p>Теперь у вас есть тарбол и zip-архив с релизом вашего проекта, которые вы можете загрузить на свой сайт или отправить людям по почте.</p>
<p id="calibre_link-140"><span><span><b>Команда shortlog</b></span></span></p>
<p>Пришло время написать письмо для списка рассылки, чтобы поделиться новостями проекта со всеми, кто им интересуется. При помощи команды <tt>git shortlog</tt> можно быстро получить что-то наподобие лога изменений (changelog), описывающего, что появилось нового в вашем проекте со времени последнего релиза или последнего письма в список рассылки. Лог изменений включает в себя все коммиты в указанном диапазоне; например, следующая команда вернёт вам сводку по всем коммитам, сделанным со времени прошлого релиза (если последний релиз имел метку v1.0.1):</p>
<p><tt>$&nbsp;git&nbsp;shortlog&nbsp;--no-merges&nbsp;master&nbsp;--not&nbsp;v1.0.1<br></br>Chris&nbsp;Wanstrath&nbsp;(8):<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add&nbsp;support&nbsp;for&nbsp;annotated&nbsp;tags&nbsp;to&nbsp;Grit::Tag<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add&nbsp;packed-refs&nbsp;annotated&nbsp;tag&nbsp;support.<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add&nbsp;Grit::Commit#to_patch<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Update&nbsp;version&nbsp;and&nbsp;History.txt<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove&nbsp;stray&nbsp;`puts`<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make&nbsp;ls_tree&nbsp;ignore&nbsp;nils<br></br><br></br>Tom&nbsp;Preston-Werner&nbsp;(4):<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fix&nbsp;dates&nbsp;in&nbsp;history<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dynamic&nbsp;version&nbsp;method<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Version&nbsp;bump&nbsp;to&nbsp;1.0.2<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Regenerated&nbsp;gemspec&nbsp;for&nbsp;version&nbsp;1.0.2<br></br></tt></p>
<p>Мы получили аккуратную сводку по всем коммитам, начиная с метки v1.0.1, сгруппированным по авторам. Вывод этой команды можно послать в свой список рассылки.</p>
<div></div><p id="calibre_link-141"><span><span><b>Итоги</b></span></span></p>
<p>Вы должны чувствовать себя достаточно свободно, внося свой вклад в проект под управлением Git'а, а также занимаясь поддержкой своего собственного проекта или интегрированием наработок других пользователей. Поздравляем тебя, опытный Git-разработчик! В следующей главе вы познакомитесь с более мощными инструментами, а также получите советы по действию в сложных ситуациях, что сделает из вас настоящего мастера Git'а.</p>
<div></div><p id="calibre_link-142"><span><span><b>Инструменты Git</b></span></span></p>
<p>К этому времени вы уже изучили большинство повседневных команд и способы организации рабочего процесса, необходимые для того, чтобы поддерживать Git-репозиторий для контроля вашего исходного кода. Вы выполнили основные задания, связанные с добавлением файлов под версионный контроль и записью сделанных изменений, и вы вооружились мощью подготовительной области (staging area), легковесного ветвления и слияния.</p>
<p>Сейчас вы познакомитесь с множеством весьма сильных возможностей Git'а. Вы совсем не обязательно будете использовать их каждый день, но, возможно, в какой-то момент они вам понадобятся.</p>
<div></div><p id="calibre_link-143"><span><span><b>Выбор ревизии</b></span></span></p>
<p>Git позволяет указывать конкретные коммиты или их последовательности несколькими способами. Они не всегда очевидны, но иногда их полезно знать.</p>
<p id="calibre_link-144"><span><span><b>Одиночные ревизии</b></span></span></p>
<p>Вы можете просто сослаться на коммит по его SHA-1 хешу, но также существуют более понятные для человека способы ссылаться на коммиты. В этом разделе кратко описаны различные способы обратиться к одному определённому коммиту.</p>
<p id="calibre_link-145"><span><span><b>Сокращённый SHA</b></span></span></p>
<p>Git достаточно умён для того, чтобы понять какой коммит вы имеете в виду по первым нескольким символам (частичному хешу), конечно, если их не меньше четырёх и они однозначны, то есть если хеш только одного объекта в вашем репозитории начинается с этих символов.</p>
<p>Предположим, что вы хотите посмотреть содержимое какого-то конкретного коммита. Вы выполняете команду <tt>git log</tt> и находите этот коммит (например, тот, в котором вы добавили какую-то функциональность):</p>
<p><tt>$&nbsp;git&nbsp;log<br></br>commit&nbsp;734713bc047d87bf7eac9674765ae793478c50d3<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Jan&nbsp;2&nbsp;18:32:33&nbsp;2009&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;fixed&nbsp;refs&nbsp;handling,&nbsp;added&nbsp;gc&nbsp;auto,&nbsp;updated&nbsp;tests<br></br><br></br>commit&nbsp;d921970aadf03b3cf0e71becdaab3147ba71cdef<br></br>Merge:&nbsp;1c002dd...&nbsp;35cfb2b...<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Dec&nbsp;11&nbsp;15:08:43&nbsp;2008&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Merge&nbsp;commit&nbsp;'phedders/rdocs'<br></br><br></br>commit&nbsp;1c002dd4b536e7479fe34593e72e6c6c1819e53b<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Dec&nbsp;11&nbsp;14:58:32&nbsp;2008&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;added&nbsp;some&nbsp;blame&nbsp;and&nbsp;merge&nbsp;stuff<br></br></tt></p>
<p>В нашем случае выберем коммит <tt>1c002dd....</tt>. При использовании <tt>git show</tt> для просмотра содержимого этого коммита следующие команды эквивалентны (предполагая, что сокращённые версии однозначны):</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;1c002dd4b536e7479fe34593e72e6c6c1819e53b<br></br>$&nbsp;git&nbsp;show&nbsp;1c002dd4b536e7479f<br></br>$&nbsp;git&nbsp;show&nbsp;1c002d<br></br></tt></p>
<p>Git может показать короткие уникальные сокращения ваших SHA-1 хешей. Если вы передадите опцию <tt>--abbrev-commit</tt> команде <tt>git log</tt>, то её вывод будет использовать сокращённые значения, сохраняя их уникальными; по умолчанию будут использоваться семь символов, но при необходимости длина будет увеличена для сохранения однозначности хешей:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--abbrev-commit&nbsp;--pretty=oneline<br></br>ca82a6d&nbsp;changed&nbsp;the&nbsp;version&nbsp;number<br></br>085bb3b&nbsp;removed&nbsp;unnecessary&nbsp;test&nbsp;code<br></br>a11bef0&nbsp;first&nbsp;commit<br></br></tt></p>
<p>В общем случае восемь-десять символов более чем достаточно для уникальности внутри проекта. В одном из самых больших проектов, использующих Git, ядре Linux только начинает появляться необходимость использовать 12 символов из 40 возможных для сохранения уникальности.</p>
<p id="calibre_link-146"><span><span><b>Небольшое замечание о SHA-1</b></span></span></p>
<p>Многие люди интересуются, что произойдёт, если они в какой-то момент, по некоторой случайности, получат два объекта в репозитории, которые будут иметь два одинаковых значения SHA-1 хеша. Что тогда?</p>
<p>Если вы вдруг закоммитите объект, SHA-1 хеш которого такой же, как у некоторого предыдущего объекта в вашем репозитории, Git обнаружит предыдущий объект в своей базе данных и посчитает, что он уже был записан. Если вы в какой-то момент попытаетесь получить этот объект опять, вы всегда будете получать данные первого объекта.</p>
<p>Однако, вы должны осознавать то, как смехотворно маловероятен этот сценарий. Длина SHA-1 составляет 20 байт или 160 бит. Количество случайно хешированных объектов, необходимое для того, чтобы получить 50% вероятность одиночного совпадения составляет порядка 2<sup><small><span>80</span></small></sup> (формула для определения вероятности совпадения: <tt>p = (n(n-1)/2) * (1/2^160))</tt>). 2<sup><small><span>80</span></small></sup> это 1.2 x 10<sup><small><span>24</span></small></sup> или один миллион миллиарда миллиардов. Это в 1200 раз больше количества песчинок на земле.</p>
<p>Вот пример для того, чтобы вы поняли, что необходимо, чтобы получить SHA-1 коллизию. Если бы все 6.5 миллиардов людей на Земле программировали и каждую секунду каждый из них производил количество кода, эквивалентное всей истории ядра Linux (1 миллион Git-объектов) и отправлял его в один огромный Git-репозиторий, то потребовалось бы 5 лет для того, чтобы заполнить репозиторий достаточно для того, чтобы получить 50% вероятность единичной SHA-1 коллизии. Более вероятно, что каждый член вашей команды программистов будет атакован и убит волками в несвязанных друг с другом случаях в одну и ту же ночь.</p>
<p id="calibre_link-147"><span><span><b>Ссылки на ветки</b></span></span></p>
<p>Для самого прямого метода указать коммит необходимо, чтобы этот коммит имел ветку, ссылающуюся на него. Тогда вы можете использовать имя ветки в любой команде Git'а, которая ожидает коммит или значение SHA-1. Например, если вы хотите посмотреть последний коммит в ветке, следующие команды эквивалентны, предполагая, что ветка <tt>topic1</tt> ссылается на <tt>ca82a6d</tt>:</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;ca82a6dff817ec66f44342007202690a93763949<br></br>$&nbsp;git&nbsp;show&nbsp;topic1<br></br></tt></p>
<p>Чтобы посмотреть, на какой именно SHA указывает ветка, или понять для какого-то из приведённых примеров, к каким SHA он сводится, можно использовать служебную (plumbing) утилиту Git'а, которая называется <tt>rev-parse</tt>. Вы можете заглянуть в главу 9 для получения более подробной информации о служебных утилитах; в основном <tt>rev-parse</tt> нужна для выполнения низкоуровневых операций и не предназначена для использования в повседневной работе. Однако, она может пригодиться, если вам необходимо разобраться, что происходит на самом деле. Сейчас вы можете попробовать применить <tt>rev-parse</tt> к своей ветке.</p>
<p><tt>$&nbsp;git&nbsp;rev-parse&nbsp;topic1<br></br>ca82a6dff817ec66f44342007202690a93763949<br></br></tt></p>
<p id="calibre_link-148"><span><span><b>RefLog-сокращения</b></span></span></p>
<p>Одна из вещей, которую Git делает в фоновом режиме, пока вы работаете, это запоминание ссылочного лога &mdash; лога того, где находились HEAD и ветки в течение последних нескольких месяцев.</p>
<p>Ссылочный лог можно просмотреть с помощью <tt>git reflog</tt>:</p>
<p><tt>$&nbsp;git&nbsp;reflog<br></br>734713b...&nbsp;HEAD@{0}:&nbsp;commit:&nbsp;fixed&nbsp;refs&nbsp;handling,&nbsp;added&nbsp;gc&nbsp;auto,&nbsp;updated<br></br>d921970...&nbsp;HEAD@{1}:&nbsp;merge&nbsp;phedders/rdocs:&nbsp;Merge&nbsp;made&nbsp;by&nbsp;recursive.<br></br>1c002dd...&nbsp;HEAD@{2}:&nbsp;commit:&nbsp;added&nbsp;some&nbsp;blame&nbsp;and&nbsp;merge&nbsp;stuff<br></br>1c36188...&nbsp;HEAD@{3}:&nbsp;rebase&nbsp;-i&nbsp;(squash):&nbsp;updating&nbsp;HEAD<br></br>95df984...&nbsp;HEAD@{4}:&nbsp;commit:&nbsp;#&nbsp;This&nbsp;is&nbsp;a&nbsp;combination&nbsp;of&nbsp;two&nbsp;commits.<br></br>1c36188...&nbsp;HEAD@{5}:&nbsp;rebase&nbsp;-i&nbsp;(squash):&nbsp;updating&nbsp;HEAD<br></br>7e05da5...&nbsp;HEAD@{6}:&nbsp;rebase&nbsp;-i&nbsp;(pick):&nbsp;updating&nbsp;HEAD<br></br></tt></p>
<p>Каждый раз, когда верхушка ветки обновляется по какой-либо причине, Git сохраняет информацию об этом в эту временную историю. И вы можете использовать и эти данные для задания старых коммитов. Если вы хотите посмотреть, какое значение было у HEAD в вашем репозитории пять шагов назад, используйте ссылку вида <tt>@{n}</tt> так же, как показано в выводе команды <tt>reflog</tt>:</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;HEAD@{5}<br></br></tt></p>
<p>Также вы можете использовать эту команду, чтобы увидеть, где ветка была некоторое время назад. Например, чтобы увидеть, где была ветка <tt>master</tt> вчера, наберите</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;master@{yesterday}<br></br></tt></p>
<p>Эта команда покажет, где верхушка ветки находилась вчера. Такой подход работает только для данных, которые всё ещё находятся в ссылочном логе. Так что вы не сможете использовать его для коммитов с давностью в несколько месяцев.</p>
<p>Чтобы просмотреть информацию ссылочного лога в таком же формате, как вывод <tt>git log</tt>, можно выполнить <tt>git log -g</tt>:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-g&nbsp;master<br></br>commit&nbsp;734713bc047d87bf7eac9674765ae793478c50d3<br></br>Reflog:&nbsp;master@{0}&nbsp;(Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;)<br></br>Reflog&nbsp;message:&nbsp;commit:&nbsp;fixed&nbsp;refs&nbsp;handling,&nbsp;added&nbsp;gc&nbsp;auto,&nbsp;updated&nbsp;<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Jan&nbsp;2&nbsp;18:32:33&nbsp;2009&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;fixed&nbsp;refs&nbsp;handling,&nbsp;added&nbsp;gc&nbsp;auto,&nbsp;updated&nbsp;tests<br></br><br></br>commit&nbsp;d921970aadf03b3cf0e71becdaab3147ba71cdef<br></br>Reflog:&nbsp;master@{1}&nbsp;(Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;)<br></br>Reflog&nbsp;message:&nbsp;merge&nbsp;phedders/rdocs:&nbsp;Merge&nbsp;made&nbsp;by&nbsp;recursive.<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Dec&nbsp;11&nbsp;15:08:43&nbsp;2008&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Merge&nbsp;commit&nbsp;'phedders/rdocs'<br></br></tt></p>
<p>Важно отметить, что информация в ссылочном логе строго локальная &mdash; это лог того, чем вы занимались со своим репозиторием. Ссылки не будут теми же самыми в чьей-то чужой копии репозитория; и после того как вы только что склонировали репозиторий, ссылочный лог будет пустым, так как вы ещё ничего не делали со своим репозиторием. Команда <tt>git show HEAD@{2.months.ago}</tt> сработает, только если вы склонировали свой проект как минимум два месяца назад. Если вы склонировали его пять минут назад, то вы ничего не получите.</p>
<p id="calibre_link-149"><span><span><b>Ссылки на предков</b></span></span></p>
<p>Ещё один основной способ указать коммит &mdash; указать коммит через его предков. Если поставить <tt>^</tt> в конце ссылки, для Git'а это будет означать родителя этого коммита. Допустим, история вашего проекта выглядит следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=format:'%h&nbsp;%s'&nbsp;--graph<br></br>*&nbsp;734713b&nbsp;fixed&nbsp;refs&nbsp;handling,&nbsp;added&nbsp;gc&nbsp;auto,&nbsp;updated&nbsp;tests<br></br>*&nbsp;&nbsp;&nbsp;d921970&nbsp;Merge&nbsp;commit&nbsp;'phedders/rdocs'<br></br>|\&nbsp;&nbsp;<br></br>|&nbsp;*&nbsp;35cfb2b&nbsp;Some&nbsp;rdoc&nbsp;changes<br></br>*&nbsp;|&nbsp;1c002dd&nbsp;added&nbsp;some&nbsp;blame&nbsp;and&nbsp;merge&nbsp;stuff<br></br>|/&nbsp;&nbsp;<br></br>*&nbsp;1c36188&nbsp;ignore&nbsp;*.gem<br></br>*&nbsp;9b29157&nbsp;add&nbsp;open3_detach&nbsp;to&nbsp;gemspec&nbsp;file&nbsp;list<br></br></tt></p>
<p>В этом случае вы можете посмотреть предыдущий коммит, указав <tt>HEAD^</tt>, что означает "родитель HEAD":</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;HEAD^<br></br>commit&nbsp;d921970aadf03b3cf0e71becdaab3147ba71cdef<br></br>Merge:&nbsp;1c002dd...&nbsp;35cfb2b...<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Dec&nbsp;11&nbsp;15:08:43&nbsp;2008&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Merge&nbsp;commit&nbsp;'phedders/rdocs'<br></br></tt></p>
<p>Вы также можете указать некоторое число после <tt>^</tt>. Например, <tt>d921970^2</tt> означает "второй родитель коммита d921970". Такой синтаксис полезен только для коммитов-слияний, которые имеют больше, чем одного родителя. Первый родитель &mdash; это ветка, на которой вы находились во время слияния, а второй &mdash; коммит на ветке, которая была слита:</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;d921970^<br></br>commit&nbsp;1c002dd4b536e7479fe34593e72e6c6c1819e53b<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Dec&nbsp;11&nbsp;14:58:32&nbsp;2008&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;added&nbsp;some&nbsp;blame&nbsp;and&nbsp;merge&nbsp;stuff<br></br><br></br>$&nbsp;git&nbsp;show&nbsp;d921970^2<br></br>commit&nbsp;35cfb2b795a55793d7cc56a6cc2060b4bb732548<br></br>Author:&nbsp;Paul&nbsp;Hedderly&nbsp;&lt;paul+git@mjr.org&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Wed&nbsp;Dec&nbsp;10&nbsp;22:22:03&nbsp;2008&nbsp;+0000<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Some&nbsp;rdoc&nbsp;changes<br></br></tt></p>
<p>Другое основное обозначение для указания на предков &mdash; это <tt>~</tt>. Это тоже ссылка на первого родителя, поэтому <tt>HEAD~</tt> и <tt>HEAD^</tt> эквивалентны. Различия становятся очевидными, только когда вы указываете число. <tt>HEAD~2</tt> означает первого родителя первого родителя HEAD или прародителя &mdash; это переход по первым родителям указанное количество раз. Например, для показанной выше истории, <tt>HEAD~3</tt> будет</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;HEAD~3<br></br>commit&nbsp;1c3618887afb5fbcbea25b7c013f4e2114448b8d<br></br>Author:&nbsp;Tom&nbsp;Preston-Werner&nbsp;&lt;tom@mojombo.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Nov&nbsp;7&nbsp;13:47:59&nbsp;2008&nbsp;-0500<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;ignore&nbsp;*.gem<br></br></tt></p>
<p>То же самое можно записать как <tt>HEAD^^^</tt>, что опять же означает первого родителя первого родителя первого родителя:</p>
<p><tt>$&nbsp;git&nbsp;show&nbsp;HEAD^^^<br></br>commit&nbsp;1c3618887afb5fbcbea25b7c013f4e2114448b8d<br></br>Author:&nbsp;Tom&nbsp;Preston-Werner&nbsp;&lt;tom@mojombo.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;Nov&nbsp;7&nbsp;13:47:59&nbsp;2008&nbsp;-0500<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;ignore&nbsp;*.gem<br></br></tt></p>
<p>Кроме того, можно комбинировать эти обозначения. Например, можно получить второго родителя для предыдущей ссылки (мы предполагаем, что это коммит-слияние) написав <tt>HEAD~3^2</tt>, ну и так далее.</p>
<p id="calibre_link-150"><span><span><b>Диапазон коммитов</b></span></span></p>
<p>Теперь, когда вы умеете задавать отдельные коммиты, разберёмся, как указать диапазон коммитов. Это особенно полезно при управлении ветками &mdash; если у вас много веток, вы можете использовать обозначения диапазонов, чтобы ответить на вопросы типа "Какие в этой ветке есть коммиты, которые не были слиты в основную ветку?"</p>
<p><span><b>Две точки</b></span></p>
<p>Наиболее распространённый способ задать диапазон коммитов &mdash; это запись с двумя точками. По существу, таким образом вы просите Git взять набор коммитов, достижимых из одного коммита, но не достижимых из другого. Например, пускай ваша история коммитов выглядит так, как показано на рисунке 6-1.</p>
<p><img src="images/000008.jpg"></img></p>
<p>Допустим, вы хотите посмотреть, что в вашей ветке <tt>experiment</tt> ещё не было слито в ветку <tt>master</tt>. Можно попросить Git показать вам лог только таких коммитов с помощью <tt>master..experiment</tt> &mdash; эта запись означает "все коммиты, достижимые из experiment, которые недостижимы из master". Для краткости и большей понятности в примерах мы будем использовать буквы для обозначения коммитов на диаграмме вместо настоящего вывода лога в том порядке, в каком они будут отображены:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;master..experiment<br></br>D<br></br>C<br></br></tt></p>
<p>С другой стороны, если вы хотите получить обратное &mdash; все коммиты в <tt>master</tt>, которых нет в <tt>experiment</tt>, можно переставить имена веток. Запись <tt>experiment..master</tt> покажет всё, что есть в <tt>master</tt>, но недостижимо из <tt>experiment</tt>:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;experiment..master<br></br>F<br></br>E<br></br></tt></p>
<p>Такое полезно, если вы хотите, чтобы ветка <tt>experiment</tt> была обновлённой, и хотите посмотреть, что вы собираетесь в неё слить. Ещё один частый случай использования этого синтаксиса &mdash; посмотреть, что вы собираетесь отправить на удалённый сервер:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;origin/master..HEAD<br></br></tt></p>
<p>Эта команда покажет вам все коммиты в текущей ветке, которых нет в ветке <tt>master</tt> на сервере <tt>origin</tt>. Если бы вы выполнили <tt>git push</tt>, при условии, что текущая ветка отслеживает <tt>origin/master</tt>, то коммиты, которые перечислены в выводе <tt>git log origin/master..HEAD</tt> это те коммиты, которые были бы отправлены на сервер. Кроме того, можно опустить одну из сторон в такой записи &mdash; Git подставит туда HEAD. Например, вы можете получить такой же результат, как и в предыдущем примере, набрав <tt>git log origin/master..</tt> &mdash; Git подставит HEAD сам, если одна из сторон отсутствует.</p>
<p><span><b>Множество вершин</b></span></p>
<p>Запись с двумя точками полезна как сокращение, но, возможно, вы захотите указать больше двух веток, чтобы указать нужную ревизию. Например, чтобы посмотреть, какие коммиты находятся в одной из нескольких веток, но не в текущей. Git позволяет сделать это с помощью использования либо символа <tt>^</tt>, либо <tt>--not</tt> перед любыми ссылками, коммиты, достижимые из которых, вы не хотите видеть. Таким образом, следующие три команды эквивалентны:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;refA..refB<br></br>$&nbsp;git&nbsp;log&nbsp;^refA&nbsp;refB<br></br>$&nbsp;git&nbsp;log&nbsp;refB&nbsp;--not&nbsp;refA<br></br></tt></p>
<p>Это удобно, потому что с помощью такого синтаксиса можно указать более двух ссылок в своём запросе, чего вы не сможете сделать с помощью двух точек. Например, если вы хотите увидеть все коммиты достижимые из <tt>refA</tt> или <tt>refB</tt>, но не из <tt>refC</tt>, можно набрать одну из таких команд:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;refA&nbsp;refB&nbsp;^refC<br></br>$&nbsp;git&nbsp;log&nbsp;refA&nbsp;refB&nbsp;--not&nbsp;refC<br></br></tt></p>
<p>Всё это делает систему выбора ревизий очень мощной, что должно помочь вам определять, что содержится в ваших ветках.</p>
<p><span><b>Три точки</b></span></p>
<p>Последняя основная запись для выбора диапазона коммитов &mdash; это запись с тремя точками, которая означает те коммиты, которые достижимы по одной из двух ссылок, но не по обеим одновременно. Вернёмся к примеру истории коммитов на рисунке 6-1. Если вы хотите увидеть, что находится в <tt>master</tt> или <tt>experiment</tt>, но не в обоих сразу, выполните</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;master...experiment<br></br>F<br></br>E<br></br>D<br></br>C<br></br></tt></p>
<p>Повторимся, что это даст вам стандартный <tt>log</tt>-вывод, но покажет только информацию об этих четырёх коммитах, упорядоченных по дате коммита, как и обычно.</p>
<p>В этом случае вместе с командой <tt>log</tt> обычно используют параметр <tt>--left-right</tt>, который показывает, на какой стороне диапазона находится каждый коммит. Это помогает сделать данные полезнее:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--left-right&nbsp;master...experiment<br></br>&lt;&nbsp;F<br></br>&lt;&nbsp;E<br></br>&gt;&nbsp;D<br></br>&gt;&nbsp;C<br></br></tt></p>
<p>С помощью этих инструментов вы можете намного легче объяснить Git'у, какой коммит или коммиты вы хотите изучить.</p>
<div></div><p id="calibre_link-151"><span><span><b>Интерактивное индексирование</b></span></span></p>
<p>Вместе с Git'ом поставляется пара сценариев (script), облегчающих выполнение некоторых задач в командной строке. Сейчас мы посмотрим на несколько интерактивных команд, которые помогут вам легко смастерить свои коммиты так, чтобы включить в них только определённые части файлов. Эти инструменты сильно помогают в случае, когда вы поменяли кучу файлов, а потом решили, что хотите, чтобы эти изменения были в нескольких сфокусированных коммитах, а не в одном большом путанном коммите. Так вы сможете убедиться, что ваши коммиты &mdash; это логически разделённые наборы изменений, которые будет легко просматривать другим разработчикам, работающим с вами. Если вы выполните <tt>git add</tt> с опцией <tt>-i</tt> или <tt>--interactive</tt>, Git перейдёт в режим интерактивной оболочки и покажет что-то похожее на это:</p>
<p><tt>$&nbsp;git&nbsp;add&nbsp;-i<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unstaged&nbsp;path<br></br>&nbsp;&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0/-1&nbsp;TODO<br></br>&nbsp;&nbsp;2:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1/-1&nbsp;index.html<br></br>&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+5/-1&nbsp;lib/simplegit.rb<br></br><br></br>***&nbsp;Commands&nbsp;***<br></br>&nbsp;&nbsp;1:&nbsp;status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;revert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;add&nbsp;untracked<br></br>&nbsp;&nbsp;5:&nbsp;patch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6:&nbsp;diff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7:&nbsp;quit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;help<br></br>What&nbsp;now&gt;&nbsp;<br></br></tt></p>
<p>Как видите, эта команда показывает содержимое индекса, но в другом виде &mdash; по сути, ту же информацию вы получили бы при вызове <tt>git status</tt>, но здесь она в более сжатом и информативном виде. <tt>git add -i</tt> показывает проиндексированные изменения слева, а непроиндексированные &mdash; справа.</p>
<p>Затем идёт раздел Commands (команды). Тут можно сделать многие вещи, включая добавление файлов в индекс, удаление файлов из индекса, индексирование файлов частями, добавление неотслеживаемых файлов и просмотр дельт (diff) проиндексированных изменений.</p>
<p id="calibre_link-152"><span><span><b>Добавление и удаление файлов из индекса</b></span></span></p>
<p>Если набрать <tt>2</tt> или <tt>u</tt> в приглашении <tt>What now&gt;</tt>, сценарий спросит, какие файлы вы хотите добавить в индекс:</p>
<p><tt>What&nbsp;now&gt;&nbsp;2<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unstaged&nbsp;path<br></br>&nbsp;&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0/-1&nbsp;TODO<br></br>&nbsp;&nbsp;2:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1/-1&nbsp;index.html<br></br>&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+5/-1&nbsp;lib/simplegit.rb<br></br>Update&gt;&gt;<br></br></tt></p>
<p>Чтобы проиндексировать файлы TODO и index.html, нужно набрать их номера:</p>
<p><tt>Update&gt;&gt;&nbsp;1,2<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unstaged&nbsp;path<br></br>*&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0/-1&nbsp;TODO<br></br>*&nbsp;2:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1/-1&nbsp;index.html<br></br>&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+5/-1&nbsp;lib/simplegit.rb<br></br>Update&gt;&gt;<br></br></tt></p>
<p>Символ <tt>*</tt> рядом с каждым файлом означает, что файл выбран для индексирования. Если вы сейчас ничего не будете вводить, а нажмёте Enter в приглашении <tt>Update&gt;&gt;</tt>, то Git возьмёт всё, что уже выбрано, и добавит в индекс:</p>
<p><tt>Update&gt;&gt;&nbsp;<br></br>updated&nbsp;2&nbsp;paths<br></br><br></br>***&nbsp;Commands&nbsp;***<br></br>&nbsp;&nbsp;1:&nbsp;status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;revert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;add&nbsp;untracked<br></br>&nbsp;&nbsp;5:&nbsp;patch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6:&nbsp;diff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7:&nbsp;quit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;help<br></br>What&nbsp;now&gt;&nbsp;1<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unstaged&nbsp;path<br></br>&nbsp;&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0/-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nothing&nbsp;TODO<br></br>&nbsp;&nbsp;2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1/-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nothing&nbsp;index.html<br></br>&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+5/-1&nbsp;lib/simplegit.rb<br></br></tt></p>
<p>Как видите, теперь файлы TODO и index.html проиндексированы (staged), а файл simplegit.rb &mdash; всё ещё нет. Если в этот момент вы хотите удалить файл TODO из индекса, используйте опцию <tt>3</tt> или <tt>r</tt> (revert):</p>
<p><tt>***&nbsp;Commands&nbsp;***<br></br>&nbsp;&nbsp;1:&nbsp;status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;revert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;add&nbsp;untracked<br></br>&nbsp;&nbsp;5:&nbsp;patch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6:&nbsp;diff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7:&nbsp;quit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;help<br></br>What&nbsp;now&gt;&nbsp;3<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unstaged&nbsp;path<br></br>&nbsp;&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0/-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nothing&nbsp;TODO<br></br>&nbsp;&nbsp;2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1/-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nothing&nbsp;index.html<br></br>&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+5/-1&nbsp;lib/simplegit.rb<br></br>Revert&gt;&gt;&nbsp;1<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unstaged&nbsp;path<br></br>*&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0/-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nothing&nbsp;TODO<br></br>&nbsp;&nbsp;2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1/-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nothing&nbsp;index.html<br></br>&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+5/-1&nbsp;lib/simplegit.rb<br></br>Revert&gt;&gt;&nbsp;[enter]<br></br>reverted&nbsp;one&nbsp;path<br></br></tt></p>
<p>Взглянув на статус снова, вы увидите, что файл TODO удалён из индекса:</p>
<p><tt>***&nbsp;Commands&nbsp;***<br></br>&nbsp;&nbsp;1:&nbsp;status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;revert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;add&nbsp;untracked<br></br>&nbsp;&nbsp;5:&nbsp;patch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6:&nbsp;diff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7:&nbsp;quit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;help<br></br>What&nbsp;now&gt;&nbsp;1<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unstaged&nbsp;path<br></br>&nbsp;&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0/-1&nbsp;TODO<br></br>&nbsp;&nbsp;2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1/-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nothing&nbsp;index.html<br></br>&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+5/-1&nbsp;lib/simplegit.rb<br></br></tt></p>
<p>Чтобы посмотреть дельту для проиндексированных изменений, используйте команду <tt>6</tt> или <tt>d</tt> (diff). Она покажет вам список проиндексированных файлов, и вы сможете выбрать те, для которых хотите посмотреть дельту. Это почти то же, что указать <tt>git diff --cached</tt> в командной строке:</p>
<p><tt>***&nbsp;Commands&nbsp;***<br></br>&nbsp;&nbsp;1:&nbsp;status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;update&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;revert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;add&nbsp;untracked<br></br>&nbsp;&nbsp;5:&nbsp;patch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6:&nbsp;diff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7:&nbsp;quit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;help<br></br>What&nbsp;now&gt;&nbsp;6<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unstaged&nbsp;path<br></br>&nbsp;&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1/-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nothing&nbsp;index.html<br></br>Review&nbsp;diff&gt;&gt;&nbsp;1<br></br>diff&nbsp;--git&nbsp;a/index.html&nbsp;b/index.html<br></br>index&nbsp;4d07108..4335f49&nbsp;100644<br></br>---&nbsp;a/index.html<br></br>+++&nbsp;b/index.html<br></br>@@&nbsp;-16,7&nbsp;+16,7&nbsp;@@&nbsp;Date&nbsp;Finder<br></br><br></br>&nbsp;&lt;p&nbsp;id="out"&gt;...&lt;/p&gt;<br></br><br></br>-&lt;div&nbsp;id="footer"&gt;contact&nbsp;:&nbsp;support@github.com&lt;/div&gt;<br></br>+&lt;div&nbsp;id="footer"&gt;contact&nbsp;:&nbsp;email.support@github.com&lt;/div&gt;<br></br><br></br>&nbsp;&lt;script&nbsp;type="text/javascript"&gt;<br></br></tt></p>
<p>С помощью этих базовых команд вы можете использовать интерактивный режим для <tt>git add</tt>, чтобы немного проще работать со своим индексом.</p>
<p id="calibre_link-153"><span><span><b>Индексирование по частям</b></span></span></p>
<p>Для Git'а также возможно индексировать определённые части файлов, а не всё сразу. Например, если вы сделали несколько изменений в файле simplegit.rb и хотите проиндексировать одно из них, а другое &mdash; нет, то сделать такое в Git'е очень легко. В строке приглашения интерактивного режима наберите <tt>5</tt> или <tt>p</tt> (patch). Git спросит, какие файлы вы хотите индексировать частями; затем для каждой части изменений в выбранных файлах один за другим будут показываться куски дельт файла, и вас будут спрашивать, хотите ли вы занести их в индекс:</p>
<p><tt>diff&nbsp;--git&nbsp;a/lib/simplegit.rb&nbsp;b/lib/simplegit.rb<br></br>index&nbsp;dd5ecc4..57399e0&nbsp;100644<br></br>---&nbsp;a/lib/simplegit.rb<br></br>+++&nbsp;b/lib/simplegit.rb<br></br>@@&nbsp;-22,7&nbsp;+22,7&nbsp;@@&nbsp;class&nbsp;SimpleGit<br></br>&nbsp;&nbsp;&nbsp;end<br></br><br></br>&nbsp;&nbsp;&nbsp;def&nbsp;log(treeish&nbsp;=&nbsp;'master')<br></br>-&nbsp;&nbsp;&nbsp;&nbsp;command("git&nbsp;log&nbsp;-n&nbsp;25&nbsp;#{treeish}")<br></br>+&nbsp;&nbsp;&nbsp;&nbsp;command("git&nbsp;log&nbsp;-n&nbsp;30&nbsp;#{treeish}")<br></br>&nbsp;&nbsp;&nbsp;end<br></br><br></br>&nbsp;&nbsp;&nbsp;def&nbsp;blame(path)<br></br>Stage&nbsp;this&nbsp;hunk&nbsp;[y,n,a,d,/,j,J,g,e,?]?&nbsp;<br></br></tt></p>
<p>На этой стадии у вас много вариантов действий. Набрав <tt>?</tt>, вы получите список возможных действий:</p>
<p><tt>Stage&nbsp;this&nbsp;hunk&nbsp;[y,n,a,d,/,j,J,g,e,?]?&nbsp;?<br></br>y&nbsp;-&nbsp;stage&nbsp;this&nbsp;hunk&nbsp;(добавить&nbsp;этот&nbsp;кусок&nbsp;в&nbsp;индекс)<br></br>n&nbsp;-&nbsp;do&nbsp;not&nbsp;stage&nbsp;this&nbsp;hunk&nbsp;(не&nbsp;добавлять&nbsp;этот&nbsp;кусок&nbsp;в&nbsp;индекс)<br></br>a&nbsp;-&nbsp;stage&nbsp;this&nbsp;and&nbsp;all&nbsp;the&nbsp;remaining&nbsp;hunks&nbsp;in&nbsp;the&nbsp;file&nbsp;(добавить&nbsp;этот&nbsp;и&nbsp;все&nbsp;оставшиеся&nbsp;куски&nbsp;в&nbsp;этом&nbsp;файле&nbsp;в&nbsp;индекс)<br></br>d&nbsp;-&nbsp;do&nbsp;not&nbsp;stage&nbsp;this&nbsp;hunk&nbsp;nor&nbsp;any&nbsp;of&nbsp;the&nbsp;remaining&nbsp;hunks&nbsp;in&nbsp;the&nbsp;file&nbsp;(не&nbsp;добавлять&nbsp;в&nbsp;индекс&nbsp;ни&nbsp;этот,&nbsp;ни&nbsp;последующие&nbsp;куски&nbsp;в&nbsp;этом&nbsp;файле)<br></br>g&nbsp;-&nbsp;select&nbsp;a&nbsp;hunk&nbsp;to&nbsp;go&nbsp;to&nbsp;(выбрать&nbsp;кусок&nbsp;и&nbsp;перейти&nbsp;к&nbsp;нему)<br></br>/&nbsp;-&nbsp;search&nbsp;for&nbsp;a&nbsp;hunk&nbsp;matching&nbsp;the&nbsp;given&nbsp;regex&nbsp;(поиск&nbsp;куска&nbsp;по&nbsp;регулярному&nbsp;выражению)<br></br>j&nbsp;-&nbsp;leave&nbsp;this&nbsp;hunk&nbsp;undecided,&nbsp;see&nbsp;next&nbsp;undecided&nbsp;hunk&nbsp;(отложить&nbsp;решение&nbsp;для&nbsp;этого&nbsp;куска,&nbsp;перейти&nbsp;к&nbsp;следующему&nbsp;отложенному&nbsp;куску)<br></br>J&nbsp;-&nbsp;leave&nbsp;this&nbsp;hunk&nbsp;undecided,&nbsp;see&nbsp;next&nbsp;hunk&nbsp;(отложить&nbsp;решение&nbsp;для&nbsp;этого&nbsp;куска,&nbsp;перейти&nbsp;к&nbsp;следующему&nbsp;куску)<br></br>k&nbsp;-&nbsp;leave&nbsp;this&nbsp;hunk&nbsp;undecided,&nbsp;see&nbsp;previous&nbsp;undecided&nbsp;hunk&nbsp;(отложить&nbsp;решение&nbsp;для&nbsp;этого&nbsp;куска,&nbsp;перейти&nbsp;к&nbsp;предыдущему&nbsp;отложенному&nbsp;куску)<br></br>K&nbsp;-&nbsp;leave&nbsp;this&nbsp;hunk&nbsp;undecided,&nbsp;see&nbsp;previous&nbsp;hunk&nbsp;(отложить&nbsp;решение&nbsp;для&nbsp;этого&nbsp;куска,&nbsp;перейти&nbsp;к&nbsp;предыдущему&nbsp;куску)<br></br>s&nbsp;-&nbsp;split&nbsp;the&nbsp;current&nbsp;hunk&nbsp;into&nbsp;smaller&nbsp;hunks&nbsp;(разбить&nbsp;текущий&nbsp;кусок&nbsp;на&nbsp;меньшие&nbsp;части)<br></br>e&nbsp;-&nbsp;manually&nbsp;edit&nbsp;the&nbsp;current&nbsp;hunk&nbsp;(отредактировать&nbsp;текущий&nbsp;кусок&nbsp;вручную)<br></br>?&nbsp;-&nbsp;print&nbsp;help&nbsp;(вывести&nbsp;справку)<br></br></tt></p>
<p>Как правило, вы будете использовать <tt>y</tt> или <tt>n</tt> для индексирования каждого куска, но индексирование всех кусков сразу в некоторых файлах или откладывание решения на потом также может оказаться полезным. Если вы добавите в индекс одну часть файла, а другую часть &mdash; нет, вывод статуса будет выглядеть так:</p>
<p><tt>What&nbsp;now&gt;&nbsp;1<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unstaged&nbsp;path<br></br>&nbsp;&nbsp;1:&nbsp;&nbsp;&nbsp;&nbsp;unchanged&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0/-1&nbsp;TODO<br></br>&nbsp;&nbsp;2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1/-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nothing&nbsp;index.html<br></br>&nbsp;&nbsp;3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1/-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+4/-0&nbsp;lib/simplegit.rb<br></br></tt></p>
<p>Статус файла simplegit.rb выглядит любопытно. Он показывает, что часть строк в индексе, а часть &mdash; не в индексе. Мы частично проиндексировали этот файл. Теперь вы можете выйти из интерактивного сценария и выполнить <tt>git commit</tt>, чтобы создать коммит из этих частично проиндексированных файлов.</p>
<p>В заключение скажем, что нет необходимости входить в интерактивный режим <tt>git add</tt>, чтобы выполнять индексирование частями &mdash; вы можете запустить тот же сценарий, набрав <tt>git add -p</tt> или <tt>git add --patch</tt> в командной строке.</p>
<div></div><p id="calibre_link-154"><span><span><b>Прятанье</b></span></span></p>
<p>Часто возникает такая ситуация, что пока вы работаете над частью своего проекта, всё находится в беспорядочном состоянии, а вам нужно переключить ветки, чтобы немного поработать над чем-то другим. Проблема в том, что вы не хотите делать коммит с наполовину доделанной работой только для того, чтобы позже можно было вернуться в это же состояние. Ответ на эту проблему &mdash; команда <tt>git stash</tt>.</p>
<p>Прятанье поглощает грязное состояние рабочего каталога, то есть изменённые отслеживаемые файлы и изменения в индексе, и сохраняет их в стек незавершённых изменений, которые вы потом в любое время можете снова применить.</p>
<p id="calibre_link-155"><span><span><b>Прятанье своих трудов</b></span></span></p>
<p>Чтобы продемонстрировать, как это работает, предположим, что вы идёте к своему проекту и начинаете работать над парой файлов и, возможно, добавляете в индекс одно из изменений. Если вы выполните <tt>git status</tt>, вы увидите грязное состояние проекта:</p>
<p><tt>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;index.html<br></br>#<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;lib/simplegit.rb<br></br>#<br></br></tt></p>
<p>Теперь вы хотите поменять ветку, но не хотите делать коммит с тем, над чем вы ещё работаете; тогда вы прячете эти изменения. Чтобы создать новую "заначку", выполните <tt>git stash</tt>:</p>
<p><tt>$&nbsp;git&nbsp;stash<br></br>Saved&nbsp;working&nbsp;directory&nbsp;and&nbsp;index&nbsp;state&nbsp;\<br></br>&nbsp;&nbsp;"WIP&nbsp;on&nbsp;master:&nbsp;049d078&nbsp;added&nbsp;the&nbsp;index&nbsp;file"<br></br>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;049d078&nbsp;added&nbsp;the&nbsp;index&nbsp;file<br></br>(To&nbsp;restore&nbsp;them&nbsp;type&nbsp;"git&nbsp;stash&nbsp;apply")<br></br></tt></p>
<p>Ваш рабочий каталог чист:</p>
<p><tt>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>nothing&nbsp;to&nbsp;commit&nbsp;(working&nbsp;directory&nbsp;clean)<br></br></tt></p>
<p>В данный момент вы легко можете переключить ветки и поработать где-то ещё; ваши изменения сохранены в стеке. Чтобы посмотреть, что у вас есть припрятанного, используйте <tt>git stash list</tt>:</p>
<p><tt>$&nbsp;git&nbsp;stash&nbsp;list<br></br>stash@{0}:&nbsp;WIP&nbsp;on&nbsp;master:&nbsp;049d078&nbsp;added&nbsp;the&nbsp;index&nbsp;file<br></br>stash@{1}:&nbsp;WIP&nbsp;on&nbsp;master:&nbsp;c264051...&nbsp;Revert&nbsp;"added&nbsp;file_size"<br></br>stash@{2}:&nbsp;WIP&nbsp;on&nbsp;master:&nbsp;21d80a5...&nbsp;added&nbsp;number&nbsp;to&nbsp;log<br></br></tt></p>
<p>В нашем случае две "заначки" были сделаны ранее, так что у вас теперь три разных припрятанных работы. Вы можете снова применить ту, которую только что спрятали, с помощью команды, показанной в справке в выводе первоначальной команды <tt>stash</tt>: <tt>git stash apply</tt>. Если вы хотите применить одну из старых заначек, можете сделать это, указав её имя так: <tt>git stash apply stash@{2}</tt>. Если не указывать ничего, Git будет подразумевать, что вы хотите применить последнюю спрятанную работу:</p>
<p><tt>$&nbsp;git&nbsp;stash&nbsp;apply<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;index.html<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;lib/simplegit.rb<br></br>#<br></br></tt></p>
<p>Как видите, Git восстановил изменения в файлах, которые вы отменили, когда использовали команду <tt>stash</tt>. В нашем случае у вас был чистый рабочий каталог, когда вы восстанавливали спрятанные изменения, и к тому же вы делали это на той же ветке, на которой находились во время прятанья. Но наличие чистого рабочего каталога и применение на той же ветке не обязательны для <tt>git stash apply</tt>. Вы можете спрятать изменения на одной ветке, переключиться позже на другую ветку и попытаться восстановить изменения. У вас в рабочем каталоге также могут быть изменённые и недокоммиченные файлы во время применения спрятанного &mdash; Git выдаст вам конфликты слияния, если что-то уже не может быть применено чисто.</p>
<p>Изменения в файлах были восстановлены, но файлы в индексе &mdash; нет. Чтобы добиться такого, необходимо выполнить команду <tt>git stash apply</tt> с опцией <tt>--index</tt>, тогда команда попытается применить изменения в индексе. Если бы вы выполнили команду так, а не как раньше, то получили бы исходное состояние:</p>
<p><tt>$&nbsp;git&nbsp;stash&nbsp;apply&nbsp;--index<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;index.html<br></br>#<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;lib/simplegit.rb<br></br>#<br></br></tt></p>
<p>Всё, что делает опция apply &mdash; это пытается применить спрятанную работу &mdash; то, что вы спрятали, всё ещё будет находиться в стеке. Чтобы удалить спрятанное, выполните <tt>git stash drop</tt> с именем "заначки", которую нужно удалить:</p>
<p><tt>$&nbsp;git&nbsp;stash&nbsp;list<br></br>stash@{0}:&nbsp;WIP&nbsp;on&nbsp;master:&nbsp;049d078&nbsp;added&nbsp;the&nbsp;index&nbsp;file<br></br>stash@{1}:&nbsp;WIP&nbsp;on&nbsp;master:&nbsp;c264051...&nbsp;Revert&nbsp;"added&nbsp;file_size"<br></br>stash@{2}:&nbsp;WIP&nbsp;on&nbsp;master:&nbsp;21d80a5...&nbsp;added&nbsp;number&nbsp;to&nbsp;log<br></br>$&nbsp;git&nbsp;stash&nbsp;drop&nbsp;stash@{0}<br></br>Dropped&nbsp;stash@{0}&nbsp;(364e91f3f268f0900bc3ee613f9f733e82aaed43)<br></br></tt></p>
<p>Также можно выполнить <tt>git stash pop</tt>, чтобы применить спрятанные изменения и сразу же удалить их из стека.</p>
<p id="calibre_link-156"><span><span><b>Откат применения спрятанных изменений</b></span></span></p>
<p>При некоторых сценариях использования, может понадобиться применить спрятанные изменения, поработать, а потом отменить изменения, внесённые командой <tt>stash apply</tt>. Git не предоставляет команды <tt>stash unapply</tt>, но можно добиться того же эффекта получив сначала патч для спрятанных изменений, а потом применив его в перевёрнутом виде:</p>
<p><tt>$&nbsp;git&nbsp;stash&nbsp;show&nbsp;-p&nbsp;stash@{0}&nbsp;|&nbsp;git&nbsp;apply&nbsp;-R<br></br></tt></p>
<p>Снова, если вы не указываете параметр для <tt>stash</tt>, Git подразумевает то, что было спрятано последним:</p>
<p><tt>$&nbsp;git&nbsp;stash&nbsp;show&nbsp;-p&nbsp;|&nbsp;git&nbsp;apply&nbsp;-R<br></br></tt></p>
<p>Если хотите, сделайте псевдоним и добавьте в свой Git команду <tt>stash-unapply</tt>. Например, так:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;alias.stash-unapply&nbsp;'!git&nbsp;stash&nbsp;show&nbsp;-p&nbsp;|&nbsp;git&nbsp;apply&nbsp;-R'<br></br>$&nbsp;git&nbsp;stash<br></br>$&nbsp;#...&nbsp;work&nbsp;work&nbsp;work<br></br>$&nbsp;git&nbsp;stash-unapply<br></br></tt></p>
<p id="calibre_link-157"><span><span><b>Создание ветки из спрятанных изменений</b></span></span></p>
<p>Если вы спрятали какие-то наработки и оставили их на время, а в это время продолжили работать на той же ветке, то у вас могут возникнуть трудности с восстановлением спрятанной работы. Если <tt>apply</tt> попытается изменить файл, который вы редактировали после прятанья, то возникнет конфликт слияния, который надо будет разрешить. Если нужен более простой способ снова потестировать спрятанную работу, можно выполнить команду <tt>git stash branch</tt>, которая создаст вам новую ветку с началом из того коммита, на котором вы находились во время прятанья, восстановит в ней вашу работу и затем удалит спрятанное, если оно применилось успешно:</p>
<p><tt>$&nbsp;git&nbsp;stash&nbsp;branch&nbsp;testchanges<br></br>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;"testchanges"<br></br>#&nbsp;On&nbsp;branch&nbsp;testchanges<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;index.html<br></br>#<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;lib/simplegit.rb<br></br>#<br></br>Dropped&nbsp;refs/stash@{0}&nbsp;(f0dfc4d5dc332d1cee34a634182e168c4efc3359)<br></br></tt></p>
<p>Это сокращение удобно для того, чтобы легко восстановить свою работу, а затем поработать над ней в новой ветке.</p>
<div></div><p id="calibre_link-158"><span><span><b>Перезапись истории</b></span></span></p>
<p>Неоднократно во время работы с Git'ом, вам может захотеться по какой-либо причине исправить свою историю коммитов. Одна из чудесных особенностей Git'а заключается в том, что он даёт возможность принять решение в самый последний момент. Используя индекс, вы можете решить, какие файлы пойдут в какие коммиты, непосредственно перед тем, как сделать коммит. Вы можете воспользоваться командой <tt>stash</tt>, решив, что над чем-то ещё не стоило начинать работать. А также вы можете переписать уже сделанные коммиты так, будто они были сделаны как-то по-другому. В частности, это может быть изменение порядка следования коммитов, редактирование сообщений или модифицирование файлов в коммите, уплотнение и разделение коммитов, а также полное удаление некоторых коммитов &mdash; но только до того, как вы поделитесь наработками с другими.</p>
<p>В этом разделе вы узнаете, как делать подобные полезные вещи, чтобы перед публикацией приводить историю коммитов в желаемый вид.</p>
<p id="calibre_link-159"><span><span><b>Изменение последнего коммита</b></span></span></p>
<p>Изменение последнего коммита &mdash; это, вероятно, наиболее типичный случай переписывания истории, который вы будете делать. Как правило, вам от вашего последнего коммита понадобятся две основные вещи: изменить сообщение коммита или изменить только что записанный снимок состояния, добавив, изменив или удалив из него файлы.</p>
<p>Если вы всего лишь хотите изменить сообщение последнего коммита &mdash; это очень просто:</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;--amend<br></br></tt></p>
<p>Выполнив это, вы попадёте в свой текстовый редактор, в котором будет находиться сообщение последнего коммита, готовое к тому, чтобы его отредактировали. Когда вы сохраните текст и закроете редактор, Git создаст новый коммит с вашим сообщением и сделает его новым последним коммитом.</p>
<p>Если вы сделали коммит и затем хотите изменить снимок состояния в коммите, добавив или изменив файлы, допустим, потому что вы забыли добавить только что созданный файл, когда делали коммит, то процесс выглядит в основном так же. Вы добавляете в индекс изменения, которые хотите, редактируя файл и выполняя для него <tt>git add</tt> или выполняя <tt>git rm</tt> для отслеживаемого файла, и затем <tt>git commit --amend</tt> возьмёт текущий индекс и сделает его снимком состояния нового коммита.</p>
<p>Будьте осторожны, используя этот приём, потому что <tt>git commit --amend</tt> меняет SHA-1 коммита. Тут как с маленьким перемещением (rebase) &mdash; не правьте последний коммит, если вы его уже куда-то отправили.</p>
<p id="calibre_link-160"><span><span><b>Изменение сообщений нескольких коммитов</b></span></span></p>
<p>Чтобы изменить коммит, находящийся глубоко в истории, вам придётся перейти к использованию более сложных инструментов. В Git'е нет специального инструмента для редактирования истории, но вы можете использовать <tt>rebase</tt> для перемещения ряда коммитов на то же самое место, где они были изначально, а не куда-то в другое место. Используя инструмент для интерактивного перемещения, вы можете останавливаться на каждом коммите, который хотите изменить, и редактировать сообщение, добавлять файлы или делать что-то ещё. Интерактивное перемещение можно запустить, добавив опцию <tt>-i</tt> к <tt>git rebase</tt>. Необходимо указать, насколько далёкие в истории коммиты вы хотите переписать, сообщив команде, на какой коммит выполняется перемещение.</p>
<p>Например, если вы хотите изменить сообщения последних трёх коммитов или сообщения для только некоторых коммитов в этой группе, вам надо передать в <tt>git rebase -i</tt> в качестве аргумента родителя последнего коммита, который вы хотите изменить, то есть <tt>HEAD~2^</tt> или <tt>HEAD~3</tt>. Наверное, проще запомнить <tt>~3</tt>, потому что вы пытаетесь отредактировать три последних коммита, но имейте в виду, что на самом деле вы обозначили четвёртый сверху коммит &mdash; родительский коммит для того, который хотите отредактировать:</p>
<p><tt>$&nbsp;git&nbsp;rebase&nbsp;-i&nbsp;HEAD~3<br></br></tt></p>
<p>Снова напомним, что это команда для перемещения, то есть все коммиты в диапазоне <tt>HEAD~3..HEAD</tt> будут переписаны вне зависимости от того, меняли ли вы в них сообщение или нет. Не трогайте те коммиты, которые вы уже отправили на центральный сервер &mdash; сделав так, вы запутаете других разработчиков, дав им разные версии одних и тех же изменений.</p>
<p>Запуск этой команды выдаст вам в текстовом редакторе список коммитов, который будет выглядеть следующим образом:</p>
<p><tt>pick&nbsp;f7f3f6d&nbsp;changed&nbsp;my&nbsp;name&nbsp;a&nbsp;bit<br></br>pick&nbsp;310154e&nbsp;updated&nbsp;README&nbsp;formatting&nbsp;and&nbsp;added&nbsp;blame<br></br>pick&nbsp;a5f4a0d&nbsp;added&nbsp;cat-file<br></br><br></br>#&nbsp;Rebase&nbsp;710f0f8..a5f4a0d&nbsp;onto&nbsp;710f0f8<br></br>#<br></br>#&nbsp;Commands:<br></br>#&nbsp;&nbsp;p,&nbsp;pick&nbsp;=&nbsp;use&nbsp;commit<br></br>#&nbsp;&nbsp;e,&nbsp;edit&nbsp;=&nbsp;use&nbsp;commit,&nbsp;but&nbsp;stop&nbsp;for&nbsp;amending<br></br>#&nbsp;&nbsp;s,&nbsp;squash&nbsp;=&nbsp;use&nbsp;commit,&nbsp;but&nbsp;meld&nbsp;into&nbsp;previous&nbsp;commit<br></br>#<br></br>#&nbsp;If&nbsp;you&nbsp;remove&nbsp;a&nbsp;line&nbsp;here&nbsp;THAT&nbsp;COMMIT&nbsp;WILL&nbsp;BE&nbsp;LOST.<br></br>#&nbsp;However,&nbsp;if&nbsp;you&nbsp;remove&nbsp;everything,&nbsp;the&nbsp;rebase&nbsp;will&nbsp;be&nbsp;aborted.<br></br>#<br></br></tt></p>
<p>Важно отметить, что эти коммиты выведены в обратном порядке по сравнению с тем, как вы их обычно видите, используя команду <tt>log</tt>. Запустив <tt>log</tt>, вы получите что-то вроде этого:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=format:"%h&nbsp;%s"&nbsp;HEAD~3..HEAD<br></br>a5f4a0d&nbsp;added&nbsp;cat-file<br></br>310154e&nbsp;updated&nbsp;README&nbsp;formatting&nbsp;and&nbsp;added&nbsp;blame<br></br>f7f3f6d&nbsp;changed&nbsp;my&nbsp;name&nbsp;a&nbsp;bit<br></br></tt></p>
<p>Обратите внимание на обратный порядок. Интерактивное перемещение выдаёт сценарий, который будет выполнен. Он начнётся с коммита, который вы указали в командной строке (<tt>HEAD~3</tt>), и воспроизведёт изменения, сделанные каждым из этих коммитов, сверху вниз. Наверху указан самый старый коммит, а не самый новый, потому что он будет воспроизведён первым.</p>
<p>Вам надо отредактировать сценарий так, чтобы он останавливался на коммитах, которые вы хотите отредактировать. Чтобы сделать это, замените слово pick на слово edit для каждого коммита, на котором сценарий должен остановиться. Например, чтобы изменить сообщение только для третьего коммита, отредактируйте файл так, чтобы он выглядел следующим образом:</p>
<p><tt>edit&nbsp;f7f3f6d&nbsp;changed&nbsp;my&nbsp;name&nbsp;a&nbsp;bit<br></br>pick&nbsp;310154e&nbsp;updated&nbsp;README&nbsp;formatting&nbsp;and&nbsp;added&nbsp;blame<br></br>pick&nbsp;a5f4a0d&nbsp;added&nbsp;cat-file<br></br></tt></p>
<p>Когда вы сохраните и выйдете из редактора, Git откатит вас назад к последнему коммиту в списке и выкинет вас в командную строку, выдав следующее сообщение:</p>
<p><tt>$&nbsp;git&nbsp;rebase&nbsp;-i&nbsp;HEAD~3<br></br>Stopped&nbsp;at&nbsp;7482e0d...&nbsp;updated&nbsp;the&nbsp;gemspec&nbsp;to&nbsp;hopefully&nbsp;work&nbsp;better<br></br>You&nbsp;can&nbsp;amend&nbsp;the&nbsp;commit&nbsp;now,&nbsp;with<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git&nbsp;commit&nbsp;--amend<br></br><br></br>Once&nbsp;you’re&nbsp;satisfied&nbsp;with&nbsp;your&nbsp;changes,&nbsp;run<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git&nbsp;rebase&nbsp;--continue<br></br></tt></p>
<p>В этой инструкции в точности сказано, что надо сделать. Наберите</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;--amend<br></br></tt></p>
<p>Измените сообщение коммита и выйдите из редактора. Теперь выполните</p>
<p><tt>$&nbsp;git&nbsp;rebase&nbsp;--continue<br></br></tt></p>
<p>Данная команда применит оставшиеся два коммита автоматически и закончит на этом. Если вы измените pick на edit для большего количества строк, то вы повторите эти шаги для каждого коммита, где вы напишете edit. Каждый раз Git будет останавливаться, давая вам исправить коммит, а потом, когда вы закончите, будет продолжать.</p>
<p id="calibre_link-161"><span><span><b>Переупорядочение коммитов</b></span></span></p>
<p>Интерактивное перемещение можно также использовать для изменения порядка следования и для полного удаления коммитов. Если вы хотите удалить коммит "added cat-file" и поменять порядок, в котором идут два других коммита, измените сценарий для rebase с такого</p>
<p><tt>pick&nbsp;f7f3f6d&nbsp;changed&nbsp;my&nbsp;name&nbsp;a&nbsp;bit<br></br>pick&nbsp;310154e&nbsp;updated&nbsp;README&nbsp;formatting&nbsp;and&nbsp;added&nbsp;blame<br></br>pick&nbsp;a5f4a0d&nbsp;added&nbsp;cat-file<br></br></tt></p>
<p>на такой:</p>
<p><tt>pick&nbsp;310154e&nbsp;updated&nbsp;README&nbsp;formatting&nbsp;and&nbsp;added&nbsp;blame<br></br>pick&nbsp;f7f3f6d&nbsp;changed&nbsp;my&nbsp;name&nbsp;a&nbsp;bit<br></br></tt></p>
<p>Когда вы сохраните и выйдете из редактора, Git откатит вашу ветку к родительскому для этих трёх коммиту, применит <tt>310154e</tt>, затем <tt>f7f3f6d</tt>, а потом остановится. Вы фактически поменяли порядок следования коммитов и полностью удалили коммит "added cat-file".</p>
<p id="calibre_link-162"><span><span><b>Уплотнение коммитов</b></span></span></p>
<p>С помощью интерактивного перемещения также возможно взять несколько коммитов и сплющить их в один коммит. Сценарий выдаёт полезное сообщение с инструкциями для перемещения:</p>
<p><tt>#<br></br>#&nbsp;Commands:<br></br>#&nbsp;&nbsp;p,&nbsp;pick&nbsp;=&nbsp;use&nbsp;commit<br></br>#&nbsp;&nbsp;e,&nbsp;edit&nbsp;=&nbsp;use&nbsp;commit,&nbsp;but&nbsp;stop&nbsp;for&nbsp;amending<br></br>#&nbsp;&nbsp;s,&nbsp;squash&nbsp;=&nbsp;use&nbsp;commit,&nbsp;but&nbsp;meld&nbsp;into&nbsp;previous&nbsp;commit<br></br>#<br></br>#&nbsp;If&nbsp;you&nbsp;remove&nbsp;a&nbsp;line&nbsp;here&nbsp;THAT&nbsp;COMMIT&nbsp;WILL&nbsp;BE&nbsp;LOST.<br></br>#&nbsp;However,&nbsp;if&nbsp;you&nbsp;remove&nbsp;everything,&nbsp;the&nbsp;rebase&nbsp;will&nbsp;be&nbsp;aborted.<br></br>#<br></br></tt></p>
<p>Если вместо "pick" или "edit" указать "squash", Git применит изменения и из этого коммита, и из предыдущего, а затем даст вам объединить сообщения для коммитов. Итак, чтобы сделать один коммит из трёх наших коммитов, надо сделать так, чтобы сценарий выглядел следующим образом:</p>
<p><tt>pick&nbsp;f7f3f6d&nbsp;changed&nbsp;my&nbsp;name&nbsp;a&nbsp;bit<br></br>squash&nbsp;310154e&nbsp;updated&nbsp;README&nbsp;formatting&nbsp;and&nbsp;added&nbsp;blame<br></br>squash&nbsp;a5f4a0d&nbsp;added&nbsp;cat-file<br></br></tt></p>
<p>Когда вы сохраните и выйдете из редактора, Git применит все три изменения, а затем опять выдаст вам редактор для того, чтобы объединить сообщения трёх коммитов:</p>
<p><tt>#&nbsp;This&nbsp;is&nbsp;a&nbsp;combination&nbsp;of&nbsp;3&nbsp;commits.<br></br>#&nbsp;The&nbsp;first&nbsp;commit's&nbsp;message&nbsp;is:<br></br>changed&nbsp;my&nbsp;name&nbsp;a&nbsp;bit<br></br><br></br>#&nbsp;This&nbsp;is&nbsp;the&nbsp;2nd&nbsp;commit&nbsp;message:<br></br><br></br>updated&nbsp;README&nbsp;formatting&nbsp;and&nbsp;added&nbsp;blame<br></br><br></br>#&nbsp;This&nbsp;is&nbsp;the&nbsp;3rd&nbsp;commit&nbsp;message:<br></br><br></br>added&nbsp;cat-file<br></br></tt></p>
<p>Когда вы это сохраните, у вас будет один коммит, который вносит изменения такие же, как три бывших коммита.</p>
<p id="calibre_link-163"><span><span><b>Разбиение коммита</b></span></span></p>
<p>Разбиение коммита &mdash; это отмена коммита, а затем индексирование изменений частями и добавление коммитов столько раз, сколько коммитов вы хотите получить. Предположим, что вы хотите разбить средний из наших трёх коммитов. Вместо "updated README formatting and added blame" вы хотите получить два отдельных коммита: "updated README formatting" в качестве первого и "added blame" в качестве второго. Вы можете сделать это в сценарии <tt>rebase -i</tt>, поставив "edit" в инструкции для коммита, который хотите разбить:</p>
<p><tt>pick&nbsp;f7f3f6d&nbsp;changed&nbsp;my&nbsp;name&nbsp;a&nbsp;bit<br></br>edit&nbsp;310154e&nbsp;updated&nbsp;README&nbsp;formatting&nbsp;and&nbsp;added&nbsp;blame<br></br>pick&nbsp;a5f4a0d&nbsp;added&nbsp;cat-file<br></br></tt></p>
<p>Когда вы сохраните и выйдете из редактора, Git откатится к родителю первого коммита в списке, применит первый коммит (<tt>f7f3f6d</tt>), применит второй (<tt>310154e</tt>) и выбросит вас в консоль. Здесь вы можете сбросить последний коммит в смешанном режиме с помощью <tt>git reset HEAD^</tt> &mdash; это в сущности отменит этот коммит и оставит изменённые файлы непроиндексированными. Теперь вы можете взять сброшенные изменения и создать из них несколько коммитов. Просто добавляйте файлы в индекс и делайте коммиты, пока не сделаете несколько штук. Затем, когда закончите, выполните <tt>git rebase --continue</tt>:</p>
<p><tt>$&nbsp;git&nbsp;reset&nbsp;HEAD^<br></br>$&nbsp;git&nbsp;add&nbsp;README<br></br>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'updated&nbsp;README&nbsp;formatting'<br></br>$&nbsp;git&nbsp;add&nbsp;lib/simplegit.rb<br></br>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'added&nbsp;blame'<br></br>$&nbsp;git&nbsp;rebase&nbsp;--continue<br></br></tt></p>
<p>Когда Git применит последний коммит (<tt>a5f4a0d</tt>) в сценарии, история будет выглядеть так:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-4&nbsp;--pretty=format:"%h&nbsp;%s"<br></br>1c002dd&nbsp;added&nbsp;cat-file<br></br>9b29157&nbsp;added&nbsp;blame<br></br>35cfb2b&nbsp;updated&nbsp;README&nbsp;formatting<br></br>f3cc40e&nbsp;changed&nbsp;my&nbsp;name&nbsp;a&nbsp;bit<br></br></tt></p>
<p>Повторимся ещё раз, что эта операция меняет SHA всех коммитов в списке, так что убедитесь, что ни один из коммитов в этом списке вы ещё не успели отправить в общий репозиторий.</p>
<p id="calibre_link-164"><span><span><b>Крайнее средство: filter-branch</b></span></span></p>
<p>Есть ещё один вариант переписывания истории, который можно использовать, если надо переписать большое количество коммитов в автоматизируемой форме &mdash; например, везде поменять свой e-mail адрес или удалить файл из каждого коммита &mdash; это команда <tt>filter-branch</tt>. Она может переписать огромные периоды вашей истории, так что, возможно, вообще не стоит использовать её, если ваш проект успел стать публичным и другие люди уже работают на основе коммитов, которые вы собрались переписать. Однако, она может быть весьма полезной. Мы посмотрим на некоторые типичные варианты использования команды так, чтобы вы получили представление о тех вещах, на которые она способна.</p>
<p><span><b>Удаление файла изо всех коммитов</b></span></p>
<p>Такое случается довольно часто. Кто-нибудь случайно добавляет в коммит огромный бинарный файл, необдуманно выполнив <tt>git add .</tt>, и вы хотите удалить его отовсюду. Или, может быть, вы нечаянно добавили в коммит файл содержащий пароль, а теперь хотите сделать код этого проекта открытым. <tt>filter-branch</tt> &mdash; это тот инструмент, который вы наверняка захотите использовать, чтобы прочесать всю историю. Чтобы удалить файл с именем passwords.txt изо всей истории, используйте опцию <tt>--tree-filter</tt> для <tt>filter-branch</tt>:</p>
<p><tt>$&nbsp;git&nbsp;filter-branch&nbsp;--tree-filter&nbsp;'rm&nbsp;-f&nbsp;passwords.txt'&nbsp;HEAD<br></br>Rewrite&nbsp;6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd&nbsp;(21/21)<br></br>Ref&nbsp;'refs/heads/master'&nbsp;was&nbsp;rewritten<br></br></tt></p>
<p>Опция <tt>--tree-filter</tt> выполняет указанную команду после выгрузки каждой версии проекта и затем заново делает коммит из результата. В нашем случае мы удалили файл с именем passwords.txt из каждого снимка состояния независимо от того, существовал ли он там или нет. Если вы хотите удалить все случайно добавленные резервные копии, сделанные вашим текстовым редактором, выполните что-то типа <tt>git filter-branch --tree-filter "find * -type f -name '*~' -delete" HEAD</tt>.</p>
<p>Вы увидите, как Git переписывает деревья и коммиты, а в конце переставляет указатель ветки. Как правило, хороший вариант &mdash; делать это в тестовой ветке, а затем жёстко сбрасывать ветку master с помощью <tt>reset --hard</tt>, когда вы поймёте, что результат &mdash; это то, чего вы действительно добивались. Чтобы запустить <tt>filter-branch</tt> для всех веток, можно передать команде параметр <tt>--all</tt>.</p>
<p><span><b>Сделать подкаталог новым корнем</b></span></p>
<p>Предположим, вы импортировали репозиторий из другой системы контроля версий, и в нём есть бессмысленные каталоги (trunk, tags, и др.). Если вы хотите сделать <tt>trunk</tt> новым корнем проекта, команда <tt>filter-branch</tt> может помочь вам сделать и это:</p>
<p><tt>$&nbsp;git&nbsp;filter-branch&nbsp;--subdirectory-filter&nbsp;trunk&nbsp;HEAD<br></br>Rewrite&nbsp;856f0bf61e41a27326cdae8f09fe708d679f596f&nbsp;(12/12)<br></br>Ref&nbsp;'refs/heads/master'&nbsp;was&nbsp;rewritten<br></br></tt></p>
<p>Теперь всюду корневой каталог проекта будет в подкаталоге <tt>trunk</tt>. Git также автоматически удалит все коммиты, которые не затрагивают данный подкаталог.</p>
<p><span><b>Глобальное изменение e-mail адреса</b></span></p>
<p>Ещё один типичный случай &mdash; это, когда вы забыли выполнить <tt>git config</tt>, чтобы задать своё имя и e-mail адрес, перед тем как начать работать. Или, возможно, вы хотите открыть код своего проекта с работы и поменять все свои рабочие e-mail'ы на свой личный адрес. В любом случае с помощью <tt>filter-branch</tt> вы с таким же успехом можете поменять адреса почты в нескольких коммитах за один раз. Вам надо быть аккуратным, чтобы не поменять и чужие адреса, поэтому используйте <tt>--commit-filter</tt>:</p>
<p><tt>$&nbsp;git&nbsp;filter-branch&nbsp;--commit-filter&nbsp;'<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;[&nbsp;"$GIT_AUTHOR_EMAIL"&nbsp;=&nbsp;"schacon@localhost"&nbsp;];<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GIT_AUTHOR_NAME="Scott&nbsp;Chacon";<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GIT_AUTHOR_EMAIL="schacon@example.com";<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git&nbsp;commit-tree&nbsp;"$@";<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git&nbsp;commit-tree&nbsp;"$@";<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi'&nbsp;HEAD<br></br></tt></p>
<p>Эта команда проходит по всем коммитам и переписывает их так, чтобы там был указан новый адрес. Так как коммиты содержат значения SHA-1 своих родителей, эта команда поменяет все SHA в вашей истории, а не только те, в которых есть указанный e-mail адрес.</p>
<div></div><p id="calibre_link-165"><span><span><b>Отладка с помощью Git</b></span></span></p>
<p>Git также предоставляет несколько инструментов, призванных помочь вам в отладке ваших проектов. Так как Git сконструирован так, чтобы работать с практически любыми типами проектов, эти инструменты довольно общие, но зачастую они могут помочь отловить ошибку или её виновника, если что-то пошло не так.</p>
<p id="calibre_link-166"><span><span><b>Аннотация файла</b></span></span></p>
<p>Если вы отловили ошибку в коде и хотите узнать, когда и по какой причине она была внесена, то аннотация файла &mdash; лучший инструмент для этого случая. Он покажет вам, какие коммиты модифицировали каждую строку файла в последний раз. Так что, если вы видите, что какой-то метод в коде содержит ошибку, то можно сделать аннотацию нужного файла с помощью <tt>git blame</tt>, чтобы посмотреть, когда и кем каждая строка метода была в последний раз отредактирована. В этом примере используется опция <tt>-L</tt>, чтобы ограничить вывод строками с 12ой по 22ую:</p>
<p><tt>$&nbsp;git&nbsp;blame&nbsp;-L&nbsp;12,22&nbsp;simplegit.rb&nbsp;<br></br>^4832fe2&nbsp;(Scott&nbsp;Chacon&nbsp;&nbsp;2008-03-15&nbsp;10:31:28&nbsp;-0700&nbsp;12)&nbsp;&nbsp;def&nbsp;show(tree&nbsp;=&nbsp;'master')<br></br>^4832fe2&nbsp;(Scott&nbsp;Chacon&nbsp;&nbsp;2008-03-15&nbsp;10:31:28&nbsp;-0700&nbsp;13)&nbsp;&nbsp;&nbsp;command("git&nbsp;show&nbsp;#{tree}")<br></br>^4832fe2&nbsp;(Scott&nbsp;Chacon&nbsp;&nbsp;2008-03-15&nbsp;10:31:28&nbsp;-0700&nbsp;14)&nbsp;&nbsp;end<br></br>^4832fe2&nbsp;(Scott&nbsp;Chacon&nbsp;&nbsp;2008-03-15&nbsp;10:31:28&nbsp;-0700&nbsp;15)<br></br>9f6560e4&nbsp;(Scott&nbsp;Chacon&nbsp;&nbsp;2008-03-17&nbsp;21:52:20&nbsp;-0700&nbsp;16)&nbsp;&nbsp;def&nbsp;log(tree&nbsp;=&nbsp;'master')<br></br>79eaf55d&nbsp;(Scott&nbsp;Chacon&nbsp;&nbsp;2008-04-06&nbsp;10:15:08&nbsp;-0700&nbsp;17)&nbsp;&nbsp;&nbsp;command("git&nbsp;log&nbsp;#{tree}")<br></br>9f6560e4&nbsp;(Scott&nbsp;Chacon&nbsp;&nbsp;2008-03-17&nbsp;21:52:20&nbsp;-0700&nbsp;18)&nbsp;&nbsp;end<br></br>9f6560e4&nbsp;(Scott&nbsp;Chacon&nbsp;&nbsp;2008-03-17&nbsp;21:52:20&nbsp;-0700&nbsp;19)&nbsp;<br></br>42cf2861&nbsp;(Magnus&nbsp;Chacon&nbsp;2008-04-13&nbsp;10:45:01&nbsp;-0700&nbsp;20)&nbsp;&nbsp;def&nbsp;blame(path)<br></br>42cf2861&nbsp;(Magnus&nbsp;Chacon&nbsp;2008-04-13&nbsp;10:45:01&nbsp;-0700&nbsp;21)&nbsp;&nbsp;&nbsp;command("git&nbsp;blame&nbsp;#{path}")<br></br>42cf2861&nbsp;(Magnus&nbsp;Chacon&nbsp;2008-04-13&nbsp;10:45:01&nbsp;-0700&nbsp;22)&nbsp;&nbsp;end<br></br></tt></p>
<p>Заметьте, что первое поле &mdash; это частичная SHA-1 коммита, в котором последний раз менялась строка. Следующие два поля &mdash; это значения, полученные из этого коммита &mdash; имя автора и дата создания коммита. Так что вы легко можете понять, кто и когда менял данную строку. Затем идут номера строк и содержимое файла. Также обратите внимание на строки с <tt>^4832fe2</tt>, это те строки, которые находятся здесь со времён первого коммита для этого файла. Это коммит, в котором этот файл был впервые добавлен в проект, и с тех пор те строки не менялись. Это всё несколько сбивает с толку, потому что только что вы увидели по крайней мере три разных способа изменить SHA коммита с помощью <tt>^</tt>, но тут вот такое значение.</p>
<p>Ещё одна крутая вещь в Git'е &mdash; это то, что он не отслеживает переименования файлов в явном виде. Он записывает снимки состояний, а затем пытается выяснить, что было переименовано неявно уже после того, как это случилось. Одна из интересных функций, возможная благодаря этому, заключается в том, что вы можете попросить дополнительно выявить все виды перемещений кода. Если вы передадите <tt>-C</tt> в <tt>git blame</tt>, Git проанализирует аннотируемый файл и попытается выявить, откуда фрагменты кода в нём появились изначально, если они были скопированы откуда-то. Недавно я занимался разбиением файла <tt>GITServerHandler.m</tt> на несколько файлов, один из которых был <tt>GITPackUpload.m</tt>. Вызвав <tt>blame</tt> с опцией <tt>-C</tt> для <tt>GITPackUpload.m</tt>, я могу понять откуда части кода здесь появились:</p>
<p><tt>$&nbsp;git&nbsp;blame&nbsp;-C&nbsp;-L&nbsp;141,153&nbsp;GITPackUpload.m&nbsp;<br></br>f344f58d&nbsp;GITServerHandler.m&nbsp;(Scott&nbsp;2009-01-04&nbsp;141)&nbsp;<br></br>f344f58d&nbsp;GITServerHandler.m&nbsp;(Scott&nbsp;2009-01-04&nbsp;142)&nbsp;-&nbsp;(void)&nbsp;gatherObjectShasFromC<br></br>f344f58d&nbsp;GITServerHandler.m&nbsp;(Scott&nbsp;2009-01-04&nbsp;143)&nbsp;{<br></br>70befddd&nbsp;GITServerHandler.m&nbsp;(Scott&nbsp;2009-03-22&nbsp;144)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//NSLog(@"GATHER&nbsp;COMMI<br></br>ad11ac80&nbsp;GITPackUpload.m&nbsp;&nbsp;&nbsp;&nbsp;(Scott&nbsp;2009-03-24&nbsp;145)<br></br>ad11ac80&nbsp;GITPackUpload.m&nbsp;&nbsp;&nbsp;&nbsp;(Scott&nbsp;2009-03-24&nbsp;146)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSString&nbsp;*parentSha;<br></br>ad11ac80&nbsp;GITPackUpload.m&nbsp;&nbsp;&nbsp;&nbsp;(Scott&nbsp;2009-03-24&nbsp;147)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GITCommit&nbsp;*commit&nbsp;=&nbsp;[g<br></br>ad11ac80&nbsp;GITPackUpload.m&nbsp;&nbsp;&nbsp;&nbsp;(Scott&nbsp;2009-03-24&nbsp;148)<br></br>ad11ac80&nbsp;GITPackUpload.m&nbsp;&nbsp;&nbsp;&nbsp;(Scott&nbsp;2009-03-24&nbsp;149)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//NSLog(@"GATHER&nbsp;COMMI<br></br>ad11ac80&nbsp;GITPackUpload.m&nbsp;&nbsp;&nbsp;&nbsp;(Scott&nbsp;2009-03-24&nbsp;150)<br></br>56ef2caf&nbsp;GITServerHandler.m&nbsp;(Scott&nbsp;2009-01-05&nbsp;151)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(commit)&nbsp;{<br></br>56ef2caf&nbsp;GITServerHandler.m&nbsp;(Scott&nbsp;2009-01-05&nbsp;152)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[refDict&nbsp;setOb<br></br>56ef2caf&nbsp;GITServerHandler.m&nbsp;(Scott&nbsp;2009-01-05&nbsp;153)<br></br></tt></p>
<p>Это действительно удобно. Стандартно вам бы выдали в качестве начального коммита тот коммит, в котором вы скопировали код, так как это первый коммит, в котором вы поменяли эти строки в данном файле. А сейчас Git выдал вам изначальный коммит, в котором эти строки были написаны, несмотря на то, что это было в другом файле.</p>
<p id="calibre_link-167"><span><span><b>Бинарный поиск</b></span></span></p>
<p>Аннотирование файла помогает, когда вы знаете, где у вас ошибка, и есть с чего начинать. Если вы не знаете, что у вас сломалось, и с тех пор, когда код работал, были сделаны десятки или сотни коммитов, вы наверняка обратитесь за помощью к <tt>git bisect</tt>. Команда <tt>bisect</tt> выполняет бинарный поиск по истории коммитов, и призвана помочь как можно быстрее определить, в каком коммите была внесена ошибка.</p>
<p>Положим, вы только что отправили новую версию вашего кода в производство, и теперь вы периодически получаете отчёты о какой-то ошибке, которая не проявлялась, пока вы работали над кодом, и вы не представляете, почему код ведёт себя так. Вы возвращаетесь к своему коду, и у вас получается воспроизвести ошибку, но вы не понимаете, что не так. Вы можете использовать <tt>bisect</tt>, чтобы выяснить это. Сначала выполните <tt>git bisect start</tt>, чтобы запустить процесс, а затем <tt>git bisect bad</tt>, чтобы сказать системе, что текущий коммит, на котором вы сейчас находитесь, сломан. Затем, необходимо сказать <tt>bisect</tt>, когда было последнее известное хорошее состояние с помощью <tt>git bisect good [хороший_коммит]</tt>:</p>
<p><tt>$&nbsp;git&nbsp;bisect&nbsp;start<br></br>$&nbsp;git&nbsp;bisect&nbsp;bad<br></br>$&nbsp;git&nbsp;bisect&nbsp;good&nbsp;v1.0<br></br>Bisecting:&nbsp;6&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this<br></br>[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2]&nbsp;error&nbsp;handling&nbsp;on&nbsp;repo<br></br></tt></p>
<p>Git выяснил, что между коммитом, который вы указали как последний хороший коммит (v1.0), и текущей плохой версией было сделано примерно 12 коммитов, и он выгрузил вам версию из середины. В этот момент вы можете провести свои тесты и посмотреть, проявляется ли проблема в этом коммите. Если да, то она была внесена где-то раньше этого среднего коммита; если нет, то проблема появилась где-то после коммита в середине. Положим, что оказывается, что проблема здесь не проявилась, и вы сообщаете об этом Git'у, набрав <tt>git bisect good</tt>, и продолжаете свой путь:</p>
<p><tt>$&nbsp;git&nbsp;bisect&nbsp;good<br></br>Bisecting:&nbsp;3&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this<br></br>[b047b02ea83310a70fd603dc8cd7a6cd13d15c04]&nbsp;secure&nbsp;this&nbsp;thing<br></br></tt></p>
<p>Теперь вы на другом коммите, посередине между тем, который только что был протестирован и вашим плохим коммитом. Вы снова проводите тесты и выясняете, что текущий коммит сломан. Так что вы говорите об этом Git'у с помощью <tt>git bisect bad</tt>:</p>
<p><tt>$&nbsp;git&nbsp;bisect&nbsp;bad<br></br>Bisecting:&nbsp;1&nbsp;revisions&nbsp;left&nbsp;to&nbsp;test&nbsp;after&nbsp;this<br></br>[f71ce38690acf49c1f3c9bea38e09d82a5ce6014]&nbsp;drop&nbsp;exceptions&nbsp;table<br></br></tt></p>
<p>Этот коммит хороший, и теперь у Git'а есть вся необходимая информация, чтобы определить, где проблема была внесена впервые. Он выдаёт вам SHA-1 первого плохого коммита и некоторую информацию о нём, а также какие файлы были изменены в этом коммите, так что вы сможете понять, что случилось, что могло внести эту ошибку:</p>
<p><tt>$&nbsp;git&nbsp;bisect&nbsp;good<br></br>b047b02ea83310a70fd603dc8cd7a6cd13d15c04&nbsp;is&nbsp;first&nbsp;bad&nbsp;commit<br></br>commit&nbsp;b047b02ea83310a70fd603dc8cd7a6cd13d15c04<br></br>Author:&nbsp;PJ&nbsp;Hyett&nbsp;&lt;pjhyett@example.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Tue&nbsp;Jan&nbsp;27&nbsp;14:48:32&nbsp;2009&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;secure&nbsp;this&nbsp;thing<br></br><br></br>:040000&nbsp;040000&nbsp;40ee3e7821b895e52c1695092db9bdc4c61d1730<br></br>f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4&nbsp;M&nbsp;&nbsp;config<br></br></tt></p>
<p>Если вы закончили, необходимо выполнить <tt>git bisect reset</tt>, чтобы сбросить HEAD туда, где он был до начала бинарного поиска, иначе вы окажетесь в странном состоянии:</p>
<p><tt>$&nbsp;git&nbsp;bisect&nbsp;reset<br></br></tt></p>
<p>Это мощный инструмент, который поможет вам за считанные минуты проверить сотни коммитов в поисках появившейся ошибки. На самом деле, если у вас есть сценарий (script), который возвращает на выходе 0, если проект хороший и не 0, если проект плохой, то вы можете полностью автоматизировать <tt>git bisect</tt>. Для начала ему снова надо задать область бинарного поиска, задав известные хороший и плохой коммиты. Если хотите, можете сделать это, указав команде <tt>bisect start</tt> известный плохой коммит первым, а хороший вторым:</p>
<p><tt>$&nbsp;git&nbsp;bisect&nbsp;start&nbsp;HEAD&nbsp;v1.0<br></br>$&nbsp;git&nbsp;bisect&nbsp;run&nbsp;test-error.sh<br></br></tt></p>
<p>Сделав так, вы получите, что <tt>test-error.sh</tt> будет автоматически запускаться на каждом выгруженном коммите, пока Git не найдёт первый сломанный коммит. Вы также можете запускать что-нибудь типа <tt>make</tt> или <tt>make tests</tt> или что-то там ещё, что запускает ваши автоматические тесты.</p>
<div></div><p id="calibre_link-168"><span><span><b>Подмодули</b></span></span></p>
<p>Зачастую случается так, что во время работы над некоторым проектом появляется необходимость использовать внутри него ещё какой-то проект. Возможно, библиотеку, разрабатываемую сторонними разработчиками или разрабатываемую вами обособленно и используемую в нескольких родительских проектах. Типичная проблема, возникающая при использовании подобного сценария, это, как сделать так, чтобы иметь возможность рассматривать эти два проекта как отдельные, всё же имея возможность использовать один проект внутри другого.</p>
<p>Вот пример. Предположим, вы разрабатываете веб-сайт и создаёте Atom-ленты. И вместо того, чтобы писать собственный код, генерирующий Atom, вы решили использовать библиотеку. Вы, вероятно, должны либо подключить нужный код с помощью разделяемой библиотеки, такой как устанавливаемый модуль CPAN или пакет RubyGem, либо скопировать исходный код в дерево собственного проекта. Проблема с подключением библиотеки в том, что библиотеку сложно хоть как-то модифицировать под свои нужды, и зачастую её сложнее распространять. Ведь вы вынуждены удостовериться в том, что эта библиотека доступна на каждом клиенте. Проблема с включением кода в ваш собственный проект в том, что любые изменения, вносимые вами, могут конфликтовать с изменениями, которые появятся в основном проекте, и эти изменения будет сложно слить.</p>
<p>Git решает эту задачу, используя подмодули (submodule). Подмодули позволяют содержать один Git-репозиторий как подкаталог другого Git-репозитория. Это даёт возможность клонировать ещё один репозиторий внутрь проекта, храня коммиты для этого репозитория отдельно.</p>
<p id="calibre_link-169"><span><span><b>Начало использования подмодулей</b></span></span></p>
<p>Предположим, вы хотите добавить библиотеку Rack (интерфейс шлюза веб-сервера Ruby) в свой проект, возможно, внося свои собственные изменения в него, но продолжая сливать их с изменениями основного проекта. Первое, что вам требуется сделать, это клонировать внешний репозиторий в подкаталог. Добавление внешних проектов в качестве подмодулей делается командой <tt>git submodule add</tt>:</p>
<p><tt>$&nbsp;git&nbsp;submodule&nbsp;add&nbsp;git://github.com/chneukirchen/rack.git&nbsp;rack<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/subtest/rack/.git/<br></br>remote:&nbsp;Counting&nbsp;objects:&nbsp;3181,&nbsp;done.<br></br>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100%&nbsp;(1534/1534),&nbsp;done.<br></br>remote:&nbsp;Total&nbsp;3181&nbsp;(delta&nbsp;1951),&nbsp;reused&nbsp;2623&nbsp;(delta&nbsp;1603)<br></br>Receiving&nbsp;objects:&nbsp;100%&nbsp;(3181/3181),&nbsp;675.42&nbsp;KiB&nbsp;|&nbsp;422&nbsp;KiB/s,&nbsp;done.<br></br>Resolving&nbsp;deltas:&nbsp;100%&nbsp;(1951/1951),&nbsp;done.<br></br></tt></p>
<p>Теперь у вас внутри проекта в подкаталоге с именем <tt>rack</tt> находится проект Rack. Вы можете переходить в этот подкаталог, вносить изменения, добавить ваш собственный доступный для записи внешний репозиторий для отправки в него своих изменений, извлекать и сливать из исходного репозитория и многое другое. Если вы выполните <tt>git status</tt> сразу после добавления подмодуля, то увидите две вещи:</p>
<p><tt>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;file:&nbsp;&nbsp;&nbsp;.gitmodules<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;file:&nbsp;&nbsp;&nbsp;rack<br></br>#<br></br></tt></p>
<p>Вначале вы заметите файл <tt>.gitmodules</tt>. Это конфигурационный файл, который содержит соответствие между URL проекта и локальным подкаталогом, в который был загружен подмодуль:</p>
<p><tt>$&nbsp;cat&nbsp;.gitmodules&nbsp;<br></br>[submodule&nbsp;"rack"]<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;rack<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;git://github.com/chneukirchen/rack.git<br></br></tt></p>
<p>Если у вас несколько подмодулей, то в этом файле будет несколько записей. Важно обратить внимание на то, что этот файл находится под версионным контролем вместе с другими вашими файлами, так же как и файл <tt>.gitignore</tt>. Он отправляется при выполнении <tt>push</tt> и загружается при выполнении <tt>pull</tt> вместе с остальными файлами проекта. Так другие люди, которые клонируют этот проект, узнают, откуда взять проекты-подмодули.</p>
<p>В следующем листинге вывода <tt>git status</tt> присутствует элемент <tt>rack</tt>. Если вы выполните <tt>git diff</tt> для него, то увидите кое-что интересное:</p>
<p><tt>$&nbsp;git&nbsp;diff&nbsp;--cached&nbsp;rack<br></br>diff&nbsp;--git&nbsp;a/rack&nbsp;b/rack<br></br>new&nbsp;file&nbsp;mode&nbsp;160000<br></br>index&nbsp;0000000..08d709f<br></br>---&nbsp;/dev/null<br></br>+++&nbsp;b/rack<br></br>@@&nbsp;-0,0&nbsp;+1&nbsp;@@<br></br>+Subproject&nbsp;commit&nbsp;08d709f78b8c5b0fbeb7821e37fa53e69afcf433<br></br></tt></p>
<p>Хотя <tt>rack</tt> является подкаталогом в вашем рабочем каталоге, Git видит его как подмодуль и не отслеживает его содержимое, если вы не находитесь в нём. Вместо этого, Git записывает его как один конкретный коммит из этого репозитория. Если вы производите изменения в этом подкаталоге и делаете коммит, основной проект замечает, что HEAD в подмодуле был изменён, и регистрирует тот хеш коммита, над которым вы в данный момент завершили работу в подмодуле. Таким образом, если кто-то склонирует этот проект, он сможет воссоздать окружение в точности.</p>
<p>Это важная особенность подмодулей &ndash; вы запоминаете их как определенный коммит (состояние), в котором они находятся. Вы не можете записать подмодуль под ссылкой <tt>master</tt> или какой-либо другой символьной ссылкой.</p>
<p>Если вы создадите коммит, то увидите что-то вроде этого:</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'first&nbsp;commit&nbsp;with&nbsp;submodule&nbsp;rack'<br></br>[master&nbsp;0550271]&nbsp;first&nbsp;commit&nbsp;with&nbsp;submodule&nbsp;rack<br></br>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;4&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;.gitmodules<br></br>&nbsp;create&nbsp;mode&nbsp;160000&nbsp;rack<br></br></tt></p>
<p>Обратите внимание на режим 160000 для элемента rack. Это специальный режим в Git'е, который по существу означает, что в качестве записи в каталоге сохраняется коммит, а не подкаталог или файл.</p>
<p>Вы можете обращаться с каталогом <tt>rack</tt> как с отдельным проектом и время от времени обновлять свой "надпроект" с помощью указателя на самый последний коммит в этом подпроекте. Все команды Git'а в этих двух каталогах работают независимо друг от друга:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-1<br></br>commit&nbsp;0550271328a0038865aad6331e620cd7238601bb<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Apr&nbsp;9&nbsp;09:03:56&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;commit&nbsp;with&nbsp;submodule&nbsp;rack<br></br>$&nbsp;cd&nbsp;rack/<br></br>$&nbsp;git&nbsp;log&nbsp;-1<br></br>commit&nbsp;08d709f78b8c5b0fbeb7821e37fa53e69afcf433<br></br>Author:&nbsp;Christian&nbsp;Neukirchen&nbsp;&lt;chneukirchen@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Wed&nbsp;Mar&nbsp;25&nbsp;14:49:04&nbsp;2009&nbsp;+0100<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Document&nbsp;version&nbsp;change<br></br></tt></p>
<p id="calibre_link-170"><span><span><b>Клонирование проекта с подмодулями</b></span></span></p>
<p>Сейчас мы склонируем проект, содержащий подмодуль. После получения такого проекта в вашей копии будут каталоги, содержащие подмодули, но пока что без единого файла в них:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;git://github.com/schacon/myproject.git<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/myproject/.git/<br></br>remote:&nbsp;Counting&nbsp;objects:&nbsp;6,&nbsp;done.<br></br>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100%&nbsp;(4/4),&nbsp;done.<br></br>remote:&nbsp;Total&nbsp;6&nbsp;(delta&nbsp;0),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)<br></br>Receiving&nbsp;objects:&nbsp;100%&nbsp;(6/6),&nbsp;done.<br></br>$&nbsp;cd&nbsp;myproject<br></br>$&nbsp;ls&nbsp;-l<br></br>total&nbsp;8<br></br>-rw-r--r--&nbsp;&nbsp;1&nbsp;schacon&nbsp;&nbsp;admin&nbsp;&nbsp;&nbsp;3&nbsp;Apr&nbsp;&nbsp;9&nbsp;09:11&nbsp;README<br></br>drwxr-xr-x&nbsp;&nbsp;2&nbsp;schacon&nbsp;&nbsp;admin&nbsp;&nbsp;68&nbsp;Apr&nbsp;&nbsp;9&nbsp;09:11&nbsp;rack<br></br>$&nbsp;ls&nbsp;rack/<br></br>$<br></br></tt></p>
<p>Каталог <tt>rack</tt> присутствует, но он пустой. Необходимо выполнить две команды: <tt>git submodule init</tt> для инициализации вашего локального файла конфигурации и <tt>git submodule update</tt> для получения всех данных из подмодуля и перехода к соответствующему коммиту, указанному в вашем основном проекте:</p>
<p><tt>$&nbsp;git&nbsp;submodule&nbsp;init<br></br>Submodule&nbsp;'rack'&nbsp;(git://github.com/chneukirchen/rack.git)&nbsp;registered&nbsp;for&nbsp;path&nbsp;'rack'<br></br>$&nbsp;git&nbsp;submodule&nbsp;update<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/myproject/rack/.git/<br></br>remote:&nbsp;Counting&nbsp;objects:&nbsp;3181,&nbsp;done.<br></br>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100%&nbsp;(1534/1534),&nbsp;done.<br></br>remote:&nbsp;Total&nbsp;3181&nbsp;(delta&nbsp;1951),&nbsp;reused&nbsp;2623&nbsp;(delta&nbsp;1603)<br></br>Receiving&nbsp;objects:&nbsp;100%&nbsp;(3181/3181),&nbsp;675.42&nbsp;KiB&nbsp;|&nbsp;173&nbsp;KiB/s,&nbsp;done.<br></br>Resolving&nbsp;deltas:&nbsp;100%&nbsp;(1951/1951),&nbsp;done.<br></br>Submodule&nbsp;path&nbsp;'rack':&nbsp;checked&nbsp;out&nbsp;'08d709f78b8c5b0fbeb7821e37fa53e69afcf433'<br></br></tt></p>
<p>Теперь ваш подкаталог <tt>rack</tt> точно в том состоянии, в котором он был, когда вы раньше делали коммит. Если другой разработчик внесёт изменения в код rack и затем сделает коммит, а вы потом обновите эту ссылку и сольёте её, то вы получите что-то странное:</p>
<p><tt>$&nbsp;git&nbsp;merge&nbsp;origin/master<br></br>Updating&nbsp;0550271..85a3eee<br></br>Fast&nbsp;forward<br></br>&nbsp;rack&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;+-<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br>[master*]$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;not&nbsp;staged&nbsp;for&nbsp;commit:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;update&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;checkout&nbsp;--&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;discard&nbsp;changes&nbsp;in&nbsp;working&nbsp;directory)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;rack<br></br>#<br></br></tt></p>
<p>Вы слили то, что по существу является изменением указателя на подмодуль. Но при этом обновления кода в каталоге подмодуля не произошло, так что всё выглядит так, как будто вы имеете грязное состояние в своём рабочем каталоге:</p>
<p><tt>$&nbsp;git&nbsp;diff<br></br>diff&nbsp;--git&nbsp;a/rack&nbsp;b/rack<br></br>index&nbsp;6c5e70b..08d709f&nbsp;160000<br></br>---&nbsp;a/rack<br></br>+++&nbsp;b/rack<br></br>@@&nbsp;-1&nbsp;+1&nbsp;@@<br></br>-Subproject&nbsp;commit&nbsp;6c5e70b984a60b3cecd395edd5b48a7575bf58e0<br></br>+Subproject&nbsp;commit&nbsp;08d709f78b8c5b0fbeb7821e37fa53e69afcf433<br></br></tt></p>
<p>Это всё из-за того, что ваш указатель на подмодуль не соответствует тому, что на самом деле находится в каталоге подмодуля. Чтобы исправить это, необходимо снова выполнить <tt>git submodule update</tt>:</p>
<p><tt>$&nbsp;git&nbsp;submodule&nbsp;update<br></br>remote:&nbsp;Counting&nbsp;objects:&nbsp;5,&nbsp;done.<br></br>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100%&nbsp;(3/3),&nbsp;done.<br></br>remote:&nbsp;Total&nbsp;3&nbsp;(delta&nbsp;1),&nbsp;reused&nbsp;2&nbsp;(delta&nbsp;0)<br></br>Unpacking&nbsp;objects:&nbsp;100%&nbsp;(3/3),&nbsp;done.<br></br>From&nbsp;git@github.com:schacon/rack<br></br>&nbsp;&nbsp;&nbsp;08d709f..6c5e70b&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;origin/master<br></br>Submodule&nbsp;path&nbsp;'rack':&nbsp;checked&nbsp;out&nbsp;'6c5e70b984a60b3cecd395edd5b48a7575bf58e0'<br></br></tt></p>
<p>Вы вынуждены делать так каждый раз, когда вы получаете изменения подмодуля в главном проекте. Это странно, но это работает.</p>
<p>Распространённая проблема возникает, когда разработчик делает изменения в своей локальной копии подмодуля, но не отправляет их на общий сервер. Затем он создаёт коммит содержащий указатель на это непубличное состояние и отправляет его в основной проект. Когда другие разработчики пытаются выполнить <tt>git submodule update</tt>, система работы с подмодулями не может найти указанный коммит, потому что он существует только в системе первого разработчика. Если такое случится, вы увидите ошибку вроде этой:</p>
<p><tt>$&nbsp;git&nbsp;submodule&nbsp;update<br></br>fatal:&nbsp;reference&nbsp;isn’t&nbsp;a&nbsp;tree:&nbsp;6c5e70b984a60b3cecd395edd5b48a7575bf58e0<br></br>Unable&nbsp;to&nbsp;checkout&nbsp;'6c5e70b984a60b3cecd395edd5ba7575bf58e0'&nbsp;in&nbsp;submodule&nbsp;path&nbsp;'rack'<br></br></tt></p>
<p>Вам надо посмотреть, кто последним менял подмодуль:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-1&nbsp;rack<br></br>commit&nbsp;85a3eee996800fcfa91e2119372dd4172bf76678<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Apr&nbsp;9&nbsp;09:19:14&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;added&nbsp;a&nbsp;submodule&nbsp;reference&nbsp;I&nbsp;will&nbsp;never&nbsp;make&nbsp;public.&nbsp;hahahahaha!<br></br></tt></p>
<p>А затем отправить этому человеку письмо со своими возмущениями.</p>
<p id="calibre_link-171"><span><span><b>Суперпроекты</b></span></span></p>
<p>Иногда разработчики хотят объединить подкаталоги крупного проекта в нечто связанное в зависимости от того, в какой они команде. Это типично для людей, перешедших с CVS или Subversion, где они определяли модуль или набор подкаталогов, и они хотят сохранить данный тип рабочего процесса.</p>
<p>Хороший способ сделать такое в Git'е &mdash; это сделать каждый из подкаталогов отдельным Git-репозиторием, и создать Git-репозиторий для суперпроекта, который будет содержать несколько подмодулей. Преимущество такого подхода в том, что вы можете более гибко определять отношения между проектами при помощи меток и ветвей в суперпроектах.</p>
<p id="calibre_link-172"><span><span><b>Проблемы с подмодулями</b></span></span></p>
<p>Однако, использование подмодулей не обходится без загвоздок. Во-первых, вы должны быть относительно осторожны, работая в каталоге подмодуля. Когда вы выполняете команду <tt>git submodule update</tt>, она возвращает определённую версию проекта, но не внутри ветви. Это называется состоянием с отделённым HEAD (detached HEAD) &mdash; это означает, что файл HEAD указывает на конкретный коммит, а не на символическую ссылку. Проблема в том, что вы, скорее всего, не хотите работать в окружении с отделённым HEAD, потому что так легко потерять изменения. Если вы сделаете первоначальный <tt>submodule update</tt>, сделаете коммит в каталоге подмодуля, не создавая ветки для работы в ней, и затем вновь выполните <tt>git submodule update</tt> из основного проекта, без создания коммита в суперпроекте, Git затрёт ваши изменения без предупреждения. Технически вы не потеряете проделанную работу, но у вас не будет ветки, указывающей на неё, так что будет несколько сложновато её восстановить.</p>
<p>Для предотвращения этой проблемы создавайте ветвь, когда работаете в каталоге подмодуля с использованием команды <tt>git checkout -b work</tt> или какой-нибудь аналогичной. Когда вы сделаете обновление подмодуля командой <tt>submodule update</tt> в следующий раз, она всё же откатит вашу работу, но, по крайней мере, у вас будет указатель для возврата назад.</p>
<p>Переключение веток с подмодулями в них также может быть мудрёным. Если вы создадите новую ветку, добавите туда подмодуль и затем переключитесь обратно, туда где не было этого подмодуля, вы всё ещё будете иметь каталог подмодуля в виде неотслеживаемого каталога:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;rack<br></br>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;"rack"<br></br>$&nbsp;git&nbsp;submodule&nbsp;add&nbsp;git@github.com:schacon/rack.git&nbsp;rack<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/myproj/rack/.git/<br></br>...<br></br>Receiving&nbsp;objects:&nbsp;100%&nbsp;(3184/3184),&nbsp;677.42&nbsp;KiB&nbsp;|&nbsp;34&nbsp;KiB/s,&nbsp;done.<br></br>Resolving&nbsp;deltas:&nbsp;100%&nbsp;(1952/1952),&nbsp;done.<br></br>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'added&nbsp;rack&nbsp;submodule'<br></br>[rack&nbsp;cc49a69]&nbsp;added&nbsp;rack&nbsp;submodule<br></br>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;4&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;.gitmodules<br></br>&nbsp;create&nbsp;mode&nbsp;160000&nbsp;rack<br></br>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>Switched&nbsp;to&nbsp;branch&nbsp;"master"<br></br>$&nbsp;git&nbsp;status<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Untracked&nbsp;files:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;add&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;include&nbsp;in&nbsp;what&nbsp;will&nbsp;be&nbsp;committed)<br></br>#<br></br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rack/<br></br></tt></p>
<p>Вы будете вынуждены либо переместить каталог подмодуля в другое место, либо удалить его. В случае удаления вам потребуется клонировать его снова при переключении обратно, и тогда вы можете потерять локальные изменения или ветки, которые не были отправлены в основной репозиторий.</p>
<p>Последняя проблема, которая возникает у многих, и о которой стоит предостеречь, возникает при переходе от подкаталогов к подмодулям. Если вы держали некоторые файлы под версионным контролем в своём проекте, а сейчас хотите перенести их в подмодуль, вам надо быть осторожным, иначе Git разозлится на вас. Допустим, вы держите файлы rack в подкаталоге проекта, и вы хотите вынести его в подмодуль. Если вы просто удалите подкаталог и затем выполните <tt>submodule add</tt>, Git наорёт на вас:</p>
<p><tt>$&nbsp;rm&nbsp;-Rf&nbsp;rack/<br></br>$&nbsp;git&nbsp;submodule&nbsp;add&nbsp;git@github.com:schacon/rack.git&nbsp;rack<br></br>'rack'&nbsp;already&nbsp;exists&nbsp;in&nbsp;the&nbsp;index<br></br></tt></p>
<p>Вначале вам следует убрать каталог <tt>rack</tt> из индекса (убрать из-под версионного контроля). Потом можете добавить подмодуль:</p>
<p><tt>$&nbsp;git&nbsp;rm&nbsp;-r&nbsp;rack<br></br>$&nbsp;git&nbsp;submodule&nbsp;add&nbsp;git@github.com:schacon/rack.git&nbsp;rack<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/testsub/rack/.git/<br></br>remote:&nbsp;Counting&nbsp;objects:&nbsp;3184,&nbsp;done.<br></br>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100%&nbsp;(1465/1465),&nbsp;done.<br></br>remote:&nbsp;Total&nbsp;3184&nbsp;(delta&nbsp;1952),&nbsp;reused&nbsp;2770&nbsp;(delta&nbsp;1675)<br></br>Receiving&nbsp;objects:&nbsp;100%&nbsp;(3184/3184),&nbsp;677.42&nbsp;KiB&nbsp;|&nbsp;88&nbsp;KiB/s,&nbsp;done.<br></br>Resolving&nbsp;deltas:&nbsp;100%&nbsp;(1952/1952),&nbsp;done.<br></br></tt></p>
<p>Теперь, предположим, вы сделали это в ветке. Если вы попытаетесь переключиться обратно на ту ветку, где эти файлы всё ещё в актуальном дереве, а не в подмодуле, то вы получите такую ошибку:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>error:&nbsp;Untracked&nbsp;working&nbsp;tree&nbsp;file&nbsp;'rack/AUTHORS'&nbsp;would&nbsp;be&nbsp;overwritten&nbsp;by&nbsp;merge.<br></br></tt></p>
<p>Вам следует переместить каталог подмодуля <tt>rack</tt>, перед тем, как вы сможете переключиться на ветку, которая не содержит его:</p>
<p><tt>$&nbsp;mv&nbsp;rack&nbsp;/tmp/<br></br>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>Switched&nbsp;to&nbsp;branch&nbsp;"master"<br></br>$&nbsp;ls<br></br>README&nbsp;&nbsp;rack<br></br></tt></p>
<p>Затем, когда вы переключитесь обратно, вы получите пустой каталог <tt>rack</tt>. Вы сможете либо выполнить <tt>git submodule update</tt> для повторного клонирования, или вернуть содержимое вашего каталога <tt>/tmp/rack</tt> обратно в пустой каталог.</p>
<div></div><p id="calibre_link-173"><span><span><b>Слияние поддеревьев</b></span></span></p>
<p>Теперь, когда вы увидели сложности системы подмодулей, давайте посмотрим на альтернативный путь решения той же проблемы. Когда Git выполняет слияние, он смотрит на то, что требуется слить воедино, и потом выбирает подходящую стратегию слияния. Если вы сливаете две ветви, Git использует <span><i>рекурсивную</i></span> (recursive) стратегию. Если вы объединяете более двух ветвей, Git выбирает стратегию <span><i>осьминога</i></span> (octopus). Эти стратегии выбираются за вас автоматически потому, что рекурсивная стратегия может обрабатывать сложные трёхсторонние ситуации слияния &mdash; например, более чем один общий предок &mdash; но она может сливать только две ветви. Слияние методом осьминога может справиться с множеством веток, но является более осторожным, чтобы предотвратить сложные конфликты, так что этот метод является стратегией по умолчанию при слиянии более двух веток.</p>
<p>Однако, существуют другие стратегии, которые вы также можете выбрать. Одна из них &mdash; слияние <span><i>поддеревьев</i></span> (subtree), и вы можете использовать его для решения задачи с подпроектами. Сейчас вы увидите, как выполнить то же встраивание rack, как и в предыдущем разделе, но с использованием стратегии слияния поддеревьев.</p>
<p>Идея слияния поддеревьев состоит в том, что у вас есть два проекта, и один из проектов отображается в подкаталог другого и наоборот. Если вы зададите в качестве стратегии слияния метод subtree, то Git будет достаточно умён, чтобы понять, что один из проектов является поддеревом другого и выполнит слияние в соответствии с этим. И это довольно удивительно.</p>
<p>Сначала добавим приложение Rack в проект. Добавим проект Rack как внешнюю ссылку в свой проект, и затем поместим его в отдельную ветку:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;rack_remote&nbsp;git@github.com:schacon/rack.git<br></br>$&nbsp;git&nbsp;fetch&nbsp;rack_remote<br></br>warning:&nbsp;no&nbsp;common&nbsp;commits<br></br>remote:&nbsp;Counting&nbsp;objects:&nbsp;3184,&nbsp;done.<br></br>remote:&nbsp;Compressing&nbsp;objects:&nbsp;100%&nbsp;(1465/1465),&nbsp;done.<br></br>remote:&nbsp;Total&nbsp;3184&nbsp;(delta&nbsp;1952),&nbsp;reused&nbsp;2770&nbsp;(delta&nbsp;1675)<br></br>Receiving&nbsp;objects:&nbsp;100%&nbsp;(3184/3184),&nbsp;677.42&nbsp;KiB&nbsp;|&nbsp;4&nbsp;KiB/s,&nbsp;done.<br></br>Resolving&nbsp;deltas:&nbsp;100%&nbsp;(1952/1952),&nbsp;done.<br></br>From&nbsp;git@github.com:schacon/rack<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;build&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;rack_remote/build<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;rack_remote/master<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rack-0.4&nbsp;&nbsp;&nbsp;-&gt;&nbsp;rack_remote/rack-0.4<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rack-0.9&nbsp;&nbsp;&nbsp;-&gt;&nbsp;rack_remote/rack-0.9<br></br>$&nbsp;git&nbsp;checkout&nbsp;-b&nbsp;rack_branch&nbsp;rack_remote/master<br></br>Branch&nbsp;rack_branch&nbsp;set&nbsp;up&nbsp;to&nbsp;track&nbsp;remote&nbsp;branch&nbsp;refs/remotes/rack_remote/master.<br></br>Switched&nbsp;to&nbsp;a&nbsp;new&nbsp;branch&nbsp;"rack_branch"<br></br></tt></p>
<p>Теперь у нас есть корень проекта Rack в ветке <tt>rack_branch</tt> и наш проект в ветке <tt>master</tt>. Если вы переключитесь на одну ветку, а затем на другую, то увидите, что содержимое их корневых каталогов различно:</p>
<p><tt>$&nbsp;ls<br></br>AUTHORS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KNOWN-ISSUES&nbsp;&nbsp;&nbsp;Rakefile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contrib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lib<br></br>COPYING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;README&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;example&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test<br></br>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>Switched&nbsp;to&nbsp;branch&nbsp;"master"<br></br>$&nbsp;ls<br></br>README<br></br></tt></p>
<p>Допустим, вы хотите поместить проект Rack в подкаталог своего проекта в ветке <tt>master</tt>. Вы можете сделать это в Git'е командой <tt>git read-tree</tt>. Вы узнаете больше про команду <tt>read-tree</tt> и её друзей в главе 9, а пока достаточно знать, что она считывает корень дерева одной ветки в индекс и рабочий каталог. Вам достаточно переключиться обратно на ветку <tt>master</tt> и вытянуть ветку <tt>rack</tt> в подкаталог <tt>rack</tt> основного проекта из ветки <tt>master</tt>:</p>
<p><tt>$&nbsp;git&nbsp;read-tree&nbsp;--prefix=rack/&nbsp;-u&nbsp;rack_branch<br></br></tt></p>
<p>После того как вы сделаете коммит, все файлы проекта Rack будут находиться в этом подкаталоге &mdash; будто вы скопировали их туда из архива. Интересно то, что вы можете довольно легко слить изменения из одной ветки в другую. Так что если проект Rack изменится, вы сможете вытянуть изменения из основного проекта, переключившись в его ветку и выполнив <tt>git pull</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;rack_branch<br></br>$&nbsp;git&nbsp;pull<br></br></tt></p>
<p>Затем вы можете слить эти изменения обратно в свою главную ветку. Можно использовать <tt>git merge -s subtree</tt> &mdash; это сработает правильно, но тогда Git, кроме того, объединит вместе истории, чего вы, вероятно, не хотите. Чтобы получить изменения и заполнить сообщение коммита, используйте опции <tt>--squash</tt> и <tt>--no-commit</tt> вместе с опцией стратегии <tt>-s subtree</tt>:</p>
<p><tt>$&nbsp;git&nbsp;checkout&nbsp;master<br></br>$&nbsp;git&nbsp;merge&nbsp;--squash&nbsp;-s&nbsp;subtree&nbsp;--no-commit&nbsp;rack_branch<br></br>Squash&nbsp;commit&nbsp;--&nbsp;not&nbsp;updating&nbsp;HEAD<br></br>Automatic&nbsp;merge&nbsp;went&nbsp;well;&nbsp;stopped&nbsp;before&nbsp;committing&nbsp;as&nbsp;requested<br></br></tt></p>
<p>Все изменения из проекта Rack слиты и готовы для локальной фиксации. Вы также можете сделать наоборот &mdash; внести изменения в подкаталог <tt>rack</tt> вашей ветки <tt>master</tt>, и затем слить их в ветку <tt>rack_branch</tt>, чтобы позже представить их мейнтейнерам или отправить их в основной репозиторий проекта с помощью <tt>git push</tt>.</p>
<p>Для получения разности между тем, что у вас есть в подкаталоге <tt>rack</tt> и кодом в вашей ветке <tt>rack_branch</tt>, чтобы увидеть нужно ли вам объединять их, вы не можете использовать нормальную команду <tt>diff</tt>. Вместо этого вы должны выполнить <tt>git diff-tree</tt> с веткой, с которой вы хотите сравнить:</p>
<p><tt>$&nbsp;git&nbsp;diff-tree&nbsp;-p&nbsp;rack_branch<br></br></tt></p>
<p>Или, для сравнения того, что в вашем подкаталоге <tt>rack</tt> с тем, что было в ветке <tt>master</tt> на сервере во время последнего обновления, можно выполнить:</p>
<p><tt>$&nbsp;git&nbsp;diff-tree&nbsp;-p&nbsp;rack_remote/master<br></br></tt></p>
<div></div><p id="calibre_link-174"><span><span><b>Итоги</b></span></span></p>
<p>Вы познакомились с рядом продвинутых инструментов, которые позволяют вам манипулировать вашими коммитами и индексом более совершенно. Если вы заметите проблему, то без труда сможете определить, каким коммитом она внесена, когда и кем. Если вы хотите использовать подпроекты в своём проекте &mdash; вы узнали несколько путей, как приспособиться к этим нуждам. К этому моменту вы должны уметь делать в Git'е большинство тех вещей, которые вам понадобятся для повседневной работы в командной строке, и при этом вы будете чувствовать себя комфортно.</p>
<div></div><p id="calibre_link-175"><span><span><b>Настройка Git</b></span></span></p>
<p>До этого момента мы описывали основы того, как Git работает, и как его использовать. Также мы познакомились с несколькими предоставляемыми Git'ом инструментами, которые делают его использование простым и эффективным. В этой главе мы пройдёмся по некоторым действиям, которые вы можете предпринять, чтобы заставить Git работать в нужной именно вам манере. Мы рассмотрим несколько важных настроек и систему перехватчиков (hook). С их помощью легко сделать так, чтобы Git работал именно так, как вам, вашей компании или вашей группе нужно.</p>
<div></div><p id="calibre_link-176"><span><span><b>Конфигурирование Git</b></span></span></p>
<p>В первой главе вкратце было рассказано, как можно изменить настройки Git'а с помощью команды <tt>git config</tt>. Одна из первых вещей, которую мы тогда сделали, это установили свои имя и e-mail адрес:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;user.name&nbsp;"John&nbsp;Doe"<br></br>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;user.email&nbsp;johndoe@example.com<br></br></tt></p>
<p>Теперь мы разберём пару более интересных опций, которые вы можете задать тем же образом, чтобы настроить Git под себя.</p>
<p>Мы уже рассмотрели некоторые детали настройки Git'а в первой главе, но давайте сейчас быстренько пройдёмся по ним снова. Git использует набор конфигурационных файлов для задания желаемого нестандартного поведения. Первым местом, в котором Git ищет заданные параметры, является файл <tt>/etc/gitconfig</tt>, содержащий значения, действующие для всех пользователей системы и всех их репозиториев. Когда вы передаёте <tt>git config</tt> опцию <tt>--system</tt>, происходит чтение или запись именно этого файла.</p>
<p>Следующее место, в которое Git заглядывает, это файл <tt>~/.gitconfig</tt>, который для каждого пользователя свой. Вы можете заставить Git читать или писать этот файл, передав опцию <tt>--global</tt>.</p>
<p>И наконец, Git ищет заданные настройки в конфигурационном файле в Git-каталоге (<tt>.git/config</tt>) того репозитория, который вы используете в данный момент. Значения оттуда относятся к данному конкретному репозиторию. Значения настроек на новом уровне переписывают значения, заданные на предыдущем уровне. Поэтому, например, значения из <tt>.git/config</tt> перебивают значения в <tt>/etc/gitconfig</tt>. Позволяется задавать настройки путём редактирования конфигурационного файла вручную, используя правильный синтаксис, но, как правило, проще воспользоваться командой <tt>git config</tt>.</p>
<p id="calibre_link-177"><span><span><b>Основные настройки клиента</b></span></span></p>
<p>Настройки конфигурации, поддерживаемые Git'ом, можно разделить на две категории: клиентские и серверные. Большинство опций&nbsp;&mdash; клиентские, они задают предпочтения в вашей личной работе. Несмотря на то, что опций доступно великое множество, мы рассмотрим только некоторые из них&nbsp;&mdash; те, которые широко используются или значительно влияют на вашу работу. Многие опции полезны только в редких случаях, которые мы не будем здесь рассматривать. Если вы хотите посмотреть список всех опций, которые есть в вашем Git'е, выполните:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--help<br></br></tt></p>
<p>В странице руководства для <tt>git config</tt> все доступные опции описаны довольно подробно.</p>
<p><span><b>core.editor</b></span></p>
<p>Для создания и редактирования сообщений коммитов и меток Git по умолчанию использует тот редактор, который установлен текстовым редактором по умолчанию в вашей системе, или, как запасной вариант, редактор Vi. Чтобы сменить это умолчание на что-нибудь другое, используйте настройку <tt>core.editor</tt>:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;core.editor&nbsp;emacs<br></br></tt></p>
<p>Теперь неважно, что установлено в качестве вашего редактора по умолчанию в переменной оболочки, при редактировании сообщений Git будет запускать Emacs.</p>
<p><span><b>commit.template</b></span></p>
<p>Если установить в этой настройке путь к какому-нибудь файлу в вашей системе, Git будет использовать содержимое этого файла в качестве сообщения по умолчанию при коммите. Например, предположим, что вы создали шаблонный файл <tt>$HOME/.gitmessage.txt</tt>, который выглядит следующим образом:</p>
<p><tt>заголовок<br></br><br></br>что&nbsp;произошло<br></br><br></br>[карточка:&nbsp;X]<br></br></tt></p>
<p>Чтобы попросить Git использовать это в качестве сообщения по умолчанию, которое будет появляться в вашем редакторе при выполнении <tt>git commit</tt>, задайте значение настройки <tt>commit.template</tt>:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;commit.template&nbsp;$HOME/.gitmessage.txt<br></br>$&nbsp;git&nbsp;commit<br></br></tt></p>
<p>После этого, когда во время создания коммита запустится ваш редактор, в нём в качестве сообщения-заглушки будет находиться что-то вроде такого:</p>
<p><tt>заголовок<br></br><br></br>что&nbsp;произошло<br></br><br></br>[карточка:&nbsp;X]<br></br>#&nbsp;Please&nbsp;enter&nbsp;the&nbsp;commit&nbsp;message&nbsp;for&nbsp;your&nbsp;changes.&nbsp;Lines&nbsp;starting<br></br>#&nbsp;with&nbsp;'#'&nbsp;will&nbsp;be&nbsp;ignored,&nbsp;and&nbsp;an&nbsp;empty&nbsp;message&nbsp;aborts&nbsp;the&nbsp;commit.<br></br>#&nbsp;On&nbsp;branch&nbsp;master<br></br>#&nbsp;Changes&nbsp;to&nbsp;be&nbsp;committed:<br></br>#&nbsp;&nbsp;&nbsp;(use&nbsp;"git&nbsp;reset&nbsp;HEAD&nbsp;&lt;file&gt;..."&nbsp;to&nbsp;unstage)<br></br>#<br></br>#&nbsp;modified:&nbsp;&nbsp;&nbsp;lib/test.rb<br></br>#<br></br>~<br></br>~<br></br>".git/COMMIT_EDITMSG"&nbsp;14L,&nbsp;297C<br></br></tt></p>
<p>Если у вас существует определённая политика для сообщений коммитов, то задание шаблона, соответствующего этой политике, и настройка Git'а на использование его по умолчанию могут увеличить вероятность того, что этой политики будут придерживаться постоянно.</p>
<p><span><b>core.pager</b></span></p>
<p>Настройка core.pager определяет, какой пейджер использовать при постраничном отображении вывода таких команд, как <tt>log</tt> и <tt>diff</tt>. Вы можете указать здесь <tt>more</tt> или свой любимый пейджер (по умолчанию используется <tt>less</tt>), или можно отключить его, указав пустую строку:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;core.pager&nbsp;''<br></br></tt></p>
<p>Если это выполнить, Git будет выдавать весь вывод полностью для всех команд вне зависимости от того, насколько он большой.</p>
<p><span><b>user.signingkey</b></span></p>
<p>Если вы делаете подписанные аннотированные метки (смотри главу 2), то, чтобы облегчить этот процесс, можно задать свой GPG-ключ для подписи в настройках. Задать ID своего ключа можно так:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;user.signingkey&nbsp;&lt;id-gpg-ключа&gt;<br></br></tt></p>
<p>Теперь, чтобы подписать метку, не обязательно каждый раз указывать свой ключ команде <tt>git tag</tt>:</p>
<p><tt>$&nbsp;git&nbsp;tag&nbsp;-s&nbsp;&lt;имя-метки&gt;<br></br></tt></p>
<p><span><b>core.excludesfile</b></span></p>
<p>Чтобы Git не видел определённые файлы проекта как неотслеживаемые и не пытался добавить их в индекс при выполнении <tt>git add</tt>, можно задать для них шаблоны в файл <tt>.gitignore</tt>, как это описано главе 2. Однако, если вам необходим другой файл, который будет хранить эти или дополнительные значения вне вашего проекта, то вы можете указать Git'у расположение такого файла с помощью настройки <tt>core.excludesfile</tt>. Просто задайте там путь к файлу, в котором написано то же, что пишется в <tt>.gitignore</tt>.</p>
<p><span><b>help.autocorrect</b></span></p>
<p>Эта опция доступна только в Git 1.6.1 и более поздних. Если вы неправильно наберёте команду в Git'е, он выдаст что-то вроде этого:</p>
<p><tt>$&nbsp;git&nbsp;com<br></br>git:&nbsp;'com'&nbsp;is&nbsp;not&nbsp;a&nbsp;git-command.&nbsp;See&nbsp;'git&nbsp;--help'.<br></br><br></br>Did&nbsp;you&nbsp;mean&nbsp;this?<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commit<br></br></tt></p>
<p>Если установить <tt>help.autocorrect</tt> в 1, Git автоматически запустит нужную команду, если она была единственным вариантом при этом сценарии.</p>
<p id="calibre_link-178"><span><span><b>Цвета в Git</b></span></span></p>
<p>Git умеет раскрашивать свой вывод для терминала, что может помочь вам быстрее и легче визуально анализировать вывод. Множество опций в настройках помогут вам установить цвета в соответствии со своими предпочтениями.</p>
<p><span><b>color.ui</b></span></p>
<p>Git автоматически раскрасит большую часть своего вывода, если вы его об этом попросите. Вы можете очень тонко задать, что вы хотите раскрасить и как. Но, чтобы просто включить весь предустановленный цветной вывод для терминала, установите <tt>color.ui</tt> в true:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;color.ui&nbsp;true<br></br></tt></p>
<p>Когда установлено это значение, Git раскрашивает свой вывод в случае, если вывод идёт на терминал. Другие доступные значения это: false, при котором вывод никогда не раскрашивается, и always, при котором цвета добавляются всегда, даже если вы перенаправляете вывод команд Git'а в файл или через конвейер другой команде.</p>
<p>Вам вряд ли понадобится использовать <tt>color.ui = always</tt>. В большинстве случаев, если вам нужны коды цветов в перенаправленном выводе, то вы можете просто передать команде флаг <tt>--color</tt>, чтобы заставить её добавить коды цветов. Настройка <tt>color.ui = true</tt>&nbsp;&mdash; это почти всегда именно то, что вам нужно.</p>
<p><tt><span><b>color.*</b></span></tt></p>
<p>Если вам необходимо более точно задать какие команды и как должны быть раскрашены, то в Git'е есть возможность задать настройки цветов для каждой команды отдельно. Каждая из этих настроек может быть установлена в <tt>true</tt>, <tt>false</tt> или <tt>always</tt>:</p>
<p><tt>color.branch<br></br>color.diff<br></br>color.interactive<br></br>color.status<br></br></tt></p>
<p>Кроме того, каждая из этих настроек имеет свои поднастройки, которые можно использовать для задания определённого цвета для какой-то части вывода, если вы хотите перезадать цвета. Например, чтобы получить метаинформацию в выводе команды diff в синем цвете с чёрным фоном и жирным шрифтом, выполните</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;color.diff.meta&nbsp;“blue&nbsp;black&nbsp;bold”<br></br></tt></p>
<p>Цвет может принимать любое из следующих значений: normal, black, red, green, yellow, blue, magenta, cyan и white. Если вы хотите задать атрибут вроде bold, как мы делали в предыдущем примере, то на выбор представлены: bold, dim, ul, blink и reverse.</p>
<p>Если вам это интересно, загляните в страницу руководства для <tt>git config</tt>, чтобы узнать обо всех доступных для конфигурации настройках.</p>
<p id="calibre_link-179"><span><span><b>Внешние утилиты merge и diff</b></span></span></p>
<p>Хоть в Git'е и есть внутренняя реализация diff, которой мы и пользовались до этого момента, вы можете заменить её внешней утилитой. И ещё вы можете установить графическую утилиту для разрешения конфликтов слияния, вместо того, чтобы разрешать конфликты вручную. Мы рассмотрим настройку Perforce Visual Merge Tool (P4Merge) в качестве замены diff и для разрешения конфликтов слияния, потому что это удобная графическая утилита и к тому же бесплатная.</p>
<p>Если вам захотелось её попробовать, то P4Merge работает на всех основных платформах, поэтому проблем с ней быть не должно. В примерах мы будем использовать пути к файлам, которые используются на Mac'е и Linux'е; для Windows вам надо заменить <tt>/usr/local/bin</tt> на тот путь к исполняемым файлам, который используется в вашей среде.</p>
<p>Скачать P4Merge можно здесь:</p>
<p><tt>http://www.perforce.com/perforce/downloads/component.html<br></br></tt></p>
<p>Для начала сделаем внешние сценарии-обёртки для запуска нужных команд. Я буду использовать Mac'овский путь к исполняемым файлам; для других систем это будет тот путь, куда установлен ваш файл <tt>p4merge</tt>. Сделайте для слияния сценарий-обёртку с именем <tt>extMerge</tt>, он будет вызывать бинарник со всеми переданными аргументами:</p>
<p><tt>$&nbsp;cat&nbsp;/usr/local/bin/extMerge<br></br>#!/bin/sh<br></br>/Applications/p4merge.app/Contents/MacOS/p4merge&nbsp;$*<br></br></tt></p>
<p>Обёртка для команды <tt>diff</tt> проверяет, что ей было передано семь аргументов, и передаёт два из них вашему сценарию для слияния. По умолчанию Git передаёт следующие аргументы программе, выполняющей <tt>diff</tt>:</p>
<p><tt>путь&nbsp;старый-файл&nbsp;старый-хеш&nbsp;старые-права&nbsp;новый-файл&nbsp;новый-хеш&nbsp;новые-права<br></br></tt></p>
<p>Так как нам нужны только <tt>старый-файл</tt> и <tt>новый-файл</tt>, воспользуемся сценарием-обёрткой, чтобы передать только те аргументы, которые нам нужны:</p>
<p><tt>$&nbsp;cat&nbsp;/usr/local/bin/extDiff&nbsp;<br></br>#!/bin/sh<br></br>[&nbsp;$#&nbsp;-eq&nbsp;7&nbsp;]&nbsp;&amp;&amp;&nbsp;/usr/local/bin/extMerge&nbsp;"$2"&nbsp;"$5"<br></br></tt></p>
<p>Ещё следует убедиться, что наши сценарии имеют права на исполнение:</p>
<p><tt>$&nbsp;sudo&nbsp;chmod&nbsp;+x&nbsp;/usr/local/bin/extMerge&nbsp;<br></br>$&nbsp;sudo&nbsp;chmod&nbsp;+x&nbsp;/usr/local/bin/extDiff<br></br></tt></p>
<p>Теперь мы можем настроить свой конфигурационный файл на использование наших собственных утилит для разрешения слияний и diff'а. Для этого нам потребуется поменять несколько настроек: <tt>merge.tool</tt>, чтобы указать Git'у на то, какую стратегию использовать; <tt>mergetool.*.cmd</tt>, чтобы указать, как запустить команду; <tt>mergetool.trustExitCode</tt>, чтобы указать Git'у, можно ли по коду возврата определить, было разрешение конфликта слияния успешным или нет; и <tt>diff.external</tt> для того, чтобы задать команду, используемую для diff. Таким образом, вам надо либо выполнить четыре команды <tt>git config</tt></p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;merge.tool&nbsp;extMerge<br></br>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;mergetool.extMerge.cmd&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;&nbsp;'extMerge&nbsp;"$BASE"&nbsp;"$LOCAL"&nbsp;"$REMOTE"&nbsp;"$MERGED"'<br></br>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;mergetool.trustExitCode&nbsp;false<br></br>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;diff.external&nbsp;extDiff<br></br></tt></p>
<p>либо отредактировать свой файл <tt>~/.gitconfig</tt> и добавить туда следующие строки:</p>
<p><tt>[merge]<br></br>&nbsp;&nbsp;tool&nbsp;=&nbsp;extMerge<br></br>[mergetool&nbsp;"extMerge"]<br></br>&nbsp;&nbsp;cmd&nbsp;=&nbsp;extMerge&nbsp;\"$BASE\"&nbsp;\"$LOCAL\"&nbsp;\"$REMOTE\"&nbsp;\"$MERGED\"<br></br>&nbsp;&nbsp;trustExitCode&nbsp;=&nbsp;false<br></br>[diff]<br></br>&nbsp;&nbsp;external&nbsp;=&nbsp;extDiff<br></br></tt></p>
<p>Если после того, как всё это настроено, вы выполните команду <tt>diff</tt> следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;diff&nbsp;32d1776b1^&nbsp;32d1776b1<br></br></tt></p>
<p>то вместо того, чтобы получить вывод команды <tt>diff</tt> в терминал, Git запустит P4Merge, как это показано на рисунке 7-1.</p>
<p><img src="images/000021.jpg"></img></p>
<p>Если при попытке слияния двух веток вы получите конфликт, запустите команду <tt>git mergetool</tt>&nbsp;&mdash; она запустит графическую утилиту P4Merge, с помощью которой вы сможете разрешить свои конфликты.</p>
<p>Что удобно в нашей настройке с обёртками, так это то, что вы с лёгкостью можете поменять утилиты для слияния и diff'а. Например, чтобы изменить свои утилиты <tt>extDiff</tt> и <tt>extMerge</tt> так, чтобы они использовали утилиту KDiff3, всё, что вам надо сделать, это отредактировать свой файл <tt>extMerge</tt>:</p>
<p><tt>$&nbsp;cat&nbsp;/usr/local/bin/extMerge<br></br>#!/bin/sh&nbsp;&nbsp;&nbsp;<br></br>/Applications/kdiff3.app/Contents/MacOS/kdiff3&nbsp;$*<br></br></tt></p>
<p>Теперь Git будет использовать утилиту KDiff3 для просмотра diff'ов и разрешения конфликтов слияния.</p>
<p>В Git'е уже есть предустановленные настройки для множества других утилит для разрешения слияний, для которых вам не надо полностью прописывать команду для запуска, а достаточно просто указать имя утилиты. К таким утилитам относятся: kdiff3, opendiff, tkdiff, meld, xxdiff, emerge, vimdiff и gvimdiff. Например, если вам неинтересно использовать KDiff3 для diff'ов, а хочется использовать его только для разрешения слияний, и команда <tt>kdiff3</tt> находится в пути, то вы можете выполнить</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;merge.tool&nbsp;kdiff3<br></br></tt></p>
<p>Если вместо настройки файлов <tt>extMerge</tt> и <tt>extDiff</tt> вы выполните эту команду, Git будет использовать KDiff3 для разрешения слияний и обычный свой инструмент diff для diff'ов.</p>
<p id="calibre_link-180"><span><span><b>Форматирование и пробельные символы</b></span></span></p>
<p>Проблемы с форматированием и пробельными символами&nbsp;&mdash; одни из самых дурацких и трудноуловимых проблем из тех, с которыми сталкиваются многие разработчики при совместной работе над проектами, особенно если разработка ведётся на разных платформах. Очень просто внести малозаметные изменения с помощью пробельных символов при, например, подготовке патчей из-за того, что текстовые редакторы добавляют их без предупреждения, или в кросс-платформенных проектах Windows-программисты добавляют символы возврата каретки в конце изменяемых ими строк. В Git'е есть несколько опций для того, чтобы помочь с решением подобных проблем.</p>
<p><span><b>core.autocrlf</b></span></p>
<p>Если вы пишете код на Windows или пользуетесь другой системой, но работаете с людьми, которые пишут на Windows, то наверняка рано или поздно столкнётесь с проблемой конца строк. Она возникает из-за того, что Windows использует для переноса строк и символ возврата каретки, и символ перехода на новую строку, в то время как в системах Mac и Linux используется только символ перехода на новую строку. Это незначительное, но невероятно раздражающее обстоятельство при кросс-платформенной работе.</p>
<p>Git может справиться с этим, автоматически конвертируя CRLF-концы строк в LF при коммите и в обратную сторону при выгрузке кода из репозитория на файловую систему. Данную функциональность можно включить с помощью настройки <tt>core.autocrlf</tt>. Если вы используете Windows, установите настройку в <tt>true</tt>, тогда концы строк из LF будут сконвертированы в CRLF при выгрузке кода:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;core.autocrlf&nbsp;true<br></br></tt></p>
<p>Если вы сидите на Linux'е или Mac'е, где используются LF-концы строк, вам не надо, чтобы Git автоматически конвертировал их при выгрузке файлов из репозитория. Однако, если вдруг случайно кто-то добавил файл с CRLF-концами строк, то хотелось бы, чтобы Git исправил это. Можно указать Git'у, чтобы он конвертировал CRLF в LF только при коммитах, установив настройку <tt>core.autocrlf</tt> в <tt>input</tt>:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;core.autocrlf&nbsp;input<br></br></tt></p>
<p>Такая настройка даст вам CRLF-концы в выгруженном коде на Windows-системах и LF-концы на Mac'ах и Linux'е, и в репозитории.</p>
<p>Если вы Windows-программист, пишущий проект, предназначенный только для Windows, то можете отключить данную функциональность и записывать символы возврата каретки в репозиторий, установив значение настройки в <tt>false</tt>:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;core.autocrlf&nbsp;false<br></br></tt></p>
<p><span><b>core.whitespace</b></span></p>
<p>Git заранее настроен на обнаружение и исправление некоторых проблем, связанных с пробелами. Он может находить четыре основные проблемы с пробелами&nbsp;&mdash; две из них по умолчанию отслеживаются, но могут быть выключены, и две по умолчанию не отслеживаются, но их можно включить.</p>
<p>Те две настройки, которые включены по умолчанию&nbsp;&mdash; это <tt>trailing-space</tt>, которая ищет пробелы в конце строк, и <tt>space-before-tab</tt>, которая ищет пробелы перед символами табуляции в начале строк.</p>
<p>Те две, которые по умолчанию выключены, но могут быть включены&nbsp;&mdash; это <tt>indent-with-non-tab</tt>, которая ищет строки, начинающиеся с восьми или более пробелов вместо символов табуляции, и <tt>cr-at-eol</tt>, которая сообщает Git'у, что символы возврата каретки в конце строк допустимы.</p>
<p>Вы можете указать Git'у, какие из этих настроек вы хотите включить, задав их в <tt>core.whitespace</tt> через запятую. Отключить настройку можно либо опустив её в списке, либо дописав знак <tt>-</tt> перед соответствующим значением. Например, если вы хотите установить все проверки, кроме <tt>cr-at-eol</tt>, то это можно сделать так:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;core.whitespace&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;&nbsp;trailing-space,space-before-tab,indent-with-non-tab<br></br></tt></p>
<p>Git будет выявлять эти проблемы при запуске команды <tt>git diff</tt> и пытаться выделить их цветом так, чтобы можно было их исправить ещё до коммита. Кроме того, эти значения будут использоваться, чтобы помочь с применением патчей с помощью <tt>git apply</tt>. Когда будете принимать патч, можете попросить Git предупредить вас о наличии в патче заданных проблем с пробельными символами:</p>
<p><tt>$&nbsp;git&nbsp;apply&nbsp;--whitespace=warn&nbsp;&lt;патч&gt;<br></br></tt></p>
<p>Или же Git может попытаться автоматически исправить проблему перед применением патча:</p>
<p><tt>$&nbsp;git&nbsp;apply&nbsp;--whitespace=fix&nbsp;&lt;патч&gt;<br></br></tt></p>
<p>Данные настройки также относятся и к команде <tt>git rebase</tt>. Если вы вдруг сделали коммиты, в которых есть проблемы с пробельными символами, но ещё не отправили их на сервер, запустите <tt>rebase</tt> с опцией <tt>--whitespace=fix</tt>, чтобы Git автоматически исправил ошибки во время переписывания патчей.</p>
<p id="calibre_link-181"><span><span><b>Настройка сервера</b></span></span></p>
<p>Для серверной части Git'а доступно не так уж много настроек, но среди них есть несколько интересных, на которые следует обратить внимание.</p>
<p><span><b>receive.fsckObjects</b></span></p>
<p>По умолчанию Git не проверяет все отправленные на сервер объекты на целостность. Хотя Git и может проверять, что каждый объект всё ещё совпадает со своей контрольной суммой SHA-1 и указывает на допустимые объекты, по умолчанию Git не делает этого при каждом запуске команды <tt>push</tt>. Эта операция довольно затратна и может значительно увеличить время выполнения <tt>git push</tt> в зависимости от размера репозитория и количества отправляемых данных. Если вы хотите, чтобы Git проверял целостность объектов при каждой отправке данных, сделать это можно, установив <tt>receive.fsckObjects</tt> в true:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--system&nbsp;receive.fsckObjects&nbsp;true<br></br></tt></p>
<p>Теперь Git, перед тем как принять новые данные от клиента, будет проверять целостность вашего репозитория, чтобы убедиться, что какой-нибудь неисправный клиент не внёс повреждённые данные.</p>
<p><span><b>receive.denyNonFastForwards</b></span></p>
<p>Если вы переместили с помощью команды <tt>rebase</tt> уже отправленные на сервер коммиты и затем пытаетесь отправить их снова или, иначе, пытаетесь отправить коммит в такую удалённую ветку, которая не содержит коммит, на который на текущий момент указывает удалённая ветка&nbsp;&mdash; вам будет в этом отказано. Обычно это хорошая стратегия. Но в случае если вы переместили коммиты, хорошо понимая, зачем это вам нужно, вы можете вынудить Git обновить удалённую ветку, передав команде <tt>push</tt> флаг <tt>-f</tt>.</p>
<p>Чтобы отключить возможность принудительного обновления веток, задайте <tt>receive.denyNonFastForwards</tt>:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--system&nbsp;receive.denyNonFastForwards&nbsp;true<br></br></tt></p>
<p>Есть ещё один способ сделать это&nbsp;&mdash; с помощью перехватчиков, работающих на приём (receive hooks), на стороне сервера, которые мы рассмотрим вкратце позднее. Такой подход позволит сделать более сложные вещи, такие как, например, запрет принудительных обновлений только для определённой группы пользователей.</p>
<p><span><b>receive.denyDeletes</b></span></p>
<p>Один из способов обойти политику <tt>denyNonFastForwards</tt>&nbsp;&mdash; это удалить ветку, а затем отправить новую ссылку на её место. В новых версиях Git'а (начиная с версии 1.6.1) вы можете установить <tt>receive.denyDeletes</tt> в true:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--system&nbsp;receive.denyDeletes&nbsp;true<br></br></tt></p>
<p>Этим вы запретите удаление веток и меток с помощью команды <tt>push</tt> для всех сразу&nbsp;&mdash; ни один из пользователей не сможет этого сделать. Чтобы удалить ветку на сервере, вам придётся удалить файлы ссылок с сервера вручную. Также есть и другие более интересные способы добиться этого, но уже для отдельных пользователей с помощью ACL (списков контроля доступа), как мы увидим в конце этой главы.</p>
<div></div><p id="calibre_link-182"><span><span><b>Git-атрибуты</b></span></span></p>
<p>Некоторые настройки могут быть заданы для отдельных путей, и тогда Git будет применять их только для некоторых подкаталогов или набора файлов. Такие настройки, специфичные по отношению к путям, называются атрибутами и задаются либо в файле <tt>.gitattributes</tt> в одном из каталогов проекта (обычно в корне), либо в файле <tt>.git/info/attributes</tt>, если вы не хотите, чтобы файл с атрибутами попал в коммит вместе с остальными файлами проекта.</p>
<p>Использование атрибутов позволяет, например, задать разные стратегии слияния для отдельных файлов или каталогов проекта, или объяснить Git'у, как сравнивать нетекстовые файлы, или сделать так, чтобы Git пропускал данные через фильтр перед тем, как выгрузить или записать данные в репозиторий. В этом разделе мы рассмотрим некоторые из доступных в Git'е атрибутов и рассмотрим несколько практических примеров их использования.</p>
<p id="calibre_link-183"><span><span><b>Бинарные файлы</b></span></span></p>
<p>Есть один клёвый трюк, для которого можно использовать атрибуты&nbsp;&mdash; можно указать Git'у, какие файлы являются бинарными (в случае если по-другому определить это не получается), и дать ему специальные инструкции о том, как с этими файлами работать. Например, некоторые текстовые файлы могут быть машинными&nbsp;&mdash; генерируемыми программой&nbsp;&mdash; для них нет смысла вычислять дельты, в то время как для некоторых бинарных файлов получение дельт может быть полезным. Дальше мы увидим, как сказать Git'у, какие файлы какие.</p>
<p><span><b>Определение бинарных файлов</b></span></p>
<p>Некоторые файлы выглядят как текстовые, но по существу должны рассматриваться как бинарные данные. Например, проекты Xcode на Mac'ах содержат файл, оканчивающийся на <tt>.pbxproj</tt>, который, по сути, является набором JSON-данных (текстовый формат данных для javascript), записываемым IDE, в котором сохраняются ваши настройки сборки и прочее. Хоть технически это и текстовый файл, потому что содержит только ASCII-символы, но нет смысла рассматривать его как таковой, потому что на самом деле это легковесная база данных&nbsp;&mdash; вы не сможете слить её содержимое, если два человека внесут в неё изменение, получение дельт тоже, как правило, ничем вам не поможет. Этот файл предназначается для обработки программой. По сути, лучше рассматривать этот файл как бинарный.</p>
<p>Чтобы заставить Git обращаться со всеми <tt>pbxproj</tt>-файлами как с бинарными, добавьте следующую строку в файл <tt>.gitattributes</tt>:</p>
<p><tt>*.pbxproj&nbsp;-crlf&nbsp;-diff<br></br></tt></p>
<p>Теперь Git не будет пытаться конвертировать CRLF-концы строк или исправлять проблемы с ними. Также он не будет пытаться получить дельту для изменений в этом файле при запуске <tt>git show</tt> или <tt>git diff</tt> в вашем проекте. В Git'е есть предустановленный макрос <tt>binary</tt>, который означает то же, что и <tt>-crlf -diff</tt>:</p>
<p><tt>*.pbxproj&nbsp;binary<br></br></tt></p>
<p><span><b>Получение дельты для бинарных файлов</b></span></p>
<p>Функциональность атрибутов Git'а может быть использована для эффективного получения дельт бинарных файлов. Сделать это можно, объяснив Git'у, как сконвертировать ваши бинарные данные в текстовый формат, для которого можно выполнить сравнение с помощью обычного diff. Осталось только понять, как получить текстовое представление для <span><i>бинарных</i></span> данных. Идеальный вариант &mdash; найти подходящую утилиту для конвертирования нужного формата в текстовый вид. Но, к сожалению, получить хорошее текстовое представление можно только для весьма ограниченного набора бинарных форматов. Для большинства же бинарных форматов, например, для графических или аудио данных, получить читаемый текстовый вид не представляется возможным. Но если мы не можем получить текстовое представление содержимого, мы зачастую можем получить читаемое описание содержимого или метаданные. Метаданные не дают полное представление о содержимом файле, но, во всяком случае, это лучше чем ничего.</p>
<p>Далее мы рассмотрим оба подхода на примерах популярных бинарных форматов.</p>
<p>Замечание: Существуют разные виды бинарных файлов с текстовым содержимым, для которых вам, может быть, не удастся найти подходящий конвёртер. В данном случае вы можете попробовать вытащить текст с помощью утилиты <tt>strings</tt>. Некоторые из таких файлов могут использовать кодировку UTF-16 или могут быть написаны не в латинице, в таких файлах <tt>strings</tt> не найдёт ничего хорошего. Полезность <tt>strings</tt> может сильно варьироваться. Тем не менее, <tt>strings</tt> доступен на большинстве Mac- и Linux-систем, так что он может быть хорошим первым вариантом для того, чтобы сделать подобное со многими бинарными форматами.</p>
<p><span><span><b>Документы MS Word</b></span></span></p>
<p>Для начала мы используем описанный подход, чтобы решить одну из самых раздражающих проблем, известных человечеству: версионный контроль документов Word. Всем известно, что Word &mdash; это самый ужасающий из всех существующих редакторов, но, как ни странно, все им пользуются. Если вы хотите поместить документы Word под версионный контроль, вы можете запихнуть их в Git-репозиторий и время от времени делать коммиты. Но что в этом хорошего? Если вы запустите <tt>git diff</tt> как обычно, то увидите только что-то наподобие этого:</p>
<p><tt>$&nbsp;git&nbsp;diff&nbsp;<br></br>diff&nbsp;--git&nbsp;a/chapter1.doc&nbsp;b/chapter1.doc<br></br>index&nbsp;88839c4..4afcb7c&nbsp;100644<br></br>Binary&nbsp;files&nbsp;a/chapter1.doc&nbsp;and&nbsp;b/chapter1.doc&nbsp;differ<br></br></tt></p>
<p>У вас не получится сравнить две версии между собой, только если вы не выгрузите их обе и просмотрите их вручную, так? Оказывается, можно сделать это достаточно успешно, используя атрибуты Git'а. Поместите следующую строку в свой файл <tt>.gitattributes</tt>:</p>
<p><tt>*.doc&nbsp;diff=word<br></br></tt></p>
<p>Она говорит Git'у, что все файлы, соответствующие указанному шаблону (.doc) должны использовать фильтр "word" при попытке посмотреть дельту с изменениями. Что такое фильтр "word"? Нам нужно его изготовить. Сейчас мы настроим Git на использование программы <tt>catdoc</tt>, специально написанной для того, чтобы вытаскивать текстовую информацию из бинарных документов MS Word (скачать её можно по адресу <tt>http://www.45.free.net/~vitus/software/catdoc/</tt>), для конвертирования документов Word в читаемые текстовые файлы, которые Git затем правильно сравнит:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;diff.word.textconv&nbsp;catdoc<br></br></tt></p>
<p>Этой командой в свой <tt>.git/config</tt> вы добавите следующую секцию:</p>
<p><tt>[diff&nbsp;"word"]<br></br>&nbsp;&nbsp;&nbsp;&nbsp;textconv&nbsp;=&nbsp;catdoc<br></br></tt></p>
<p>Теперь Git знает, что если ему надо найти дельту между двумя снимками состояния, и какие-то их файлы заканчиваются на <tt>.doc</tt>, он должен прогнать эти файлы через фильтр "word", который определён как программа <tt>catdoc</tt>. Так вы фактически сделаете текстовые версии своих Word-файлов перед тем, как получить для них дельту.</p>
<p>Рассмотрим пример. Я поместил главу 1 настоящей книги в Git, добавил немного текста в один параграф и сохранил документ. Затем я выполнил <tt>git diff</tt>, чтобы увидеть, что изменилось:</p>
<p><tt>$&nbsp;git&nbsp;diff<br></br>diff&nbsp;--git&nbsp;a/chapter1.doc&nbsp;b/chapter1.doc<br></br>index&nbsp;c1c8a0a..b93c9e4&nbsp;100644<br></br>---&nbsp;a/chapter1.doc<br></br>+++&nbsp;b/chapter1.doc<br></br>@@&nbsp;-128,7&nbsp;+128,7&nbsp;@@&nbsp;and&nbsp;data&nbsp;size)<br></br>&nbsp;Since&nbsp;its&nbsp;birth&nbsp;in&nbsp;2005,&nbsp;Git&nbsp;has&nbsp;evolved&nbsp;and&nbsp;matured&nbsp;to&nbsp;be&nbsp;easy&nbsp;to&nbsp;use<br></br>&nbsp;and&nbsp;yet&nbsp;retain&nbsp;these&nbsp;initial&nbsp;qualities.&nbsp;It’s&nbsp;incredibly&nbsp;fast,&nbsp;it’s<br></br>&nbsp;very&nbsp;efficient&nbsp;with&nbsp;large&nbsp;projects,&nbsp;and&nbsp;it&nbsp;has&nbsp;an&nbsp;incredible&nbsp;branching<br></br>-system&nbsp;for&nbsp;non-linear&nbsp;development.<br></br>+system&nbsp;for&nbsp;non-linear&nbsp;development&nbsp;(See&nbsp;Chapter&nbsp;3).<br></br></tt></p>
<p>Git коротко и ясно дал мне знать, что я добавил строку "(See Chapter 3)", так оно и есть. Работает идеально.</p>
<p><span><span><b>Текстовые файлы в формате OpenDocument</b></span></span></p>
<p>Тот же подход, который мы использовали для файлов MS Word (<tt>*.doc</tt>), может быть использован и для текстовых файлов в формате OpenDocument, созданных в OpenOffice.org.</p>
<p>Добавим следующую строку в файл <tt>.gitattributes</tt>:</p>
<p><tt>*.odt&nbsp;diff=odt<br></br></tt></p>
<p>Теперь настроим фильтр <tt>odt</tt> в <tt>.git/config</tt>:</p>
<p><tt>[diff&nbsp;"odt"]<br></br>&nbsp;&nbsp;&nbsp;&nbsp;binary&nbsp;=&nbsp;true<br></br>&nbsp;&nbsp;&nbsp;&nbsp;textconv&nbsp;=&nbsp;/usr/local/bin/odt-to-txt<br></br></tt></p>
<p>Файлы в формате OpenDocument на самом деле являются запакованными zip'ом каталогами с множеством файлов (содержимое в XML-формате, таблицы стилей, изображения и т.д.). Мы напишем свой сценарий для извлечения содержимого и вывода его в виде обычного текста. Создайте файл <tt>/usr/local/bin/odt-to-txt</tt> (можете создать его в любом другом каталоге) со следующим содержимым:</p>
<p><tt>#!&nbsp;/usr/bin/env&nbsp;perl<br></br>#&nbsp;Сценарий&nbsp;для&nbsp;конвертации&nbsp;OpenDocument&nbsp;Text&nbsp;(.odt)&nbsp;в&nbsp;обычный&nbsp;текст.<br></br>#&nbsp;Автор:&nbsp;Philipp&nbsp;Kempgen<br></br><br></br>if&nbsp;(!&nbsp;defined($ARGV[0]))&nbsp;{<br></br>&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;STDERR&nbsp;"Не&nbsp;задано&nbsp;имя&nbsp;файла!\n";<br></br>&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;STDERR&nbsp;"Использование:&nbsp;$0&nbsp;имя&nbsp;файла\n";<br></br>&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;1;<br></br>}<br></br><br></br>my&nbsp;$content&nbsp;=&nbsp;'';<br></br>open&nbsp;my&nbsp;$fh,&nbsp;'-|',&nbsp;'unzip',&nbsp;'-qq',&nbsp;'-p',&nbsp;$ARGV[0],&nbsp;'content.xml'&nbsp;or&nbsp;die&nbsp;$!;<br></br>{<br></br>&nbsp;&nbsp;&nbsp;&nbsp;local&nbsp;$/&nbsp;=&nbsp;undef;&nbsp;&nbsp;#&nbsp;считываем&nbsp;файл&nbsp;целиком<br></br>&nbsp;&nbsp;&nbsp;&nbsp;$content&nbsp;=&nbsp;&lt;$fh&gt;;<br></br>}<br></br>close&nbsp;$fh;<br></br>$_&nbsp;=&nbsp;$content;<br></br>s/&lt;text:span\b[^&gt;]*&gt;//g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;удаляем&nbsp;span'ы<br></br>s/&lt;text:h\b[^&gt;]*&gt;/\n\n*****&nbsp;&nbsp;/g;&nbsp;&nbsp;&nbsp;#&nbsp;заголовки<br></br>s/&lt;text:list-item\b[^&gt;]*&gt;\s*&lt;text:p\b[^&gt;]*&gt;/\n&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;&nbsp;/g;&nbsp;&nbsp;#&nbsp;элементы&nbsp;списков<br></br>s/&lt;text:list\b[^&gt;]*&gt;/\n\n/g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;списки<br></br>s/&lt;text:p\b[^&gt;]*&gt;/\n&nbsp;&nbsp;/g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;параграфы<br></br>s/&lt;[^&gt;]+&gt;//g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;удаляем&nbsp;все&nbsp;XML-теги<br></br>s/\n{2,}/\n\n/g;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;удаляем&nbsp;подряд&nbsp;идущие&nbsp;пустые&nbsp;строки<br></br>s/\A\n+//;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;удаляем&nbsp;пустые&nbsp;строки&nbsp;в&nbsp;начале<br></br>print&nbsp;"\n",&nbsp;$_,&nbsp;"\n\n";<br></br></tt></p>
<p>Сделайте его исполняемым</p>
<p><tt>chmod&nbsp;+x&nbsp;/usr/local/bin/odt-to-txt<br></br></tt></p>
<p>Теперь <tt>git diff</tt> сможет сказать вам, что изменилось в <tt>.odt</tt> файлах.</p>
<p><span><span><b>Изображения</b></span></span></p>
<p>Ещё одна интересная проблема, которую можно решить таким способом, это сравнение файлов изображений. Один из способов сделать это&nbsp;&mdash; прогнать PNG-файлы через фильтр, извлекающий их EXIF-информацию&nbsp;&mdash; метаданные, которые дописываются в большинство форматов изображений. Если скачаете и установите программу <tt>exiftool</tt>, то сможете воспользоваться ею, чтобы извлечь из изображений текстовую информацию о метаданных, так чтобы diff хоть как-то показал вам текстовое представление произошедших изменений:</p>
<p><tt>$&nbsp;echo&nbsp;'*.png&nbsp;diff=exif'&nbsp;&gt;&gt;&nbsp;.gitattributes<br></br>$&nbsp;git&nbsp;config&nbsp;diff.exif.textconv&nbsp;exiftool<br></br></tt></p>
<p>Если вы замените в проекте изображение и запустите <tt>git diff</tt>, то получите что-то вроде такого:</p>
<p><tt>diff&nbsp;--git&nbsp;a/image.png&nbsp;b/image.png<br></br>index&nbsp;88839c4..4afcb7c&nbsp;100644<br></br>---&nbsp;a/image.png<br></br>+++&nbsp;b/image.png<br></br>@@&nbsp;-1,12&nbsp;+1,12&nbsp;@@<br></br>&nbsp;ExifTool&nbsp;Version&nbsp;Number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;7.74<br></br>-File&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;70&nbsp;kB<br></br>-File&nbsp;Modification&nbsp;Date/Time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;2009:04:17&nbsp;10:12:35-07:00<br></br>+File&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;94&nbsp;kB<br></br>+File&nbsp;Modification&nbsp;Date/Time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;2009:04:21&nbsp;07:02:43-07:00<br></br>&nbsp;File&nbsp;Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;PNG<br></br>&nbsp;MIME&nbsp;Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;image/png<br></br>-Image&nbsp;Width&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;1058<br></br>-Image&nbsp;Height&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;889<br></br>+Image&nbsp;Width&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;1056<br></br>+Image&nbsp;Height&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;827<br></br>&nbsp;Bit&nbsp;Depth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;8<br></br>&nbsp;Color&nbsp;Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;RGB&nbsp;with&nbsp;Alpha<br></br></tt></p>
<p>Легко можно заметить, что размер файла, а также высота и ширина изображения поменялись.</p>
<p id="calibre_link-184"><span><span><b>Развёртывание ключа</b></span></span></p>
<p>Разработчики, привыкшие к SVN или CVS, часто хотят получить в Git'е возможность развёртывания ключа в стиле этих систем. Основная проблема с реализацией этой функциональности в Git'е это то, что нельзя записать в файл информацию о коммите после того, как коммит был сделан, так как Git сначала считает контрольную сумму для файла. Несмотря на это, вы можете вставлять текст в файл во время его выгрузки и удалять его перед добавлением в коммит. Атрибуты Git'а предлагают два варианта сделать это.</p>
<p>Во-первых, вы можете внедрять SHA-1-сумму блоба в поле <tt>$Id$</tt> в файл автоматически. Если установить соответствующий атрибут для одного или нескольких файлов, то в следующий раз, когда вы будете выгружать данные из этой ветки, Git будет заменять это поле SHA-суммой блоба. Обратите внимание, что это SHA-1 не коммита, а самого блоба.</p>
<p><tt>$&nbsp;echo&nbsp;'*.txt&nbsp;ident'&nbsp;&gt;&gt;&nbsp;.gitattributes<br></br>$&nbsp;echo&nbsp;'$Id$'&nbsp;&gt;&nbsp;test.txt<br></br>$&nbsp;git&nbsp;add&nbsp;test.txt<br></br></tt></p>
<p>В следующий раз, когда вы будете выгружать этот файл, Git автоматически вставит в него SHA его блоба:</p>
<p><tt>$&nbsp;rm&nbsp;test.txt<br></br>$&nbsp;git&nbsp;checkout&nbsp;--&nbsp;test.txt<br></br>$&nbsp;cat&nbsp;test.txt&nbsp;<br></br>$Id:&nbsp;42812b7653c7b88933f8a9d6cad0ca16714b9bb3&nbsp;$<br></br></tt></p>
<p>Однако, такой результат мало применим. Если вы раньше пользовались развёртыванием ключа в CVS или Subversion, можете добавлять метку даты&nbsp;&mdash; SHA не особенно полезен, так как он довольно случаен, и к тому же, глядя на две SHA-суммы, никак не определить какая из них новее.</p>
<p>Как оказывается, можно написать свои собственные фильтры, которые будут делать подстановки в файлах при коммитах и выгрузке файлов. Для этого надо задать фильтры "clean" и "smudge". В файле <tt>.gitattributes</tt> можно задать фильтр для определённых путей и затем установить сценарии, которые будут обрабатывать файлы непосредственно перед выгрузкой ("smudge", см. рис. 7-2) и прямо перед коммитом ("clean", см. рис. 7-3). Эти фильтры можно настроить на совершение абсолютно любых действий.</p>
<p><img src="images/000017.jpg"></img></p>
<p><img src="images/000024.jpg"></img></p>
<p>В сообщении первоначального коммита, добавляющего эту функциональность, дан простой пример того, как можно пропустить весь свой исходный код на C через программу <tt>indent</tt> перед коммитом. Сделать это можно, задав атрибут filter в файле <tt>.gitattributes</tt> так, чтобы он пропускал файлы <tt>*.c</tt> через фильтр "indent":</p>
<p><tt>*.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter=indent<br></br></tt></p>
<p>Затем укажите Git'у, что должен делать фильтр "indent" при smudge и clean:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;filter.indent.clean&nbsp;indent<br></br>$&nbsp;git&nbsp;config&nbsp;--global&nbsp;filter.indent.smudge&nbsp;cat<br></br></tt></p>
<p>В нашем случае, когда вы будете делать коммит, содержащий файлы, соответствующие шаблону <tt>*.c</tt>, Git прогонит их через программу <tt>indent</tt> перед коммитом, а потом через программу <tt>cat</tt> перед тем как выгрузить их на диск. Программа <tt>cat</tt>, по сути, является холостой&nbsp;&mdash; она выдаёт те же данные, которые получила. Фактически эта комбинация профильтровывает все файлы с исходным кодом на C через <tt>indent</tt> перед тем, как сделать коммит.</p>
<p>Ещё один интересный пример&nbsp;&mdash; это развёртывание ключа <tt>$Date$</tt> в стиле RCS. Чтобы сделать его правильно, нам понадобится небольшой сценарий, который принимает на вход имя файла, определяет дату последнего коммита в проекте и вставляет эту дату в наш файл. Вот небольшой сценарий на Ruby, который делает именно это:</p>
<p><tt>#!&nbsp;/usr/bin/env&nbsp;ruby<br></br>data&nbsp;=&nbsp;STDIN.read<br></br>last_date&nbsp;=&nbsp;`git&nbsp;log&nbsp;--pretty=format:"%ad"&nbsp;-1`<br></br>puts&nbsp;data.gsub('$Date$',&nbsp;'$Date:&nbsp;'&nbsp;+&nbsp;last_date.to_s&nbsp;+&nbsp;'$')<br></br></tt></p>
<p>Всё, что делает этот сценарий, это получает дату последнего коммита с помощью команды <tt>git log</tt>, засовывает её во все строки <tt>$Date$</tt>, которые видит в stdin, и выводит результат&nbsp;&mdash; такое должно быть несложно реализовать на любом удобном вам языке. Давайте назовём этот файл <tt>expand_date</tt> и поместим в путь. Теперь в Git'е необходимо настроить фильтр (назовём его <tt>dater</tt>) и указать, что надо использовать фильтр <tt>expand_date</tt> при выполнении smudge во время выгрузки файлов. Воспользуемся регулярным выражением Perl, чтобы убрать изменения при коммите:</p>
<p><tt>$&nbsp;git&nbsp;config&nbsp;filter.dater.smudge&nbsp;expand_date<br></br>$&nbsp;git&nbsp;config&nbsp;filter.dater.clean&nbsp;'perl&nbsp;-pe&nbsp;"s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'<br></br></tt></p>
<p>Этот фрагмент кода на Perl'е вырезает всё, что находит в строке <tt>$Date$</tt> так, чтобы вернуть всё в начальное состояние. Теперь, когда наш фильтр готов, можете протестировать его, создав файл с ключом <tt>$Date$</tt> и установив для этого файла Git-атрибут, который задействует для него новый фильтр:</p>
<p><tt>$&nbsp;echo&nbsp;'#&nbsp;$Date$'&nbsp;&gt;&nbsp;date_test.txt<br></br>$&nbsp;echo&nbsp;'date*.txt&nbsp;filter=dater'&nbsp;&gt;&gt;&nbsp;.gitattributes<br></br></tt></p>
<p>Если мы сейчас добавим эти изменения в коммит и снова выгрузим файл, то мы увидим, что ключевое слово было заменено правильно:</p>
<p><tt>$&nbsp;git&nbsp;add&nbsp;date_test.txt&nbsp;.gitattributes<br></br>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;"Testing&nbsp;date&nbsp;expansion&nbsp;in&nbsp;Git"<br></br>$&nbsp;rm&nbsp;date_test.txt<br></br>$&nbsp;git&nbsp;checkout&nbsp;date_test.txt<br></br>$&nbsp;cat&nbsp;date_test.txt<br></br>#&nbsp;$Date:&nbsp;Tue&nbsp;Apr&nbsp;21&nbsp;07:26:52&nbsp;2009&nbsp;-0700$<br></br></tt></p>
<p>Как видите, такая техника может быть весьма мощной для настройки проекта под свои нужды. Но вы должны быть осторожны, ибо файл <tt>.gitattributes</tt> вы добавите в коммит и будете его распространять вместе с проектом, а драйвер (в нашем случае <tt>dater</tt>)&nbsp;&mdash; нет. Так что не везде оно будет работать. Когда будете проектировать свои фильтры, постарайтесь сделать так, чтобы при возникновении в них ошибки проект не переставал работать правильно.</p>
<p id="calibre_link-185"><span><span><b>Экспорт репозитория</b></span></span></p>
<p>Ещё атрибуты в Git'е позволяют делать некоторые интересные вещи при экспортировании архива с проектом.</p>
<p><span><b>export-ignore</b></span></p>
<p>Вы можете попросить Git не экспортировать определённые файлы и каталоги при создании архива. Если у вас есть подкаталог или файл, который вы не желаете включать в архив, но хотите, чтобы в проекте он был, можете установить для такого файла атрибут <tt>export-ignore</tt>.</p>
<p>Например, скажем, у вас в подкаталоге <tt>test/</tt> имеются некоторые тестовые файлы, и нет никакого смысла добавлять их в тарбол при экспорте проекта. Тогда добавим следующую строку в файл с Git-атрибутами:</p>
<p><tt>test/&nbsp;export-ignore<br></br></tt></p>
<p>Теперь, если вы запустите <tt>git archive</tt>, чтобы создать тарбол с проектом, этот каталог в архив включён не будет.</p>
<p><span><b>export-subst</b></span></p>
<p>Ещё одна вещь, которую можно сделать с архивами,&nbsp;&mdash; это сделать какую-нибудь простую подстановку ключевых слов. Git позволяет добавить в любой файл строку вида <tt>$Format:$</tt> с любыми кодами форматирования, доступными в <tt>--pretty=format</tt> (многие из этих кодов мы рассматривали в главе 2). Например, если вам захотелось добавить в проект файл с именем <tt>LAST_COMMIT</tt>, в который при запуске <tt>git archive</tt> будет автоматически помещаться дата последнего коммита, то такой файл вы можете сделать следующим образом:</p>
<p><tt>$&nbsp;echo&nbsp;'Last&nbsp;commit&nbsp;date:&nbsp;$Format:%cd$'&nbsp;&gt;&nbsp;LAST_COMMIT<br></br>$&nbsp;echo&nbsp;"LAST_COMMIT&nbsp;export-subst"&nbsp;&gt;&gt;&nbsp;.gitattributes<br></br>$&nbsp;git&nbsp;add&nbsp;LAST_COMMIT&nbsp;.gitattributes<br></br>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'adding&nbsp;LAST_COMMIT&nbsp;file&nbsp;for&nbsp;archives'<br></br></tt></p>
<p>После запуска <tt>git archive</tt> этот файл у вас в архиве будет иметь содержимое следующего вида:</p>
<p><tt>$&nbsp;cat&nbsp;LAST_COMMIT<br></br>Last&nbsp;commit&nbsp;date:&nbsp;$Format:Tue&nbsp;Apr&nbsp;21&nbsp;08:38:48&nbsp;2009&nbsp;-0700$<br></br></tt></p>
<p id="calibre_link-186"><span><span><b>Стратегии слияния</b></span></span></p>
<p>Атрибуты Git'а могут также быть использованы для того, чтобы попросить Git использовать другие стратегии слияния для определённых файлов в проекте. Одна очень полезная возможность&nbsp;&mdash; это сказать Git'у, чтобы он не пытался слить некоторые файлы, если для них есть конфликт, а просто выбрал ваш вариант, предпочтя его чужому.</p>
<p>Это полезно в том случае, если ветка в вашем проекте разошлась с исходной, но вам всё же хотелось бы иметь возможность слить изменения из неё обратно, проигнорировав некоторые файлы. Скажем, у вас есть файл с настройками базы данных, который называется database.xml, и в двух ветках он разный, и вы хотите влить другую свою ветку, не трогая файл с настройками базы данных. Задайте атрибут следующим образом:</p>
<p><tt>database.xml&nbsp;merge=ours<br></br></tt></p>
<p>При вливании другой ветки, вместо конфликтов слияния для файла database.xml, вы увидите следующее:</p>
<p><tt>$&nbsp;git&nbsp;merge&nbsp;topic<br></br>Auto-merging&nbsp;database.xml<br></br>Merge&nbsp;made&nbsp;by&nbsp;recursive.<br></br></tt></p>
<p>В данном случае database.xml остался в том варианте, в каком и был изначально.</p>
<div></div><p id="calibre_link-187"><span><span><b>Перехватчики в Git</b></span></span></p>
<p>Как и во многих других системах контроля версий, в Git'е есть возможность запускать собственные сценарии в те моменты, когда происходят некоторые важные действия. Существуют две группы подобных перехватчиков (hook): на стороне клиента и на стороне сервера. Перехватчики на стороне клиента предназначены для клиентских операций, таких как создание коммита и слияние. Перехватчики на стороне сервера нужны для серверных операций, таких как приём отправленных коммитов. Перехватчики могут быть использованы для выполнения самых различных задач. О некоторых из таких задач мы и поговорим.</p>
<p id="calibre_link-188"><span><span><b>Установка перехватчика</b></span></span></p>
<p>Все перехватчики хранятся в подкаталоге <tt>hooks</tt> в Git-каталоге. В большинстве проектов это <tt>.git/hooks</tt>. По умолчанию Git заполняет этот каталог кучей примеров сценариев, многие из которых полезны сами по себе, но кроме того в них задокументированы входные значения для каждого из сценариев. Все эти примеры являются сценариями для командной оболочки с вкраплениями Perl'а, но вообще-то будет работать любой исполняемый сценарий с правильным именем &mdash; вы можете писать их на Ruby или Python или на чём-то ещё, что вам нравится. Эти файлы с примерами перехватчиков оканчиваются на .sample; вам надо их переименовать.</p>
<p>Чтобы активировать сценарий-перехватчик, положите файл в подкаталог <tt>hooks</tt> в Git-каталоге, дайте ему правильное имя и права на исполнение. С этого момента он будет вызываться. Основные имена перехватчиков мы сейчас рассмотрим.</p>
<p id="calibre_link-189"><span><span><b>Перехватчики на стороне клиента</b></span></span></p>
<p>Существует множество перехватчиков, работающих на стороне клиента. В этом разделе они поделены на перехватчики, используемые при работе над коммитами, сценарии, используемые в процессе работы с электронными письмами, и все остальные, работающие на стороне клиента.</p>
<p><span><b>Перехватчики для работы с коммитами</b></span></p>
<p>Первые четыре перехватчика относятся к процессу создания коммита. Перехватчик <tt>pre-commit</tt> запускается первым, ещё до того, как вы наберёте сообщение коммита. Его используют для проверки снимка состояния перед тем, как сделать коммит, чтобы проверить, не забыли ли вы что-нибудь, чтобы убедиться, что вы запустили тесты, или проверить в коде ещё что-нибудь, что вам нужно. Завершение перехватчика с ненулевым кодом прерывает создание коммита, хотя вы можете обойти это с помощью <tt>git commit --no-verify</tt>. Можно, например, проверить стиль кодирования (запускать lint или что-нибудь аналогичное), проверить наличие пробельных символов в конце строк (перехватчик по умолчанию занимается именно этим) или проверить наличие необходимой документации для новых методов.</p>
<p>Перехватчик <tt>prepare-commit-msg</tt> запускается до появления редактора с сообщением коммита, но после создания сообщения по умолчанию. Он позволяет отредактировать сообщение по умолчанию перед тем, как автор коммита его увидит. У этого перехватчика есть несколько опций: путь к файлу, в котором сейчас хранится сообщение коммита, тип коммита и SHA-1 коммита (если в коммит вносится правка с помощью <tt>git commit --amend</tt>). Как правило, данный перехватчик не представляет пользы для обычных коммитов; он скорее хорош для коммитов с автогенерируемыми сообщениями, такими как шаблонные сообщения коммитов, коммиты-слияния, уплотнённые коммиты (squashed commits) и коммиты c исправлениями (amended commits). Данный перехватчик можно использовать в связке с шаблоном для коммита, чтобы программно добавлять в него информацию.</p>
<p>Перехватчик <tt>commit-msg</tt> принимает один параметр, и снова это путь к временному файлу, содержащему текущее сообщение коммита. Когда сценарий завершается с ненулевым кодом, Git прерывает процесс создания коммита. Так что можно использовать его для проверки состояния проекта или сообщений коммита перед тем, как его одобрить. В последнем разделе главы я продемонстрирую, как использовать данный перехватчик, чтобы проверить, что сообщение коммита соответствует требуемому шаблону.</p>
<p>После того, как весь процесс создания коммита завершён, запускается перехватчик <tt>post-commit</tt>. Он не принимает никаких параметров, но вы с лёгкостью можете получить последний коммит, выполнив <tt>git log -1 HEAD</tt>. Как правило, этот сценарий используется для уведомлений или чего-то в этом роде.</p>
<p>Сценарии на стороне клиента, предназначенные для запуска во время работы над коммитами, могут быть использованы при осуществлении практически любого типа рабочего процесса. Их часто используют, чтобы обеспечить соблюдение определённых стандартов, хотя важно отметить, что данные сценарии не передаются при клонировании. Вы можете принудить к соблюдению правил на стороне сервера, отвергая присланные коммиты, если они не подчиняются некоторым правилам, но использование данных сценариев на клиентской стороне полностью зависит только от разработчика. Итак, эти сценарии призваны помочь разработчикам, и это обязанность разработчиков установить и сопровождать их, хотя разработчики и имеют возможность в любой момент подменить их или модифицировать.</p>
<p><span><b>Перехватчики для работы с e-mail</b></span></p>
<p>Для рабочих процессов, основанных на электронной почте, есть три специальных клиентских перехватчика. Все они вызываются командой <tt>git am</tt>, так что, если вы не пользуетесь этой командой в процессе своей работы, то можете смело переходить к следующему разделу. Если вы принимаете патчи, отправленные по e-mail и подготовленные с помощью <tt>git format-patch</tt>, то некоторые из них могут оказаться для вас полезными.</p>
<p>Первый запускаемый перехватчик &mdash; это <tt>applypatch-msg</tt>. Он принимает один аргумент &mdash; имя временного файла, содержащего предлагаемое сообщение коммита. Git прерывает наложение патча, если сценарий завершается с ненулевым кодом. Это может быть использовано для того, чтобы убедиться, что сообщение коммита правильно отформатировано или, чтобы нормализовать сообщение, отредактировав его на месте из сценария.</p>
<p>Следующий перехватчик, запускаемый во время наложения патчей с помощью <tt>git am</tt> &mdash; это <tt>pre-applypatch</tt>. У него нет аргументов, и он запускается после того, как патч наложен, поэтому его можно использовать для проверки снимка состояния перед созданием коммита. Можно запустить тесты или как-то ещё проверить рабочее дерево с помощью этого сценария. Если чего-то не хватает, или тесты не пройдены, выход с ненулевым кодом так же завершает сценарий <tt>git am</tt> без применения патча.</p>
<p>Последний перехватчик, запускаемый во время работы <tt>git am</tt> &mdash; это <tt>post-applypatch</tt>. Его можно использовать для уведомления группы или автора патча о том, что вы его применили. Этим сценарием процесс наложения патча остановить уже нельзя.</p>
<p><span><b>Другие клиентские перехватчики</b></span></p>
<p>Перехватчик <tt>pre-rebase</tt> запускается перед перемещением чего-либо, и может остановить процесс перемещения, если завершится с ненулевым кодом. Этот перехватчик можно использовать, чтобы запретить перемещение любых уже отправленных коммитов. Пример перехватчика <tt>pre-rebase</tt>, устанавливаемый Git'ом, это и делает, хотя он предполагает, что ветка, в которой вы публикуете свои изменения, называется next. Вам, скорее всего, нужно будет заменить это имя на имя своей публичной стабильной ветки.</p>
<p>После успешного выполнения команды <tt>git checkout</tt>, запускается перехватчик <tt>post-checkout</tt>. Его можно использовать для того, чтобы правильно настроить рабочий каталог для своей проектной среды. Под этим может подразумеваться, например, перемещение в каталог больших бинарных файлов, которые вам не хочется включать под версионный контроль, автоматическое генерирование документации или что-то ещё в таком же духе.</p>
<p>И наконец, перехватчик <tt>post-merge</tt> запускается после успешного выполнения команды <tt>merge</tt>. Его можно использовать для восстановления в рабочем дереве данных, которые Git не может отследить, таких как информация о правах. Этот перехватчик может также проверить наличие внешних по отношению к контролируемым Git'ом файлов, которые вам нужно скопировать в каталог при изменениях рабочего дерева.</p>
<p id="calibre_link-190"><span><span><b>Перехватчики на стороне сервера</b></span></span></p>
<p>В дополнение к перехватчикам на стороне клиента вы как системный администратор можете задействовать пару важных перехватчиков на стороне сервера, чтобы навязать в своём проекте правила практически любого вида. Эти сценарии выполняются до и после отправки данных на сервер. Pre-перехватчики могут быть в любое время завершены с ненулевым кодом, чтобы отклонить присланные данные, а также вывести клиенту обратно сообщение об ошибке. Вы можете установить настолько сложные правила приёма данных, насколько захотите.</p>
<p><span><b>pre-receive и post-receive</b></span></p>
<p>Первый сценарий, который выполняется при обработке отправленных клиентом данных, &mdash; это <tt>pre-receive</tt>. Он принимает на вход из stdin список отправленных ссылок; если он завершается с ненулевым кодом, ни одна из них не будет принята. Этот перехватчик можно использовать, чтобы, например, убедиться, что ни одна из обновлённых ссылок не выполняет ничего кроме перемотки, или, чтобы убедиться, что пользователь, запустивший <tt>git push</tt>, имеет права на создание, удаление или изменение для всех файлов, модифицируемых этим push'ем.</p>
<p>Перехватчик <tt>post-receive</tt> запускается после того, как весь процесс завершился, и может быть использован для обновления других сервисов или уведомления пользователей. Он получает на вход из stdin те же данные, что и перехватчик <tt>pre-receive</tt>. Примерами использования могут быть: отправка писем в рассылку, уведомление сервера непрерывной интеграции или обновление карточки (ticket) в системе отслеживания ошибок &mdash; вы можете даже анализировать сообщения коммитов, чтобы выяснить, нужно ли открыть, изменить или закрыть какие-то карточки. Этот сценарий не сможет остановить процесс приёма данных, но клиент не будет отключён до тех пор, пока процесс не завершится; так что будьте осторожны, если хотите сделать что-то, что может занять много времени.</p>
<p><span><b>update</b></span></p>
<p>Сценарий <tt>update</tt> очень похож на сценарий <tt>pre-receive</tt>, за исключением того, что он выполняется для каждой ветки, которую отправитель данных пытается обновить. Если отправитель пытается обновить несколько веток, то <tt>pre-receive</tt> выполнится только один раз, в то время как <tt>update</tt> выполнится по разу для каждой обновляемой ветки. Сценарий не считывает параметры из stdin, а принимает на вход три аргумента: имя ссылки (ветки), SHA-1, на которую ссылка указывала до запуска <tt>push</tt>, и тот SHA-1, который пользователь пытается отправить. Если сценарий <tt>update</tt> завершится с ненулевым кодом, то только одна ссылка будет отклонена, остальные ссылки всё ещё смогут быть обновлены.</p>
<div></div><p id="calibre_link-191"><span><span><b>Пример навязывания политики с помощью Git</b></span></span></p>
<p>В этом разделе мы используем ранее полученные знания для организации в Git'е такого рабочего процесса, который проверяет сообщения коммитов на соответствие заданному формату, из обновлений разрешает только перемотки и позволяет только определённым пользователям изменять определённые подкаталоги внутри проекта. Мы создадим клиентские сценарии, которые помогут разработчикам узнать, будет ли их push отклонён, и серверные сценарии, которые будут действительно вынуждать следовать установленным правилам.</p>
<p>Для их написания я использовал Ruby, и потому что это мой любимый язык сценариев, и потому что из всех языков сценариев он больше всего похож на псевдокод; таким образом, код должен быть вам понятен в общих чертах, даже если вы не пользуетесь Ruby. Однако любой язык сгодится. Все примеры перехватчиков, распространяемые вместе с Git'ом, написаны либо на Perl, либо на Bash, так что вы сможете просмотреть достаточно примеров перехватчиков на этих языках, заглянув в примеры.</p>
<p id="calibre_link-192"><span><span><b>Перехватчик на стороне сервера</b></span></span></p>
<p>Вся работа для сервера будет осуществляться в файле <tt>update</tt> из каталога <tt>hooks</tt>. Файл <tt>update</tt> запускается по разу для каждой отправленной ветки и принимает на вход ссылку, в которую сделано отправление, старую версию, на которой ветка находилась раньше, и новую присланную версию. Кроме того, вам будет доступно имя пользователя, приславшего данные, если <tt>push</tt> был выполнен по SSH. Если вы позволили подключаться всем под одним пользователем (например, "git") с аутентификацией по открытому ключу, то вам может понадобиться создать для этого пользователя обёртку командной оболочки, которая на основе открытого ключа будет определять, какой пользователь осуществил подключение, и записывать этого пользователя в какой-нибудь переменной окружения. Тут я буду предполагать, что имя подключившегося пользователя находится в переменной окружения <tt>$USER</tt>, так что начнём наш сценарий со сбора всей необходимой информации:</p>
<p><tt>#!/usr/bin/env&nbsp;ruby<br></br><br></br>$refname&nbsp;=&nbsp;ARGV[0]<br></br>$oldrev&nbsp;&nbsp;=&nbsp;ARGV[1]<br></br>$newrev&nbsp;&nbsp;=&nbsp;ARGV[2]<br></br>$user&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;ENV['USER']<br></br><br></br>puts&nbsp;"Enforcing&nbsp;Policies...&nbsp;\n(#{$refname})&nbsp;(#{$oldrev[0,6]})&nbsp;(#{$newrev[0,6]})"<br></br></tt></p>
<p>Да, я использую глобальные переменные. Не судите строго &mdash; в таком виде получается нагляднее.</p>
<p><span><b>Установка особого формата сообщений коммитов</b></span></p>
<p>Первая наша задача &mdash; это заставить все сообщения коммитов обязательно придерживаться определённого формата. Просто чтобы было чем заняться, предположим, что каждое сообщение должно содержать строку вида "ref: 1234", так как мы хотим, чтобы каждый коммит был связан с некоторым элементом в нашей системе с карточками. Нам необходимо просмотреть все присланные коммиты, выяснить, есть ли такая строка в сообщении коммита, и, если строка отсутствует в каком-либо из этих коммитов, то завершить сценарий с ненулевым кодом, чтобы <tt>push</tt> был отклонён.</p>
<p>Список значений SHA-1 для всех присланных коммитов можно получить, взяв значения <tt>$newrev</tt> и <tt>$oldrev</tt> и передав их служебной команде <tt>git rev-list</tt>. По сути, это команда <tt>git log</tt>, но по умолчанию она выводит только SHA-1 значения и больше ничего. Таким образом, чтобы получить список SHA для всех коммитов, сделанных между одним SHA коммита и другим, достаточно выполнить следующее:</p>
<p><tt>$&nbsp;git&nbsp;rev-list&nbsp;538c33..d14fc7<br></br>d14fc7c847ab946ec39590d87783c69b031bdfb7<br></br>9f585da4401b0a3999e84113824d15245c13f0be<br></br>234071a1be950e2a8d078e6141f5cd20c1e61ad3<br></br>dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a<br></br>17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475<br></br></tt></p>
<p>Можно взять этот вывод, пройти в цикле по SHA-хешам всех этих коммитов, беря их сообщения и проверяя с помощью регулярного выражения, совпадает ли сообщение с шаблоном.</p>
<p>Нам нужно выяснить, как из всех этих коммитов получить их сообщения, для того, чтобы их протестировать. Чтобы получить данные коммита в сыром виде, можно воспользоваться ещё одной служебной командой, которая называется <tt>git cat-file</tt>. Мы рассмотрим все эти служебные команды более подробно в главе 9, но пока что, вот, что эта команда нам выдала:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;commit&nbsp;ca82a6<br></br>tree&nbsp;cfda3bf379e4f8dba8717dee55aab78aef7f4daf<br></br>parent&nbsp;085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br></br>author&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;&nbsp;1205815931&nbsp;-0700<br></br>committer&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;&nbsp;1240030591&nbsp;-0700<br></br><br></br>changed&nbsp;the&nbsp;version&nbsp;number<br></br></tt></p>
<p>Простой способ получить сообщение коммита для коммита, чьё значение SHA-1 известно, &mdash; это дойти в выводе команды <tt>git cat-file</tt> до первой пустой строки и взять всё, что идёт после неё. В Unix-системах это можно сделать с помощью команды <tt>sed</tt>:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;commit&nbsp;ca82a6&nbsp;|&nbsp;sed&nbsp;'1,/^$/d'<br></br>changed&nbsp;the&nbsp;version&nbsp;number<br></br></tt></p>
<p>Используйте приведённую ниже абракадабру, чтобы получить для каждого отправленного коммита его сообщение и выйти, если обнаружится, что что-то не соответствует требованиям. Если хотим отклонить отправленные данные, выходим с ненулевым кодом. Весь метод целиком выглядит следующим образом:</p>
<p><tt>$regex&nbsp;=&nbsp;/\[ref:&nbsp;(\d+)\]/<br></br><br></br>#&nbsp;принуждает&nbsp;использовать&nbsp;особый&nbsp;формат&nbsp;сообщений<br></br>def&nbsp;check_message_format<br></br>&nbsp;&nbsp;missed_revs&nbsp;=&nbsp;`git&nbsp;rev-list&nbsp;#{$oldrev}..#{$newrev}`.split("\n")<br></br>&nbsp;&nbsp;missed_revs.each&nbsp;do&nbsp;|rev|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;message&nbsp;=&nbsp;`git&nbsp;cat-file&nbsp;commit&nbsp;#{rev}&nbsp;|&nbsp;sed&nbsp;'1,/^$/d'`<br></br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;!$regex.match(message)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts&nbsp;"[POLICY]&nbsp;Your&nbsp;message&nbsp;is&nbsp;not&nbsp;formatted&nbsp;correctly"<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;1<br></br>&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;end<br></br>end<br></br>check_message_format<br></br></tt></p>
<p>Добавив это в свой сценарий <tt>update</tt>, мы запретим обновления, содержащие коммиты, сообщения которых не соблюдают наше правило.</p>
<p><span><b>Настройка системы контроля доступа для пользователей</b></span></p>
<p>Предположим, что нам хотелось бы добавить какой-нибудь механизм для использования списков контроля доступа (ACL), где указано, какие пользователи могут отправлять изменения и в какие части проекта. Несколько людей будут иметь полный доступ, а остальные будут иметь доступ на изменение только некоторых подкаталогов или отдельных файлов. Чтобы обеспечить выполнение такой политики, мы запишем правила в файл <tt>acl</tt>, который будет находиться в нашем "голом" репозитории на сервере. Нам нужно будет, чтобы перехватчик <tt>update</tt> брал эти правила, смотрел на то, какие файлы были изменены присланными коммитами, и определял, имеет ли пользователь, выполнивший <tt>push</tt>, право на обновление всех этих файлов.</p>
<p>Первое, что мы сделаем, &mdash; это напишем свой ACL. Мы сейчас будем использовать формат, очень похожий на механизм ACL в CVS. В нём используется последовательность строк, где первое поле &mdash; это <tt>avail</tt> или <tt>unavail</tt>, следующее поле &mdash; это разделённый запятыми список пользователей, для которых применяется правило, и последнее поле &mdash; это путь, к которому применяется правило (пропуск здесь означает открытый доступ). Все эти поля разделяются вертикальной чертой (<tt>|</tt>).</p>
<p>В нашем примере будет несколько администраторов, сколько-то занимающихся написанием документации с доступом к каталогу <tt>doc</tt> и один разработчик, который имеет доступ только к каталогам <tt>lib</tt> и <tt>tests</tt>, и наш файл <tt>acl</tt> будет выглядеть так:</p>
<p><tt>avail|nickh,pjhyett,defunkt,tpw<br></br>avail|usinclair,cdickens,ebronte|doc<br></br>avail|schacon|lib<br></br>avail|schacon|tests<br></br></tt></p>
<p>Начнём со считывания этих данных в какую-нибудь пригодную для использования структуру. В нашем случае, чтобы не усложнять пример, мы будем применять только директивы <tt>avail</tt>. Вот метод, который даёт нам ассоциативный массив, где ключом является имя пользователя, а значением &mdash; массив путей, для которых пользователь имеет доступ на запись:</p>
<p><tt>def&nbsp;get_acl_access_data(acl_file)<br></br>&nbsp;&nbsp;#&nbsp;считывание&nbsp;данных&nbsp;ACL<br></br>&nbsp;&nbsp;acl_file&nbsp;=&nbsp;File.read(acl_file).split("\n").reject&nbsp;{&nbsp;|line|&nbsp;line&nbsp;==&nbsp;''&nbsp;}<br></br>&nbsp;&nbsp;access&nbsp;=&nbsp;{}<br></br>&nbsp;&nbsp;acl_file.each&nbsp;do&nbsp;|line|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;avail,&nbsp;users,&nbsp;path&nbsp;=&nbsp;line.split('|')<br></br>&nbsp;&nbsp;&nbsp;&nbsp;next&nbsp;unless&nbsp;avail&nbsp;==&nbsp;'avail'<br></br>&nbsp;&nbsp;&nbsp;&nbsp;users.split(',').each&nbsp;do&nbsp;|user|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access[user]&nbsp;||=&nbsp;[]<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access[user]&nbsp;&lt;&lt;&nbsp;path<br></br>&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;access<br></br>end<br></br></tt></p>
<p>Для рассмотренного ранее ACL-файла, метод <tt>get_acl_access_data</tt> вернёт структуру данных следующего вида:</p>
<p><tt>{"defunkt"=&gt;[nil],<br></br>&nbsp;"tpw"=&gt;[nil],<br></br>&nbsp;"nickh"=&gt;[nil],<br></br>&nbsp;"pjhyett"=&gt;[nil],<br></br>&nbsp;"schacon"=&gt;["lib",&nbsp;"tests"],<br></br>&nbsp;"cdickens"=&gt;["doc"],<br></br>&nbsp;"usinclair"=&gt;["doc"],<br></br>&nbsp;"ebronte"=&gt;["doc"]}<br></br></tt></p>
<p>Теперь, когда мы разобрались с правами, нам нужно выяснить, какие пути изменяются присланными коммитами, чтобы можно было убедиться, что пользователь, выполнивший <tt>push</tt>, имеет ко всем ним доступ.</p>
<p>Мы довольно легко можем определить, какие файлы были изменены в одном коммите, с помощью опции <tt>--name-only</tt> для команды <tt>git log</tt> (мы упоминали о ней в главе 2):</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-1&nbsp;--name-only&nbsp;--pretty=format:''&nbsp;9f585d<br></br><br></br>README<br></br>lib/test.rb<br></br></tt></p>
<p>Если мы воспользуемся ACL-структурой, полученной из метода <tt>get_acl_access_data</tt>, и сверим её со списком файлов для каждого коммита, то мы сможем определить, имеет ли пользователь право на отправку своих коммитов:</p>
<p><tt>#&nbsp;некоторые&nbsp;подкаталоги&nbsp;в&nbsp;проекте&nbsp;разрешено&nbsp;модифицировать&nbsp;только&nbsp;определённым&nbsp;пользователям<br></br>def&nbsp;check_directory_perms<br></br>&nbsp;&nbsp;access&nbsp;=&nbsp;get_acl_access_data('acl')<br></br><br></br>&nbsp;&nbsp;#&nbsp;проверим,&nbsp;что&nbsp;никто&nbsp;не&nbsp;пытается&nbsp;прислать&nbsp;чего-то,&nbsp;что&nbsp;ему&nbsp;нельзя<br></br>&nbsp;&nbsp;new_commits&nbsp;=&nbsp;`git&nbsp;rev-list&nbsp;#{$oldrev}..#{$newrev}`.split("\n")<br></br>&nbsp;&nbsp;new_commits.each&nbsp;do&nbsp;|rev|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;files_modified&nbsp;=&nbsp;`git&nbsp;log&nbsp;-1&nbsp;--name-only&nbsp;--pretty=format:''&nbsp;#{rev}`.split("\n")<br></br>&nbsp;&nbsp;&nbsp;&nbsp;files_modified.each&nbsp;do&nbsp;|path|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next&nbsp;if&nbsp;path.size&nbsp;==&nbsp;0<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_file_access&nbsp;=&nbsp;false<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access[$user].each&nbsp;do&nbsp;|access_path|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;!access_path&nbsp;||&nbsp;#&nbsp;пользователь&nbsp;имеет&nbsp;полный&nbsp;доступ<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(path.index(access_path)&nbsp;==&nbsp;0)&nbsp;#&nbsp;доступ&nbsp;к&nbsp;этому&nbsp;пути<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_file_access&nbsp;=&nbsp;true&nbsp;<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;!has_file_access<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts&nbsp;"[POLICY]&nbsp;You&nbsp;do&nbsp;not&nbsp;have&nbsp;access&nbsp;to&nbsp;push&nbsp;to&nbsp;#{path}"<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;1<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;end&nbsp;&nbsp;<br></br>end<br></br><br></br>check_directory_perms<br></br></tt></p>
<p>Большую часть этого кода должно быть не сложно понять. Мы получаем список присланных на сервер коммитов с помощью <tt>git rev-list</tt>. Затем для каждого из них мы узнаём, какие файлы были изменены, и убеждаемся, что пользователь, сделавший <tt>push</tt>, имеет доступ ко всем изменённым путям. Один Ruby'изм, который может быть непонятен &mdash; это <tt>path.index(access_path) == 0</tt>. Это условие верно, если <tt>path</tt> начинается с <tt>access_path</tt> &mdash; оно гарантирует, что <tt>access_path</tt> &mdash; это не просто один из разрешённых путей, а что каждый путь, к которому запрашивается доступ, начинается с одного из разрешённых путей.</p>
<p>Теперь наши пользователи не смогут отправить никаких коммитов с плохо отформатированными сообщениями и не смогут изменить файлы вне предназначенных для них путей.</p>
<p><span><b>Разрешение только обновлений-перемоток</b></span></p>
<p>Единственное, что нам осталось &mdash; это оставить доступными только обновления-перемотки. Чтобы добиться этого, можно просто задать настройки <tt>receive.denyDeletes</tt> и <tt>receive.denyNonFastForwards</tt>. Но осуществление этого с помощью перехватчика также будет работать, и к тому же вы сможете изменить его так, чтобы запрет действовал только для определённых пользователей, или ещё как-то, как вам захочется.</p>
<p>Логика здесь такая &mdash; мы проверяем, есть ли такие коммиты, которые достижимы из старой версии и не достижимы из новой. Если таких нет, то сделанный <tt>push</tt> был перемоткой; в противном случае мы его запрещаем:</p>
<p><tt>#&nbsp;разрешаем&nbsp;только&nbsp;обновления-перемотки<br></br>def&nbsp;check_fast_forward<br></br>&nbsp;&nbsp;missed_refs&nbsp;=&nbsp;`git&nbsp;rev-list&nbsp;#{$newrev}..#{$oldrev}`<br></br>&nbsp;&nbsp;missed_ref_count&nbsp;=&nbsp;missed_refs.split("\n").size<br></br>&nbsp;&nbsp;if&nbsp;missed_ref_count&nbsp;&gt;&nbsp;0<br></br>&nbsp;&nbsp;&nbsp;&nbsp;puts&nbsp;"[POLICY]&nbsp;Cannot&nbsp;push&nbsp;a&nbsp;non&nbsp;fast-forward&nbsp;reference"<br></br>&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;1<br></br>&nbsp;&nbsp;end<br></br>end<br></br><br></br>check_fast_forward<br></br></tt></p>
<p>Всё готово. Если вы выполните <tt>chmod u+x .git/hooks/update</tt> (а это тот файл, в который вы должны были поместить весь наш код) и затем попытаетесь отправить ссылку, для которой нельзя выполнить перемотку, то вы получите что-то типа такого:</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;-f&nbsp;origin&nbsp;master<br></br>Counting&nbsp;objects:&nbsp;5,&nbsp;done.<br></br>Compressing&nbsp;objects:&nbsp;100%&nbsp;(3/3),&nbsp;done.<br></br>Writing&nbsp;objects:&nbsp;100%&nbsp;(3/3),&nbsp;323&nbsp;bytes,&nbsp;done.<br></br>Total&nbsp;3&nbsp;(delta&nbsp;1),&nbsp;reused&nbsp;0&nbsp;(delta&nbsp;0)<br></br>Unpacking&nbsp;objects:&nbsp;100%&nbsp;(3/3),&nbsp;done.<br></br>Enforcing&nbsp;Policies...&nbsp;<br></br>(refs/heads/master)&nbsp;(8338c5)&nbsp;(c5b616)<br></br>[POLICY]&nbsp;Cannot&nbsp;push&nbsp;a&nbsp;non&nbsp;fast-forward&nbsp;reference<br></br>error:&nbsp;hooks/update&nbsp;exited&nbsp;with&nbsp;error&nbsp;code&nbsp;1<br></br>error:&nbsp;hook&nbsp;declined&nbsp;to&nbsp;update&nbsp;refs/heads/master<br></br>To&nbsp;git@gitserver:project.git<br></br>&nbsp;!&nbsp;[remote&nbsp;rejected]&nbsp;master&nbsp;-&gt;&nbsp;master&nbsp;(hook&nbsp;declined)<br></br>error:&nbsp;failed&nbsp;to&nbsp;push&nbsp;some&nbsp;refs&nbsp;to&nbsp;'git@gitserver:project.git'<br></br></tt></p>
<p>Тут есть пара интересных моментов. Во-первых, когда перехватчик начинает свою работу, мы видим это:</p>
<p><tt>Enforcing&nbsp;Policies...&nbsp;<br></br>(refs/heads/master)&nbsp;(8338c5)&nbsp;(c56860)<br></br></tt></p>
<p>Обратите внимание, что мы выводили это в stdout в самом начале нашего сценария <tt>update</tt>. Важно отметить, что всё, что сценарий выводит в stdout, будет передано клиенту.</p>
<p>Следующая вещь, которую мы видим, это сообщение об ошибке:</p>
<p><tt>[POLICY]&nbsp;Cannot&nbsp;push&nbsp;a&nbsp;non&nbsp;fast-forward&nbsp;reference<br></br>error:&nbsp;hooks/update&nbsp;exited&nbsp;with&nbsp;error&nbsp;code&nbsp;1<br></br>error:&nbsp;hook&nbsp;declined&nbsp;to&nbsp;update&nbsp;refs/heads/master<br></br></tt></p>
<p>Первую строку напечатали мы, а в остальных двух Git сообщает, что сценарий <tt>update</tt> завершился с ненулевым кодом, и это именно то, что отклонило ваш <tt>push</tt>. И, наконец, мы видим это:</p>
<p><tt>To&nbsp;git@gitserver:project.git<br></br>&nbsp;!&nbsp;[remote&nbsp;rejected]&nbsp;master&nbsp;-&gt;&nbsp;master&nbsp;(hook&nbsp;declined)<br></br>error:&nbsp;failed&nbsp;to&nbsp;push&nbsp;some&nbsp;refs&nbsp;to&nbsp;'git@gitserver:project.git'<br></br></tt></p>
<p>Сообщение "remote rejected" будет появляться для каждой отклонённой перехватчиком ссылки. Оно сообщает нам, что ссылка была отклонена именно из-за сбоя в перехватчике.</p>
<p>Кроме того, при отсутствии отметки "ref" в каком-либо из коммитов, вы увидите сообщение об ошибке, которое мы для этого напечатали.</p>
<p><tt>[POLICY]&nbsp;Your&nbsp;message&nbsp;is&nbsp;not&nbsp;formatted&nbsp;correctly<br></br></tt></p>
<p>Или если кто-то попытается отредактировать файл, не имея к нему доступа, то, отправив коммит с этими изменениями, он получит похожее сообщение. Например, если человек, пишущий документацию, попытается отправить коммит, вносящий изменения в файлы каталога <tt>lib</tt>, то увидит:</p>
<p><tt>[POLICY]&nbsp;You&nbsp;do&nbsp;not&nbsp;have&nbsp;access&nbsp;to&nbsp;push&nbsp;to&nbsp;lib/test.rb<br></br></tt></p>
<p>Вот и всё. С этого момента, до тех пор пока сценарий <tt>update</tt> находится на своём месте и имеет права на исполнение, репозиторий никогда не будет откатан назад, в нём никогда не будет коммитов с сообщениями без вашего паттерна, и пользователи будут ограничены в доступе к файлам.</p>
<p id="calibre_link-193"><span><span><b>Перехватчики на стороне клиента</b></span></span></p>
<p>Обратная сторона такого подхода &mdash; это многочисленные жалобы, которые неизбежно появятся, когда отправленные пользователями коммиты будут отклонены. Когда чью-то тщательно оформленную работу отклоняют в последний момент, этот человек может быть сильно расстроен и смущён. Мало того, ему придётся отредактировать свою историю, чтобы откорректировать её, а это обычно не для слабонервных.</p>
<p>Решение данной проблемы &mdash; предоставить пользователям какие-нибудь перехватчики, которые будут работать на стороне пользователя и будут сообщать ему, если он делает что-то, что, скорее всего, будет отклонено. При таком подходе, пользователи смогут исправить любые проблемы до создания коммита и до того, как эти проблемы станет сложно исправить. Так как перехватчики не пересылаются при клонировании проекта, вам придётся распространять эти сценарии каким-то другим способом и потом сделать так, чтобы ваши пользователи скопировали их в свой каталог <tt>.git/hooks</tt> и сделали их исполняемыми. Эти перехватчики можно поместить в свой проект или даже в отдельный проект, но способа установить их автоматически не существует.</p>
<p>Для начала, перед записью каждого коммита нам надо проверить его сообщение, чтобы быть уверенным, что сервер не отклонит изменения из-за плохо отформатированного сообщения коммита. Чтобы сделать это, добавим перехватчик <tt>commit-msg</tt>. Если мы сможем прочитать сообщение из файла, переданного в качестве первого аргумента, и сравнить его с шаблоном, то можно заставить Git прервать создание коммита при обнаружении несовпадения:</p>
<p><tt>#!/usr/bin/env&nbsp;ruby<br></br>message_file&nbsp;=&nbsp;ARGV[0]<br></br>message&nbsp;=&nbsp;File.read(message_file)<br></br><br></br>$regex&nbsp;=&nbsp;/\[ref:&nbsp;(\d+)\]/<br></br><br></br>if&nbsp;!$regex.match(message)<br></br>&nbsp;&nbsp;puts&nbsp;"[POLICY]&nbsp;Your&nbsp;message&nbsp;is&nbsp;not&nbsp;formatted&nbsp;correctly"<br></br>&nbsp;&nbsp;exit&nbsp;1<br></br>end<br></br></tt></p>
<p>Если этот сценарий находится на своём месте (в <tt>.git/hooks/commit-msg</tt>) и имеет права на исполнение, то при создании коммита с неправильно оформленным сообщением вы увидите это:</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'test'<br></br>[POLICY]&nbsp;Your&nbsp;message&nbsp;is&nbsp;not&nbsp;formatted&nbsp;correctly<br></br></tt></p>
<p>В этом случае коммит не был завершён. Однако, когда сообщение содержит правильный шаблон, Git позволяет создать коммит:</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'test&nbsp;[ref:&nbsp;132]'<br></br>[master&nbsp;e05c914]&nbsp;test&nbsp;[ref:&nbsp;132]<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p>Далее мы хотим убедиться, что пользователь не модифицирует файлы вне своей области, заданной в ACL. Если в проекте в каталоге <tt>.git</tt> уже есть копия файла <tt>acl</tt>, который мы использовали ранее, то сценарий <tt>pre-commit</tt> следующего вида применит эти ограничения:</p>
<p><tt>#!/usr/bin/env&nbsp;ruby<br></br><br></br>$user&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;ENV['USER']<br></br><br></br>#&nbsp;[&nbsp;insert&nbsp;acl_access_data&nbsp;method&nbsp;from&nbsp;above&nbsp;]<br></br><br></br>#&nbsp;некоторые&nbsp;подкаталоги&nbsp;в&nbsp;проекте&nbsp;разрешено&nbsp;модифицировать&nbsp;только&nbsp;определённым&nbsp;пользователям<br></br>def&nbsp;check_directory_perms<br></br>&nbsp;&nbsp;access&nbsp;=&nbsp;get_acl_access_data('.git/acl')<br></br><br></br>&nbsp;&nbsp;files_modified&nbsp;=&nbsp;`git&nbsp;diff-index&nbsp;--cached&nbsp;--name-only&nbsp;HEAD`.split("\n")<br></br>&nbsp;&nbsp;files_modified.each&nbsp;do&nbsp;|path|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;next&nbsp;if&nbsp;path.size&nbsp;==&nbsp;0<br></br>&nbsp;&nbsp;&nbsp;&nbsp;has_file_access&nbsp;=&nbsp;false<br></br>&nbsp;&nbsp;&nbsp;&nbsp;access[$user].each&nbsp;do&nbsp;|access_path|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;!access_path&nbsp;||&nbsp;(path.index(access_path)&nbsp;==&nbsp;0)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_file_access&nbsp;=&nbsp;true<br></br>&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;!has_file_access<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts&nbsp;"[POLICY]&nbsp;You&nbsp;do&nbsp;not&nbsp;have&nbsp;access&nbsp;to&nbsp;push&nbsp;to&nbsp;#{path}"<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;1<br></br>&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;end<br></br>end<br></br><br></br>check_directory_perms<br></br></tt></p>
<p>Это примерно тот же сценарий, что и на стороне сервера, но с двумя важными отличиями. Первое &mdash; файл <tt>acl</tt> находится в другом месте, так как этот сценарий теперь запускается из рабочего каталога, а не из Git-каталога. Нужно изменить путь к ACL-файлу с этого:</p>
<p><tt>access&nbsp;=&nbsp;get_acl_access_data('acl')<br></br></tt></p>
<p>на этот:</p>
<p><tt>access&nbsp;=&nbsp;get_acl_access_data('.git/acl')<br></br></tt></p>
<p>Другое важное отличие &mdash; это способ получения списка изменённых файлов. Так как метод, действующий на стороне сервера, смотрит в лог коммитов, а сейчас коммит ещё не был записан, нам надо получить список файлов из индекса. Вместо</p>
<p><tt>files_modified&nbsp;=&nbsp;`git&nbsp;log&nbsp;-1&nbsp;--name-only&nbsp;--pretty=format:''&nbsp;#{ref}`<br></br></tt></p>
<p>мы должны использовать</p>
<p><tt>files_modified&nbsp;=&nbsp;`git&nbsp;diff-index&nbsp;--cached&nbsp;--name-only&nbsp;HEAD`<br></br></tt></p>
<p>Но это единственные два отличия &mdash; во всём остальном этот сценарий работает точно так же. Но надо предупредить, что он предполагает, что локально вы работаете под тем же пользователем, от имени которого отправляете изменения на удалённый сервер. Если это не так, то вам необходимо задать переменную <tt>$user</tt> вручную.</p>
<p>Последнее, что нам нужно сделать, &mdash; это проверить, что пользователь не пытается отправить ссылки не с перемоткой, но это случается не так часто. Чтобы получились ссылки, не являющиеся перемоткой, надо либо переместить ветку за уже отправленный коммит, либо попытаться отправить другую локальную ветку в ту же самую удалённую ветку.</p>
<p>Так как сервер в любом случае сообщит вам о том, что нельзя отправлять обновления, не являющиеся перемоткой, а перехватчик запрещает принудительные <tt>push</tt>'и, единственная оплошность, которую вы можете попробовать предотвратить, это перемещение коммитов, которые уже были отправлены на сервер.</p>
<p>Вот пример сценария <tt>pre-rebase</tt>, который это проверяет. Он принимает на вход список всех коммитов, которые вы собираетесь переписать, и проверяет, нет ли их в какой-нибудь из ваших удалённых веток. Если найдётся такой коммит, который достижим из одной из удалённых веток, сценарий прервёт выполнение перемещения:</p>
<p><tt>#!/usr/bin/env&nbsp;ruby<br></br><br></br>base_branch&nbsp;=&nbsp;ARGV[0]<br></br>if&nbsp;ARGV[1]<br></br>&nbsp;&nbsp;topic_branch&nbsp;=&nbsp;ARGV[1]<br></br>else<br></br>&nbsp;&nbsp;topic_branch&nbsp;=&nbsp;"HEAD"<br></br>end<br></br><br></br>target_shas&nbsp;=&nbsp;`git&nbsp;rev-list&nbsp;#{base_branch}..#{topic_branch}`.split("\n")<br></br>remote_refs&nbsp;=&nbsp;`git&nbsp;branch&nbsp;-r`.split("\n").map&nbsp;{&nbsp;|r|&nbsp;r.strip&nbsp;}<br></br><br></br>target_shas.each&nbsp;do&nbsp;|sha|<br></br>&nbsp;&nbsp;remote_refs.each&nbsp;do&nbsp;|remote_ref|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;shas_pushed&nbsp;=&nbsp;`git&nbsp;rev-list&nbsp;^#{sha}^@&nbsp;refs/remotes/#{remote_ref}`<br></br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;shas_pushed.split(“\n”).include?(sha)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts&nbsp;"[POLICY]&nbsp;Commit&nbsp;#{sha}&nbsp;has&nbsp;already&nbsp;been&nbsp;pushed&nbsp;to&nbsp;#{remote_ref}"<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;1<br></br>&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;end<br></br>end<br></br></tt></p>
<p>Этот сценарий использует синтаксис, который мы не рассматривали в разделе "Выбор ревизии" в главе 6. Мы получили список коммитов, которые уже были отправлены на сервер, выполнив это:</p>
<p><tt>git&nbsp;rev-list&nbsp;^#{sha}^@&nbsp;refs/remotes/#{remote_ref}<br></br></tt></p>
<p>Запись <tt>SHA^@</tt> означает всех родителей указанного коммита. Мы ищем какой-нибудь коммит, который достижим из последнего коммита в удалённой ветке и не достижим ни из одного из родителей какого-либо SHA, который вы пытаетесь отправить на сервер &mdash; это значит, что это перемотка.</p>
<p>Главный недостаток такого подхода &mdash; это то, что проверка может быть очень медленной и зачастую избыточной &mdash; если вы не пытаетесь отправить данные принудительно с помощью <tt>-f</tt>, сервер и так выдаст предупреждение и не примет данные. Однако, это интересное упражнение и теоретически может помочь вам избежать перемещения, к которому потом придётся вернуться, чтобы исправить.</p>
<div></div><p id="calibre_link-194"><span><span><b>Итоги</b></span></span></p>
<p>Мы рассмотрели большинство основных способов настройки клиента и сервера Git'а с тем, чтобы он был максимально удобен для ваших проектов и при вашей организации рабочего процесса. Мы узнали о всевозможных настройках, атрибутах файлов и о перехватчиках событий, а также рассмотрели пример настройки сервера с соблюдением политики. Теперь вам должно быть по плечу заставить Git подстроиться под практически любой тип рабочего процесса, который можно вообразить.</p>
<div></div><p id="calibre_link-195"><span><span><b>Git и другие системы контроля версий</b></span></span></p>
<p>Наш мир несовершенен. Как правило, вы не сможете моментально перевести любой проект, в котором вы участвуете, на использование Git'а. Иногда вам придётся иметь дело с проектами, использующими другую систему контроля версий, и, в большинстве случаев, этой системой будет Subversion. Первая часть этого раздела научит вас обращаться с <tt>git svn</tt> &mdash; встроенным в Git двухсторонним интерфейсом обмена с Subversion.</p>
<p>В какой-то момент, вы, возможно, захотите перевести свой существующий проект на Git. Вторая часть раздела расскажет о том, как провести миграцию: сначала с Subversion, потом с Perforce, и наконец, с помощью написания собственного сценария для нестандартных вариантов миграции.</p>
<div></div><p id="calibre_link-196"><span><span><b>Git и Subversion</b></span></span></p>
<p>В настоящее время большинство проектов с открытым исходным кодом, а также большое число корпоративных проектов, используют Subversion для управления своим исходным кодом. Это самая популярная на текущий момент система контроля версий с открытым исходным кодом, история её использования насчитывает около 10 лет. Кроме того, она очень похожа на CVS, систему, которая была самой популярной до Subversion.</p>
<p>Одна из замечательных особенностей Git'а &mdash; возможность двустороннего обмена с Subversion через интерфейс, называемый <tt>git svn</tt>. Этот инструмент позволяет использовать Git в качестве корректного клиента при работе с сервером Subversion. Так что вы можете пользоваться всеми локальными возможностями Git'а, а затем сохранять изменения на сервере Subversion так, как если бы использовали Subversion локально. То есть вы можете делать локальное ветвление и слияние, использовать индекс, перемещение и отбор патчей для переноса из одной ветви в другую (cherry-picking) и т.д., в то время как ваши коллеги будут продолжать использовать в разработке подход времён каменного века. Это хороший способ протащить Git в рабочее окружение своей компании и помочь коллегам разработчикам стать более эффективными, в то время как вы будете лоббировать переход полностью на Git. Интерфейс обмена с Subversion &mdash; это ворота в мир распределённых систем контроля версий.</p>
<p id="calibre_link-197"><span><span><b>git svn</b></span></span></p>
<p>Базовой командой в Git'е для всех команд, работающих с мостом к Subversion, является <tt>git svn</tt>. Ей предваряется любая команда. Она принимает довольно порядочное число команд, поэтому мы изучим из них те, которые наиболее часто используются, рассмотрев несколько небольших вариантов работы.</p>
<p>Важно отметить, что при использовании <tt>git svn</tt> вы взаимодействуете с Subversion &mdash; системой, которая намного менее «продвинута», чем Git. Хоть вы и умеете с лёгкостью делать локальное ветвление и слияние, как правило, лучше всего держать свою историю в как можно более линейном виде, используя перемещения (rebase) и избегая таких вещей, как одновременный обмен с удалённым Git-репозиторием.</p>
<p>Не переписывайте свою историю, попробуйте отправить изменения ещё раз, а также не отправляйте изменения в параллельный Git-репозиторий, используемый для совместной работы, одновременно с другими разработчиками, использующими Git. Subversion может иметь только одну единственную линейную историю изменений, сбить с толку которую очень и очень просто. Если вы работаете в команде, в которой некоторые разработчики используют Git, а другие Subversion, убедитесь, что для совместной работы все используют только SVN-сервер &mdash; это сильно упростит вам жизнь.</p>
<p id="calibre_link-198"><span><span><b>Настройка</b></span></span></p>
<p>Для того чтобы попробовать этот функционал в действии, вам понадобится доступ с правами на запись к обычному SVN-репозиторию. Если вы хотите повторить рассматриваемые примеры, вам нужно сделать доступную на запись копию моего тестового репозитория. Это можно сделать без труда с помощью утилиты <tt>svnsync</tt>, входящей в состав последних версий Subversion (по крайней мере после версии 1.4). Для этих примеров я создал новый Subversion-репозиторий на Google Code, который был частичной копией проекта <tt>protobuf</tt> (утилита кодирования структурированных данных для их передачи по сети).</p>
<p>Чтобы мы могли продолжить, прежде всего создайте новый локальный репозиторий Subversion:</p>
<p><tt>$&nbsp;mkdir&nbsp;/tmp/test-svn<br></br>$&nbsp;svnadmin&nbsp;create&nbsp;/tmp/test-svn<br></br></tt></p>
<p>Затем разрешите всем пользователям изменять <tt>revprops</tt> &mdash; самым простым способом сделать это будет добавление сценария <tt>pre-revprop-change</tt>, который просто всегда завершается с кодом 0:</p>
<p><tt>$&nbsp;cat&nbsp;/tmp/test-svn/hooks/pre-revprop-change&nbsp;<br></br>#!/bin/sh<br></br>exit&nbsp;0;<br></br>$&nbsp;chmod&nbsp;+x&nbsp;/tmp/test-svn/hooks/pre-revprop-change<br></br></tt></p>
<p>Теперь вы можете синхронизировать проект со своей локальной машиной, вызвав <tt>svnsync init</tt> с параметрами, задающими исходный и целевой репозиторий:</p>
<p><tt>$&nbsp;svnsync&nbsp;init&nbsp;file:///tmp/test-svn&nbsp;http://progit-example.googlecode.com/svn/<br></br></tt></p>
<p>Эта команда подготовит процесс синхронизации. Затем склонируйте код, выполнив:</p>
<p><tt>$&nbsp;svnsync&nbsp;sync&nbsp;file:///tmp/test-svn<br></br>Committed&nbsp;revision&nbsp;1.<br></br>Copied&nbsp;properties&nbsp;for&nbsp;revision&nbsp;1.<br></br>Committed&nbsp;revision&nbsp;2.<br></br>Copied&nbsp;properties&nbsp;for&nbsp;revision&nbsp;2.<br></br>Committed&nbsp;revision&nbsp;3.<br></br>...<br></br></tt></p>
<p>Хотя выполнение этой операции и может занять всего несколько минут, однако, если вы попробуете скопировать исходный репозиторий в другой удалённый репозиторий, а не в локальный, то процесс займёт почти час, хотя в этом проекте менее ста коммитов. Subversion вынужден клонировать ревизии по одной, а затем отправлять их в другой репозиторий &mdash; это чудовищно неэффективно, однако это единственный простой способ выполнить это действие.</p>
<p id="calibre_link-199"><span><span><b>Приступим к работе</b></span></span></p>
<p>Теперь, когда в вашем распоряжении имеется SVN-репозиторий, для которого вы имеете право на запись, давайте выполним типичные действия по работе с СКВ. Начнём с команды <tt>git svn clone</tt>, которая импортирует весь SVN-репозиторий в локальный Git-репозиторий. Помните, что если вы производите импорт из настоящего удалённого SVN-репозитория, вам надо заменить <tt>file:///tmp/test-svn</tt> на реальный адрес вашего SVN-репозитория:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;clone&nbsp;file:///tmp/test-svn&nbsp;-T&nbsp;trunk&nbsp;-b&nbsp;branches&nbsp;-t&nbsp;tags<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/Users/schacon/projects/testsvnsync/svn/.git/<br></br>r1&nbsp;=&nbsp;b4e387bc68740b5af56c2a5faf4003ae42bd135c&nbsp;(trunk)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;m4/acx_pthread.m4<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;m4/stl_hash.m4<br></br>...<br></br>r75&nbsp;=&nbsp;d1957f3b307922124eec6314e15bcda59e3d9610&nbsp;(trunk)<br></br>Found&nbsp;possible&nbsp;branch&nbsp;point:&nbsp;file:///tmp/test-svn/trunk&nbsp;=&gt;&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;&nbsp;file:///tmp/test-svn&nbsp;/branches/my-calc-branch,&nbsp;75<br></br>Found&nbsp;branch&nbsp;parent:&nbsp;(my-calc-branch)&nbsp;d1957f3b307922124eec6314e15bcda59e3d9610<br></br>Following&nbsp;parent&nbsp;with&nbsp;do_switch<br></br>Successfully&nbsp;followed&nbsp;parent<br></br>r76&nbsp;=&nbsp;8624824ecc0badd73f40ea2f01fce51894189b01&nbsp;(my-calc-branch)<br></br>Checked&nbsp;out&nbsp;HEAD:<br></br>&nbsp;file:///tmp/test-svn/branches/my-calc-branch&nbsp;r76<br></br></tt></p>
<p>Эта команда эквивалентна выполнению для указанного вами URL двух команд &mdash; <tt>git svn init</tt>, а затем <tt>git svn fetch</tt>. Процесс может занять некоторое время. Тестовый проект имеет всего лишь около 75 коммитов, и кода там не очень много, так что, скорее всего, вам придётся подождать всего несколько минут. Однако, Git должен по отдельности проверить и выполнить коммит для каждой версии. Для проектов, имеющих историю с сотнями и тысячами изменений, этот процесс может занять несколько часов или даже дней.</p>
<p>Часть команды <tt>-T trunk -b branches -t tags</tt> сообщает Git'у, что этот SVN-репозиторий следует стандартным соглашениям о ветвлении и метках. Если вместо trunk, branches и tags вы используете какие-то другие, нестандартные имена, то должны изменить эти параметры соответствующим образом. В связи с тем, что такие соглашения являются общепринятыми, вы можете использовать короткий формат, заменив всю эту часть на <tt>-s</tt>, заменяющую собой все эти параметры. Следующая команда эквивалента предыдущей:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;clone&nbsp;file:///tmp/test-svn&nbsp;-s<br></br></tt></p>
<p>Таким образом, вы должны были получить корректный Git-репозиторий с импортированными ветками и метками:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;-a<br></br>*&nbsp;master<br></br>&nbsp;&nbsp;my-calc-branch<br></br>&nbsp;&nbsp;tags/2.0.2<br></br>&nbsp;&nbsp;tags/release-2.0.1<br></br>&nbsp;&nbsp;tags/release-2.0.2<br></br>&nbsp;&nbsp;tags/release-2.0.2rc1<br></br>&nbsp;&nbsp;trunk<br></br></tt></p>
<p>Важно отметить, что эта утилита именует ваши ссылки на удалённые ресурсы по-другому. Когда вы клонируете обычный Git-репозиторий, вы получаете все ветки с удалённого сервера на локальном компьютере в виде: <tt>origin/[ветка]</tt> &mdash; в пространстве имён с именем удалённого сервера. Однако, <tt>git svn</tt> полагает, что у вас не будет множества удалённых источников данных и сохраняет все ссылки на всякое, находящееся на удалённом сервере, без пространства имён. Для просмотра всех имён ссылок вы можете использовать служебную команду Git'а <tt>show-ref</tt>:</p>
<p><tt>$&nbsp;git&nbsp;show-ref<br></br>1cbd4904d9982f386d87f88fce1c24ad7c0f0471&nbsp;refs/heads/master<br></br>aee1ecc26318164f355a883f5d99cff0c852d3c4&nbsp;refs/remotes/my-calc-branch<br></br>03d09b0e2aad427e34a6d50ff147128e76c0e0f5&nbsp;refs/remotes/tags/2.0.2<br></br>50d02cc0adc9da4319eeba0900430ba219b9c376&nbsp;refs/remotes/tags/release-2.0.1<br></br>4caaa711a50c77879a91b8b90380060f672745cb&nbsp;refs/remotes/tags/release-2.0.2<br></br>1c4cb508144c513ff1214c3488abe66dcb92916f&nbsp;refs/remotes/tags/release-2.0.2rc1<br></br>1cbd4904d9982f386d87f88fce1c24ad7c0f0471&nbsp;refs/remotes/trunk<br></br></tt></p>
<p>Обычный Git-репозиторий выглядит скорее так:</p>
<p><tt>$&nbsp;git&nbsp;show-ref<br></br>83e38c7a0af325a9722f2fdc56b10188806d83a1&nbsp;refs/heads/master<br></br>3e15e38c198baac84223acfc6224bb8b99ff2281&nbsp;refs/remotes/gitserver/master<br></br>0a30dd3b0c795b80212ae723640d4e5d48cabdff&nbsp;refs/remotes/origin/master<br></br>25812380387fdd55f916652be4881c6f11600d6f&nbsp;refs/remotes/origin/testing<br></br></tt></p>
<p>Здесь два удалённых сервера: один с именем <tt>gitserver</tt> и веткой <tt>master</tt>, и другой с именем <tt>origin</tt> с двумя ветками: <tt>master</tt> и <tt>testing</tt>.</p>
<p>Обратите внимание, что в примере, где ссылки импортированы из <tt>git svn</tt>, метки были добавлены в Git как удалённые ветки, а не как настоящие метки. Импортированные из Subversion данные выглядят так, как будто под именами меток с удалённого ресурса скрываются ветки.</p>
<p id="calibre_link-200"><span><span><b>Коммит в Subversion</b></span></span></p>
<p>Теперь, когда у вас есть рабочий репозиторий, вы можете выполнить какую-либо работу с кодом и выполнить коммит в апстрим, эффективно используя Git в качестве SVN-клиента. Если вы редактировали один из файлов и закоммитили его, то вы внесли изменение в локальный Git-репозиторий, которое пока не существует на Subversion-сервере:</p>
<p><tt>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'Adding&nbsp;git-svn&nbsp;instructions&nbsp;to&nbsp;the&nbsp;README'<br></br>[master&nbsp;97031e5]&nbsp;Adding&nbsp;git-svn&nbsp;instructions&nbsp;to&nbsp;the&nbsp;README<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br></tt></p>
<p>После этого вам надо отправить изменения в апстрим. Обратите внимание, как Git изменяет способ работы с Subversion &mdash; вы можете сделать несколько коммитов оффлайн, а затем отправить их разом на Subversion-сервер. Для передачи изменений на Subversion-сервер требуется выполнить команду <tt>git svn dcommit</tt>:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;dcommit<br></br>Committing&nbsp;to&nbsp;file:///tmp/test-svn/trunk&nbsp;...<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;README.txt<br></br>Committed&nbsp;r79<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;README.txt<br></br>r79&nbsp;=&nbsp;938b1a547c2cc92033b74d32030e86468294a5c8&nbsp;(trunk)<br></br>No&nbsp;changes&nbsp;between&nbsp;current&nbsp;HEAD&nbsp;and&nbsp;refs/remotes/trunk<br></br>Resetting&nbsp;to&nbsp;the&nbsp;latest&nbsp;refs/remotes/trunk<br></br></tt></p>
<p>Это действие возьмёт все коммиты, сделанные поверх того, что есть в SVN-репозитории, выполнит коммит в Subversion для каждого из них, а затем перепишет ваш локальный коммит в Git'е, чтобы добавить к нему уникальный идентификатор. Это важно, поскольку это означает, что изменятся все SHA-1 контрольные суммы ваших коммитов. В частности и поэтому работать с одним и тем же проектом одновременно и через Git, и через Subversion &mdash; это плохая идея. Взглянув на последний коммит, вы увидите, что добавился новый <tt>git-svn-id</tt>:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-1<br></br>commit&nbsp;938b1a547c2cc92033b74d32030e86468294a5c8<br></br>Author:&nbsp;schacon&nbsp;&lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sat&nbsp;May&nbsp;2&nbsp;22:06:44&nbsp;2009&nbsp;+0000<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Adding&nbsp;git-svn&nbsp;instructions&nbsp;to&nbsp;the&nbsp;README<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;git-svn-id:&nbsp;file:///tmp/test-svn/trunk@79&nbsp;4c93b258-373f-11de-be05-5f7a86268029<br></br></tt></p>
<p>Обратите внимание &mdash; контрольная сумма SHA, которая начиналась с <tt>97031e5</tt> когда вы делали коммит, теперь начинается с <tt>938b1a5</tt>. Если вы хотите отправить изменения как на Git-сервер, так и на SVN-сервер, вы должны отправить их (<tt>dcommit</tt>) сначала на Subversion-сервер, поскольку это действие изменит отправляемые данные.</p>
<p id="calibre_link-201"><span><span><b>Получение новых изменений</b></span></span></p>
<p>Если вы работаете вместе с другими разработчиками, значит, когда-нибудь вам придётся столкнуться с ситуацией, когда кто-то из вас отправит изменения на сервер, а другой, в свою очередь, будет пытаться отправить свои изменения, конфликтующие с первыми. Это изменение не будет принято до тех пор, пока вы не сольёте себе чужую работу. В <tt>git svn</tt> эта ситуация выглядит следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;dcommit<br></br>Committing&nbsp;to&nbsp;file:///tmp/test-svn/trunk&nbsp;...<br></br>Merge&nbsp;conflict&nbsp;during&nbsp;commit:&nbsp;Your&nbsp;file&nbsp;or&nbsp;directory&nbsp;'README.txt'&nbsp;is&nbsp;probably&nbsp;\<br></br>out-of-date:&nbsp;resource&nbsp;out&nbsp;of&nbsp;date;&nbsp;try&nbsp;updating&nbsp;at&nbsp;/Users/schacon/libexec/git-\<br></br>core/git-svn&nbsp;line&nbsp;482<br></br></tt></p>
<p>Для разрешения этой проблемы вам нужно выполнить команду <tt>git svn rebase</tt>, которая получит все изменения, имеющиеся на сервере, которых ещё нет на вашей локальной машине, и переместит все ваши недавние изменения поверх того, что было на сервере:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;rebase<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;README.txt<br></br>r80&nbsp;=&nbsp;ff829ab914e8775c7c025d741beb3d523ee30bc4&nbsp;(trunk)<br></br>First,&nbsp;rewinding&nbsp;head&nbsp;to&nbsp;replay&nbsp;your&nbsp;work&nbsp;on&nbsp;top&nbsp;of&nbsp;it...<br></br>Applying:&nbsp;first&nbsp;user&nbsp;change<br></br></tt></p>
<p>Теперь все ваши изменения находятся сверху того, что есть на SVN-сервере, так что вы можете спокойно выполнить <tt>dcommit</tt>:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;dcommit<br></br>Committing&nbsp;to&nbsp;file:///tmp/test-svn/trunk&nbsp;...<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;README.txt<br></br>Committed&nbsp;r81<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;README.txt<br></br>r81&nbsp;=&nbsp;456cbe6337abe49154db70106d1836bc1332deed&nbsp;(trunk)<br></br>No&nbsp;changes&nbsp;between&nbsp;current&nbsp;HEAD&nbsp;and&nbsp;refs/remotes/trunk<br></br>Resetting&nbsp;to&nbsp;the&nbsp;latest&nbsp;refs/remotes/trunk<br></br></tt></p>
<p>Следует помнить, что в отличие от Git'а, который требует сливать себе изменения в апстриме, которых у вас ещё нет локально, перед тем как отправить свои изменения, <tt>git svn</tt> заставляет делать такое только в случае конфликта правок. Если кто-либо внесёт изменения в один файл, а вы внесёте изменения в другой, команда <tt>dcommit</tt> сработает без ошибок:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;dcommit<br></br>Committing&nbsp;to&nbsp;file:///tmp/test-svn/trunk&nbsp;...<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configure.ac<br></br>Committed&nbsp;r84<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autogen.sh<br></br>r83&nbsp;=&nbsp;8aa54a74d452f82eee10076ab2584c1fc424853b&nbsp;(trunk)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configure.ac<br></br>r84&nbsp;=&nbsp;cdbac939211ccb18aa744e581e46563af5d962d0&nbsp;(trunk)<br></br>W:&nbsp;d2f23b80f67aaaa1f6f5aaef48fce3263ac71a92&nbsp;and&nbsp;refs/remotes/trunk&nbsp;differ,&nbsp;\<br></br>&nbsp;&nbsp;using&nbsp;rebase:<br></br>:100755&nbsp;100755&nbsp;efa5a59965fbbb5b2b0a12890f1b351bb5493c18&nbsp;\<br></br>&nbsp;&nbsp;015e4c98c482f0fa71e4d5434338014530b37fa6&nbsp;M&nbsp;&nbsp;&nbsp;autogen.sh<br></br>First,&nbsp;rewinding&nbsp;head&nbsp;to&nbsp;replay&nbsp;your&nbsp;work&nbsp;on&nbsp;top&nbsp;of&nbsp;it...<br></br>Nothing&nbsp;to&nbsp;do.<br></br></tt></p>
<p>Это важно помнить, поскольку последствием этих действий может стать такое состояние проекта, которого нет ни на одном из ваших компьютеров. Если изменения несовместимы, но не ведут к конфликту изменений, у вас могут возникнуть проблемы, которые трудно будет диагностировать. Это отличается от работы с Git-сервером &mdash; в Git'е вы можете полностью проверить состояние проекта на клиентских машинах до публикации, в то время как в SVN вы не можете даже быть уверены в том, что состояние проекта непосредственно перед коммитом и после него идентично.</p>
<p>Кроме того, вам нужно выполнить следующую команду для получения изменений с сервера Subversion, даже если вы не готовы сами сделать коммит. Вы можете выполнить <tt>git svn fetch</tt> для получения новых данных, но <tt>git svn rebase</tt> и извлечёт новые данные с сервера, и обновит ваши локальные коммиты.</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;rebase<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generate_descriptor_proto.sh<br></br>r82&nbsp;=&nbsp;bd16df9173e424c6f52c337ab6efa7f7643282f1&nbsp;(trunk)<br></br>First,&nbsp;rewinding&nbsp;head&nbsp;to&nbsp;replay&nbsp;your&nbsp;work&nbsp;on&nbsp;top&nbsp;of&nbsp;it...<br></br>Fast-forwarded&nbsp;master&nbsp;to&nbsp;refs/remotes/trunk.<br></br></tt></p>
<p>Выполняйте команду <tt>git svn rebase</tt> периодически, чтобы быть уверенным в том, что ваш код имеет самую свежую версию. Перед выполнением этой команды убедитесь, что ваш рабочий каталог чист. Если нет, вы должны либо «спрятать» свои изменения, либо временно закоммитить их перед выполнением <tt>git svn rebase</tt>, иначе выполнение этой команды прекратится, если она обнаружит возникновение конфликта слияния.</p>
<p id="calibre_link-202"><span><span><b>Проблемы с ветвлением в Git</b></span></span></p>
<p>После того как вы привыкли к работе с Git'ом, вы наверняка будете создавать ветки для работы над отдельными задачами, а затем сливать их. Если вы отправляете изменения на Subversion-сервер через <tt>git svn</tt>, вам, скорее всего, потребуется перемещать свою работу каждый раз в одну ветку, а не сливать ветки вместе. Причина, по которой предпочтение должно быть отдано именно такому подходу, заключается в том, что Subversion имеет линейную историю изменений и не может обрабатывать слияния так, как это делает Git. Поэтому <tt>git svn</tt> проходит только по первым родителям при конвертации снимков состояния в коммиты Subversion.</p>
<p>Допустим, что история изменений выглядит следующим образом: вы создали ветку <tt>experiment</tt>, сделали два коммита, а затем слили их в ветку <tt>master</tt>. Если вы выполните <tt>dcommit</tt>, результат будет следующим:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;dcommit<br></br>Committing&nbsp;to&nbsp;file:///tmp/test-svn/trunk&nbsp;...<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHANGES.txt<br></br>Committed&nbsp;r85<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHANGES.txt<br></br>r85&nbsp;=&nbsp;4bfebeec434d156c36f2bcd18f4e3d97dc3269a2&nbsp;(trunk)<br></br>No&nbsp;changes&nbsp;between&nbsp;current&nbsp;HEAD&nbsp;and&nbsp;refs/remotes/trunk<br></br>Resetting&nbsp;to&nbsp;the&nbsp;latest&nbsp;refs/remotes/trunk<br></br>COPYING.txt:&nbsp;locally&nbsp;modified<br></br>INSTALL.txt:&nbsp;locally&nbsp;modified<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COPYING.txt<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INSTALL.txt<br></br>Committed&nbsp;r86<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INSTALL.txt<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COPYING.txt<br></br>r86&nbsp;=&nbsp;2647f6b86ccfcaad4ec58c520e369ec81f7c283c&nbsp;(trunk)<br></br>No&nbsp;changes&nbsp;between&nbsp;current&nbsp;HEAD&nbsp;and&nbsp;refs/remotes/trunk<br></br>Resetting&nbsp;to&nbsp;the&nbsp;latest&nbsp;refs/remotes/trunk<br></br></tt></p>
<p>Выполнение <tt>dcommit</tt> для ветки с объединённой историей не вызовет никаких проблем. Однако, если вы посмотрите на историю проекта в Git'е, то увидите, что ни один из коммитов, которые вы сделали в ветке <tt>experiment</tt> не были переписаны &mdash; вместо этого, все эти изменения появятся в SVN версии как один объединённый коммит.</p>
<p>Когда кто-нибудь склонирует себе эту работу, всё, что он увидит &mdash; это коммит, в котором все изменения слиты воедино; он не увидит данных о том, откуда они взялись и когда они были внесены.</p>
<p id="calibre_link-203"><span><span><b>Ветвление в Subversion</b></span></span></p>
<p>Работа с ветвями в Subversion отличается от таковой в Git'е; если у вас есть возможность избегать её, то это, наверное, лучший вариант. Хотя, вы можете создавать и вносить изменения в ветки в Subversion, используя <tt>git svn</tt>.</p>
<p><span><b>Создание новой ветки в SVN</b></span></p>
<p>Для того чтобы создать новую ветку в Subversion, выполните <tt>git svn branch [имя ветки]</tt>:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;branch&nbsp;opera<br></br>Copying&nbsp;file:///tmp/test-svn/trunk&nbsp;at&nbsp;r87&nbsp;to&nbsp;file:///tmp/test-svn/branches/opera...<br></br>Found&nbsp;possible&nbsp;branch&nbsp;point:&nbsp;file:///tmp/test-svn/trunk&nbsp;=&gt;&nbsp;\<br></br>&nbsp;&nbsp;file:///tmp/test-svn/branches/opera,&nbsp;87<br></br>Found&nbsp;branch&nbsp;parent:&nbsp;(opera)&nbsp;1f6bfe471083cbca06ac8d4176f7ad4de0d62e5f<br></br>Following&nbsp;parent&nbsp;with&nbsp;do_switch<br></br>Successfully&nbsp;followed&nbsp;parent<br></br>r89&nbsp;=&nbsp;9b6fe0b90c5c9adf9165f700897518dbc54a7cbf&nbsp;(opera)<br></br></tt></p>
<p>Эта команда эквивалентна команде Subversion <tt>svn copy trunk branches/opera</tt> и выполняется на Subversion-сервере. Важно отметить, что эта команда не переключает вас на указанную ветку. Так что, если вы сейчас сделаете коммит, он попадёт на сервере в <tt>trunk</tt>, а не в <tt>opera</tt>.</p>
<p id="calibre_link-204"><span><span><b>Переключение активных веток</b></span></span></p>
<p>Git определяет ветку, в которую он отправит ваши коммиты при выполнении <tt>dcommit</tt>, ища верхушку Subversion-ветки в вашей истории &mdash; она должна быть одна и она должна быть последней в текущей истории веток, имеющей метку <tt>git-svn-id</tt>.</p>
<p>Если вы хотите работать одновременно с несколькими ветками, вы можете настроить локальные ветки на внесение изменений через <tt>dcommit</tt> в конкретные ветки Subversion, начиная их на основе импортированного SVN-коммита для нужной ветки. Если вам нужна ветка <tt>opera</tt>, в которой вы можете поработать отдельно, можете выполнить:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;opera&nbsp;remotes/opera<br></br></tt></p>
<p>Теперь, если вы захотите слить ветку <tt>opera</tt> в <tt>trunk</tt> (вашу ветку <tt>master</tt>), вы сможете сделать это с помощью обычной команды <tt>git merge</tt>. Однако вам потребуется добавить подробное описание к коммиту (через параметр <tt>-m</tt>), иначе при слиянии комментарий будет иметь вид «Merge branch opera» вместо чего-нибудь полезного.</p>
<p>Помните, что хотя вы и используете <tt>git merge</tt> для этой операции, и слияние, скорее всего, произойдёт намного проще, чем было бы в Subversion (потому что Git автоматически определяет подходящую основу для слияния), оно не является обычным коммитом-слиянием в Git'е. Вы должны передать данные обратно на сервер в Subversion, который не способен справиться с коммитом, имеющим более одного родителя, так что после передачи этот коммит будет выглядеть как один коммит, в который затолканы все изменения с другой ветки. После того как вы сольёте одну ветку в другую, вы не сможете просто так вернуться к работе над ней, как могли бы в Git'е. Команда <tt>dcommit</tt> удаляет всю информацию о том, какая ветка была влита, так что последующие вычисления базы слияния будут неверными &mdash; команда <tt>dcommit</tt> сделает результаты выполнения <tt>git merge</tt> такими же, какими они были бы после выполнения <tt>git merge --squash</tt>. К сожалению, избежать подобной ситуации вряд ли удастся &mdash; Subversion не способен сохранять подобную информацию, так что вы всегда будете связаны этими ограничениями. Во избежание проблем вы должны удалить локальную ветку (в нашем случае <tt>opera</tt>) после того, как вы вольёте её в <tt>trunk</tt>.</p>
<p id="calibre_link-205"><span><span><b>Команды Subversion</b></span></span></p>
<p>Набор утилит <tt>git svn</tt> предоставляет в ваше распоряжение несколько команд для облегчения перехода на Git, путём предоставления функциональности, подобной той, которую вы имеете в Subversion. Ниже приведены несколько команд, которые дают вам то, что вы имели в Subversion.</p>
<p><span><b>Просмотр истории в стиле SVN</b></span></p>
<p>Если вы привыкли к Subversion и хотите просматривать историю в стиле SVN, выполните команду <tt>git svn log</tt>, чтобы увидеть историю коммитов в таком же формате, как в SVN:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;log<br></br>------------------------------------------------------------------------<br></br>r87&nbsp;|&nbsp;schacon&nbsp;|&nbsp;2009-05-02&nbsp;16:07:37&nbsp;-0700&nbsp;(Sat,&nbsp;02&nbsp;May&nbsp;2009)&nbsp;|&nbsp;2&nbsp;lines<br></br><br></br>autogen&nbsp;change<br></br><br></br>------------------------------------------------------------------------<br></br>r86&nbsp;|&nbsp;schacon&nbsp;|&nbsp;2009-05-02&nbsp;16:00:21&nbsp;-0700&nbsp;(Sat,&nbsp;02&nbsp;May&nbsp;2009)&nbsp;|&nbsp;2&nbsp;lines<br></br><br></br>Merge&nbsp;branch&nbsp;'experiment'<br></br><br></br>------------------------------------------------------------------------<br></br>r85&nbsp;|&nbsp;schacon&nbsp;|&nbsp;2009-05-02&nbsp;16:00:09&nbsp;-0700&nbsp;(Sat,&nbsp;02&nbsp;May&nbsp;2009)&nbsp;|&nbsp;2&nbsp;lines<br></br><br></br>updated&nbsp;the&nbsp;changelog<br></br></tt></p>
<p>Вы должны знать две важные вещи о команде <tt>git svn log</tt>. Во-первых, она работает в оффлайне, в отличие от оригинальной команды <tt>svn log</tt>, которая запрашивает информацию с Subversion-сервера. Во-вторых, эта команда отображает только те коммиты, которые были переданы на Subversion-сервер. Локальные Git-коммиты, которые вы ещё не отправили с помощью <tt>dcommit</tt>, не будут отображаться, равно как и коммиты, отправленные на Subversion-сервер другими людьми с момента последнего выполнения <tt>dcommit</tt>. Результат действия этой команды скорее похож на последнее известное состояние изменений на Subversion-сервере.</p>
<p><span><b>SVN-Аннотации</b></span></p>
<p>Так же как команда <tt>git svn log</tt> симулирует в оффлайне команду <tt>svn log</tt>, эквивалентом команды <tt>svn annotate</tt> является команда <tt>git svn blame [ФАЙЛ]</tt>. Её вывод выглядит следующим образом:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;blame&nbsp;README.txt&nbsp;<br></br>&nbsp;2&nbsp;&nbsp;&nbsp;temporal&nbsp;Protocol&nbsp;Buffers&nbsp;-&nbsp;Google's&nbsp;data&nbsp;interchange&nbsp;format<br></br>&nbsp;2&nbsp;&nbsp;&nbsp;temporal&nbsp;Copyright&nbsp;2008&nbsp;Google&nbsp;Inc.<br></br>&nbsp;2&nbsp;&nbsp;&nbsp;temporal&nbsp;http://code.google.com/apis/protocolbuffers/<br></br>&nbsp;2&nbsp;&nbsp;&nbsp;temporal&nbsp;<br></br>22&nbsp;&nbsp;&nbsp;temporal&nbsp;C++&nbsp;Installation&nbsp;-&nbsp;Unix<br></br>22&nbsp;&nbsp;&nbsp;temporal&nbsp;=======================<br></br>&nbsp;2&nbsp;&nbsp;&nbsp;temporal&nbsp;<br></br>79&nbsp;&nbsp;&nbsp;&nbsp;schacon&nbsp;Committing&nbsp;in&nbsp;git-svn.<br></br>78&nbsp;&nbsp;&nbsp;&nbsp;schacon&nbsp;<br></br>&nbsp;2&nbsp;&nbsp;&nbsp;temporal&nbsp;To&nbsp;build&nbsp;and&nbsp;install&nbsp;the&nbsp;C++&nbsp;Protocol&nbsp;Buffer&nbsp;runtime&nbsp;and&nbsp;the&nbsp;Protocol<br></br>&nbsp;2&nbsp;&nbsp;&nbsp;temporal&nbsp;Buffer&nbsp;compiler&nbsp;(protoc)&nbsp;execute&nbsp;the&nbsp;following:<br></br>&nbsp;2&nbsp;&nbsp;&nbsp;temporal&nbsp;<br></br></tt></p>
<p>Опять же, эта команда не показывает коммиты, которые вы сделали локально в Git'е или те, которые за то время были отправлены на Subversion-сервер.</p>
<p><span><b>Информация о SVN-сервере</b></span></p>
<p>Вы можете получить ту же информацию, которую даёт выполнение команды <tt>svn info</tt>, выполнив команду <tt>git svn info</tt>:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;info<br></br>Path:&nbsp;.<br></br>URL:&nbsp;https://schacon-test.googlecode.com/svn/trunk<br></br>Repository&nbsp;Root:&nbsp;https://schacon-test.googlecode.com/svn<br></br>Repository&nbsp;UUID:&nbsp;4c93b258-373f-11de-be05-5f7a86268029<br></br>Revision:&nbsp;87<br></br>Node&nbsp;Kind:&nbsp;directory<br></br>Schedule:&nbsp;normal<br></br>Last&nbsp;Changed&nbsp;Author:&nbsp;schacon<br></br>Last&nbsp;Changed&nbsp;Rev:&nbsp;87<br></br>Last&nbsp;Changed&nbsp;Date:&nbsp;2009-05-02&nbsp;16:07:37&nbsp;-0700&nbsp;(Sat,&nbsp;02&nbsp;May&nbsp;2009)<br></br></tt></p>
<p>Так же, как <tt>blame</tt> и <tt>log</tt>, эта команда выполняется оффлайн и выводит информацию, актуальную на момент последнего вашего обращения к серверу Subversion.</p>
<p><span><b>Игнорирование того, что игнорирует Subversion</b></span></p>
<p>Если вы клонируете Subversion-репозиторий, в котором где-то установлены свойства <tt>svn:ignore</tt>, скорее всего, вы захотите создать соответствующие им файлы <tt>.gitignore</tt>, чтобы ненароком не добавить в коммит те файлы, которые не стоит добавлять. Для решения этой проблемы в <tt>git svn</tt> имеется две команды. Первая &mdash; <tt>git svn create-ignore</tt> &mdash; автоматически создаст соответствующие файлы <tt>.gitignore</tt>, которые вы затем можете добавить в свой следующий коммит.</p>
<p>Вторая команда &mdash; <tt>git svn show-ignore</tt>, которая выводит на стандартный вывод строки, которые вы должны включить в файл <tt>.gitignore</tt>. Таким образом, вы можете перенаправить вывод этой команды в файл исключений вашего проекта:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;show-ignore&nbsp;&gt;&nbsp;.git/info/exclude<br></br></tt></p>
<p>Поступая таким образом, вы не захламляете проект файлами <tt>.gitignore</tt>. Это правильный подход, если вы являетесь единственным пользователем Git'а в команде, использующей Subversion, и ваши коллеги выступают против наличия файлов <tt>.gitignore</tt> в проекте.</p>
<p id="calibre_link-206"><span><span><b>Заключение по Git-Svn</b></span></span></p>
<p>Утилиты <tt>git svn</tt> полезны в том случае, если ваша разработка по каким-то причинам требует наличия рабочего Subversion-сервера. Однако, вам стоит смотреть на Git, использующий мост в Subversion, как на урезанную версию Git'а. В противном случае вы столкнётесь с проблемами в преобразованиях, которые могут сбить с толку вас и ваших коллег. Чтобы избежать неприятностей, старайтесь следовать следующим рекомендациям:</p>
<div>&nbsp;</div><ul><li value="1">Держите историю в Git линейной, чтобы она не содержала коммитов-слияний, сделанных с помощью <tt>git merge</tt>. Перемещайте всю работу, которую вы выполняете вне основной ветки обратно в неё; не выполняйте слияний.</li><li value="2">Не устанавливайте отдельный Git-сервер для совместной работы. Можно иметь один такой сервер для того, чтобы ускорить клонирование для новых разработчиков, но не отправляйте на него ничего, не имеющего записи <tt>git-svn-id</tt>. Возможно, стоит даже добавить перехватчик <tt>pre-receive</tt>, который будет проверять каждый коммит на наличие <tt>git-svn-id</tt> и отклонять <tt>git push</tt>, если коммиты не имеют такой записи.</li></ul><p>При следовании этим правилам, работа с Subversion-сервером может быть более-менее сносной. Однако, если возможен перенос проекта на реальный Git-сервер, преимущества от этого перехода дадут вашему проекту намного больше.</p>
<div></div><p id="calibre_link-207"><span><span><b>Миграция на Git</b></span></span></p>
<p>Если вы решили начать использовать Git, а у вас уже есть база исходного кода в другой СКВ, вам придётся как-то мигрировать свой проект. Этот раздел описывает некоторые из включённых в состав Git'а инструментов для импортирования проектов из самых распространённых систем, в конце описывается создание вашего собственного инструмента для импортирования.</p>
<p id="calibre_link-208"><span><span><b>Импортирование</b></span></span></p>
<p>Вы научитесь импортировать данные из двух самых популярных систем контроля версий &mdash; Subversion и Perforce &mdash; поскольку они охватывают большинство пользователей, которые переходят на Git, а также потому, что для обеих систем созданы высококлассные инструменты, которые поставляются в составе Git'а.</p>
<p id="calibre_link-209"><span><span><b>Subversion</b></span></span></p>
<p>Если вы прочли предыдущий раздел об использовании <tt>git svn</tt>, можете с лёгкостью воспользоваться имеющимися там инструкциями для клонирования репозитория через <tt>git svn clone</tt>. Затем можете отказаться от использования Subversion-сервера и отправлять изменения на новый Git-сервер, и использовать уже его. Вытащить историю изменений можно так же быстро, как получить данные с Subversion-сервера (что, однако, может занять какое-то время).</p>
<p>Однако, импортирование не будет безупречным. И так как оно занимает много времени, стоит сделать его правильно. Первая проблема &mdash; это информация об авторах. В Subversion каждый коммитер имеет свою учётную запись в системе, и его имя пользователя отображается в информации о коммите. В примерах из предыдущего раздела выводилось <tt>schacon</tt> в некоторых местах, например, в выводе команд <tt>blame</tt> и <tt>git svn log</tt>. Если вы хотите преобразовать эту информацию для лучшего соответствия данным об авторах в Git'е, вам потребуется отобразить пользователей Subversion в авторов в Git'е. Создайте файл <tt>users.txt</tt>, в котором будут содержаться данные об этом отображении в таком формате:</p>
<p><tt>schacon&nbsp;=&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@geemail.com&gt;<br></br>selse&nbsp;=&nbsp;Someo&nbsp;Nelse&nbsp;&lt;selse@geemail.com&gt;<br></br></tt></p>
<p>Для того чтобы получить список авторов, который использует SVN, можно выполнить следующее:</p>
<p><tt>$&nbsp;svn&nbsp;log&nbsp;^/&nbsp;--xml&nbsp;|&nbsp;grep&nbsp;-P&nbsp;"^&lt;author"&nbsp;|&nbsp;sort&nbsp;-u&nbsp;|&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perl&nbsp;-pe&nbsp;'s/&lt;author&gt;(.*?)&lt;\/author&gt;/$1&nbsp;=&nbsp;/'<br></br></tt></p>
<p>Эта команда выдаст журнал в формате XML&nbsp;&mdash; мы можем найти в нём информацию об авторах, создать из неё список с уникальными записями и избавиться от XML-разметки. (Разумеется, эта команда сработает только на машине с установленными <tt>grep</tt>, <tt>sort</tt> и <tt>perl</tt>). Затем перенаправьте вывод этой команды в файл <tt>users.txt</tt>, чтобы потом можно было добавить к каждой записи данные о соответствующих пользователях Git'а.</p>
<p>Вы можете передать этот файл как параметр команде <tt>git svn</tt> для более точного преобразования данных об авторах. Кроме того, можно дать указание <tt>git svn</tt> не включать метаданные, обычно импортируемые Subversion, передав параметр <tt>--no-metadata</tt> команде <tt>clone</tt> или <tt>init</tt>. Таким образом, команда для импортирования будет выглядеть так:</p>
<p><tt>$&nbsp;git&nbsp;svn&nbsp;clone&nbsp;http://my-project.googlecode.com/svn/&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--authors-file=users.txt&nbsp;--no-metadata&nbsp;-s&nbsp;my_project<br></br></tt></p>
<p>Теперь в вашем каталоге <tt>my_project</tt> будут находиться более приятно выглядящие данные после импортирования. Вместо коммитов, которые выглядят так:</p>
<p><tt>commit&nbsp;37efa680e8473b615de980fa935944215428a35a<br></br>Author:&nbsp;schacon&nbsp;&lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sun&nbsp;May&nbsp;3&nbsp;00:12:22&nbsp;2009&nbsp;+0000<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;fixed&nbsp;install&nbsp;-&nbsp;go&nbsp;to&nbsp;trunk<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;git-svn-id:&nbsp;https://my-project.googlecode.com/svn/trunk@94&nbsp;4c93b258-373f-11de-<br></br>&nbsp;&nbsp;&nbsp;&nbsp;be05-5f7a86268029<br></br></tt></p>
<p>они будут выглядеть так:</p>
<p><tt>commit&nbsp;03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@geemail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sun&nbsp;May&nbsp;3&nbsp;00:12:22&nbsp;2009&nbsp;+0000<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;fixed&nbsp;install&nbsp;-&nbsp;go&nbsp;to&nbsp;trunk<br></br></tt></p>
<p>Теперь не только поле Author выглядит намного лучше, но и строк с <tt>git-svn-id</tt> больше нет.</p>
<p>Вам потребуется сделать небольшую «уборку» после импорта. Сначала вам нужно убрать странные ссылки, оставленные <tt>git svn</tt>. Сначала мы переставим все метки так, чтобы они были реальными метками, а не странными удалёнными ветками. А затем мы переместим остальные ветки так, чтобы они стали локальными.</p>
<p>Для приведения меток к корректному виду Git-меток выполните:</p>
<p><tt>$&nbsp;cp&nbsp;-Rf&nbsp;.git/refs/remotes/tags/*&nbsp;.git/refs/tags/<br></br>$&nbsp;rm&nbsp;-Rf&nbsp;.git/refs/remotes/tags<br></br></tt></p>
<p>Эти действия переместят ссылки, которые были удалёнными ветками начинающимися с <tt>tag/</tt>, и сделают их настоящими (легковесными) метками.</p>
<p>Затем, переместите остальные ссылки в <tt>refs/remotes</tt> так, чтобы они стали локальными ветками:</p>
<p><tt>$&nbsp;cp&nbsp;-Rf&nbsp;.git/refs/remotes/*&nbsp;.git/refs/heads/<br></br>$&nbsp;rm&nbsp;-Rf&nbsp;.git/refs/remotes<br></br></tt></p>
<p>Теперь все старые ветки стали реальными Git-ветками, а все старые метки &mdash; реальными Git-метками. Последнее, что осталось сделать, это добавить свой Git-сервер в качестве удалённого ресурса и отправить на него данные. Вот пример добавления сервера как удалённого источника:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;origin&nbsp;git@my-git-server:myrepository.git<br></br></tt></p>
<p>Так как вы хотите, чтобы все ваши ветви и метки были переданы на этот сервер, выполните:</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;--all<br></br></tt></p>
<p>Теперь все ваши ветки и метки должны быть импортированы на новый Git-сервер в чистом и опрятном виде.</p>
<p id="calibre_link-210"><span><span><b>Perforce</b></span></span></p>
<p>Следующей системой, для которой мы рассмотрим процедуру импортирования, будет Perforce. Утилита импортирования для Perforce также распространяется в составе Git'а. Если вы используете Git версии старее 1.7.11, то сценарий доступен только в секции <tt>contrib</tt> исходного кода &mdash; он не доступен по умолчанию, как <tt>git svn</tt>. В этом случае вам потребуется получить исходный код Git'а, располагающийся на git.kernel.org:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;git://git.kernel.org/pub/scm/git/git.git<br></br>$&nbsp;cd&nbsp;git/contrib/fast-import<br></br></tt></p>
<p>В каталоге <tt>fast-import</tt> вы найдёте исполняемый сценарий на языке Python с названием <tt>git-p4</tt>. У вас на компьютере должен быть установлен Python и утилита <tt>p4</tt> для того, чтобы этот сценарий смог осуществить импортирование. Допустим, например, что вы импортируете проект Jam из Perforce Public Depot. Для настройки вашей клиентской машины необходимо установить переменную окружения P4PORT, указывающую на депо Perforce:</p>
<p><tt>$&nbsp;export&nbsp;P4PORT=public.perforce.com:1666<br></br></tt></p>
<p>Запустите команду <tt>git-p4 clone</tt> для импортирования проекта Jam с Perforce-сервера, передав в качестве параметров депо и путь к проекту, а также путь к каталогу, в который вы хотите импортировать проект:</p>
<p><tt>$&nbsp;git-p4&nbsp;clone&nbsp;//public/jam/src@all&nbsp;/opt/p4import<br></br>Importing&nbsp;from&nbsp;//public/jam/src@all&nbsp;into&nbsp;/opt/p4import<br></br>Reinitialized&nbsp;existing&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/p4import/.git/<br></br>Import&nbsp;destination:&nbsp;refs/remotes/p4/master<br></br>Importing&nbsp;revision&nbsp;4409&nbsp;(100%)<br></br></tt></p>
<p>Если вы теперь перейдёте в каталог <tt>/opt/p4import</tt> и выполните команду <tt>git log</tt>, вы увидите импортированную информацию:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-2<br></br>commit&nbsp;1fd4ec126171790efd2db83548b85b1bbbc07dc2<br></br>Author:&nbsp;Perforce&nbsp;staff&nbsp;&lt;support@perforce.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Aug&nbsp;19&nbsp;10:18:45&nbsp;2004&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Drop&nbsp;'rc3'&nbsp;moniker&nbsp;of&nbsp;jam-2.5.&nbsp;&nbsp;Folded&nbsp;rc2&nbsp;and&nbsp;rc3&nbsp;RELNOTES&nbsp;into<br></br>&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;main&nbsp;part&nbsp;of&nbsp;the&nbsp;document.&nbsp;&nbsp;Built&nbsp;new&nbsp;tar/zip&nbsp;balls.<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Only&nbsp;16&nbsp;months&nbsp;later.<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;[git-p4:&nbsp;depot-paths&nbsp;=&nbsp;"//public/jam/src/":&nbsp;change&nbsp;=&nbsp;4409]<br></br><br></br>commit&nbsp;ca8870db541a23ed867f38847eda65bf4363371d<br></br>Author:&nbsp;Richard&nbsp;Geiger&nbsp;&lt;rmg@perforce.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Tue&nbsp;Apr&nbsp;22&nbsp;20:51:34&nbsp;2003&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Update&nbsp;derived&nbsp;jamgram.c<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;[git-p4:&nbsp;depot-paths&nbsp;=&nbsp;"//public/jam/src/":&nbsp;change&nbsp;=&nbsp;3108]<br></br></tt></p>
<p>Как видите, в каждом коммите есть идентификатор <tt>git-p4</tt>. Оставить этот идентификатор будет хорошим решением, если позже вам понадобится узнать номер изменения в Perforce. Однако, если вы всё же хотите удалить этот идентификатор &mdash; теперь самое время это сделать, до того, как вы начнёте работать в новом репозитории. Можно воспользоваться командой <tt>git filter-branch</tt> для одновременного удаления всех строк с идентификатором:</p>
<p><tt>$&nbsp;git&nbsp;filter-branch&nbsp;--msg-filter&nbsp;'<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sed&nbsp;-e&nbsp;"/^\[git-p4:/d"<br></br>'<br></br>Rewrite&nbsp;1fd4ec126171790efd2db83548b85b1bbbc07dc2&nbsp;(123/123)<br></br>Ref&nbsp;'refs/heads/master'&nbsp;was&nbsp;rewritten<br></br></tt></p>
<p>Если вы теперь выполните <tt>git log</tt>, то увидите, что все контрольные суммы SHA-1 изменились, и что строки содержащие <tt>git-p4</tt> больше не появляются в сообщениях коммитов:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-2<br></br>commit&nbsp;10a16d60cffca14d454a15c6164378f4082bc5b0<br></br>Author:&nbsp;Perforce&nbsp;staff&nbsp;&lt;support@perforce.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Thu&nbsp;Aug&nbsp;19&nbsp;10:18:45&nbsp;2004&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Drop&nbsp;'rc3'&nbsp;moniker&nbsp;of&nbsp;jam-2.5.&nbsp;&nbsp;Folded&nbsp;rc2&nbsp;and&nbsp;rc3&nbsp;RELNOTES&nbsp;into<br></br>&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;main&nbsp;part&nbsp;of&nbsp;the&nbsp;document.&nbsp;&nbsp;Built&nbsp;new&nbsp;tar/zip&nbsp;balls.<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Only&nbsp;16&nbsp;months&nbsp;later.<br></br><br></br>commit&nbsp;2b6c6db311dd76c34c66ec1c40a49405e6b527b2<br></br>Author:&nbsp;Richard&nbsp;Geiger&nbsp;&lt;rmg@perforce.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Tue&nbsp;Apr&nbsp;22&nbsp;20:51:34&nbsp;2003&nbsp;-0800<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;Update&nbsp;derived&nbsp;jamgram.c<br></br></tt></p>
<p>Ваш импортируемый репозиторий готов к отправке на новый Git-сервер.</p>
<p id="calibre_link-211"><span><span><b>Собственная утилита для импорта</b></span></span></p>
<p>Если вы используете систему, отличную от Subversion или Perforce, вы можете поискать утилиту для импорта под свою систему в интернете &mdash; для CVS, Clear Case, Visual Source Safe и даже для простого каталога с архивами уже существуют качественные инструменты для импортирования. Если ни один из этих инструментов не подходит для ваших целей, либо если вам нужен больший контроль над процессом импортирования, вам стоит использовать утилиту <tt>git fast-import</tt>. Эта команда принимает простые инструкции со стандартного ввода для управления процессом записи нужных данных в базу Git'а. Намного проще создать необходимые объекты в Git'е так, чем запуская базовые команды Git'а либо пытаясь записать сырые объекты (см. главу 9). При использовании <tt>git fast-import</tt> вы можете создать сценарий для импортирования, который считывает всю необходимую информацию из импортируемой системы и выводит простые понятные инструкции на стандартный вывод. Затем вы просто запускаете этот сценарий и, используя конвейер (pipe), передаёте результаты его работы на вход <tt>git fast-import</tt>.</p>
<p>Чтобы быстро продемонстрировать суть этого подхода, напишем простую утилиту для импорта. Положим, что вы работаете в каталоге <tt>current</tt> и время от времени делаете резервную копию этого каталога, добавляя к имени дату &mdash; <tt>back_YYYY_MM_DD</tt>, и вы хотите импортировать это всё в Git. Допустим, ваше дерево каталогов выглядит таким образом:</p>
<p><tt>$&nbsp;ls&nbsp;/opt/import_from<br></br>back_2009_01_02<br></br>back_2009_01_04<br></br>back_2009_01_14<br></br>back_2009_02_03<br></br>current<br></br></tt></p>
<p>Для того чтобы импортировать всё это в Git, надо вспомнить, как Git хранит данные. Как вы помните, Git в своей основе представляет собой связный список объектов-коммитов, указывающих на снимки состояния их содержимого. Всё, что вам требуется, это сообщить команде <tt>fast-import</tt> что является данными снимков состояния, какие данные коммитов указывают на них и порядок их следования. Стратегией наших действий будет обход всех снимков состояния по очереди и создание соответствующих коммитов с содержимым каждого каталога, с привязкой каждого коммита к предыдущему.</p>
<p>Так же как и в главе 7 в разделе «Пример создания политики в Git», мы напишем сценарий на Ruby, поскольку это то, с чем я обычно работаю, и, кроме того, он легко читается. Но вы можете создать его на любом другом языке, которым владеете &mdash; он просто должен выводить необходимую информацию на стандартный вывод. Если вы работаете под Windows, то должны особым образом позаботиться о том, чтобы в конце строк не содержались символы возврата каретки &mdash; <tt>git fast-import</tt> принимает только символ перевода строки (LF), а не символ перевода строки и возврата каретки (CRLF), который используется в Windows.</p>
<p>Для того чтобы начать, вы должны перейти в целевой каталог и идентифицировать каждый подкаталог, являющийся снимком состояния, который вы хотите импортировать в виде коммита. Основной цикл будет выглядеть следующим образом:</p>
<p><tt>last_mark&nbsp;=&nbsp;nil<br></br><br></br>#&nbsp;loop&nbsp;through&nbsp;the&nbsp;directories<br></br>Dir.chdir(ARGV[0])&nbsp;do<br></br>&nbsp;&nbsp;Dir.glob("*").each&nbsp;do&nbsp;|dir|<br></br>&nbsp;&nbsp;&nbsp;&nbsp;next&nbsp;if&nbsp;File.file?(dir)<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;move&nbsp;into&nbsp;the&nbsp;target&nbsp;directory<br></br>&nbsp;&nbsp;&nbsp;&nbsp;Dir.chdir(dir)&nbsp;do&nbsp;<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_mark&nbsp;=&nbsp;print_export(dir,&nbsp;last_mark)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;end<br></br>end<br></br></tt></p>
<p>Вы запускаете функцию <tt>print_export</tt> внутри каждого каталога, она берёт запись и отметку предыдущего снимка состояния и возвращает запись и отметку текущего; так вы сможете их правильно между собой соединить. «Отметка» &mdash; это термин утилиты <tt>fast-import</tt>, обозначающий идентификатор, который вы даёте коммиту; когда вы создаёте коммиты, вы назначаете каждому коммиту отметку, по которой на него можно сослаться из других коммитов. Таким образом, первая операция, которую надо включить в метод <tt>print_export</tt>, это генерация отметки из имени каталога:</p>
<p><tt>mark&nbsp;=&nbsp;convert_dir_to_mark(dir)<br></br></tt></p>
<p>Мы сделаем это путём создания массива каталогов и используя значение порядкового номера каталога в массиве как его отметку, поскольку отметка должна быть целым числом:</p>
<p><tt>$marks&nbsp;=&nbsp;[]<br></br>def&nbsp;convert_dir_to_mark(dir)<br></br>&nbsp;&nbsp;if&nbsp;!$marks.include?(dir)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;$marks&nbsp;&lt;&lt;&nbsp;dir<br></br>&nbsp;&nbsp;end<br></br>&nbsp;&nbsp;($marks.index(dir)&nbsp;+&nbsp;1).to_s<br></br>end<br></br></tt></p>
<p>Теперь, когда мы имеем целочисленное представление нашего коммита, нам нужны даты, чтобы указывать их в метаданных коммитов. Поскольку дата записана в имени каталога, мы выделяем её оттуда. Следующей строкой в сценарии <tt>print_export</tt> будет:</p>
<p><tt>date&nbsp;=&nbsp;convert_dir_to_date(dir)<br></br></tt></p>
<p>где метод <tt>convert_dir_to_date</tt> определён как:</p>
<p><tt>def&nbsp;convert_dir_to_date(dir)<br></br>&nbsp;&nbsp;if&nbsp;dir&nbsp;==&nbsp;'current'<br></br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Time.now().to_i<br></br>&nbsp;&nbsp;else<br></br>&nbsp;&nbsp;&nbsp;&nbsp;dir&nbsp;=&nbsp;dir.gsub('back_',&nbsp;'')<br></br>&nbsp;&nbsp;&nbsp;&nbsp;(year,&nbsp;month,&nbsp;day)&nbsp;=&nbsp;dir.split('_')<br></br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Time.local(year,&nbsp;month,&nbsp;day).to_i<br></br>&nbsp;&nbsp;end<br></br>end<br></br></tt></p>
<p>Этот метод возвращает целочисленное значение даты для каждого каталога. Последняя часть метаданных, которая нам нужна для всех коммитов это данные о коммитере, которые мы жёстко задаём в глобальной переменной:</p>
<p><tt>$author&nbsp;=&nbsp;'Scott&nbsp;Chacon&nbsp;&lt;schacon@example.com&gt;'<br></br></tt></p>
<p>Теперь мы готовы приступить к выводу данных коммита в своём сценарии импорта. Дадим начальную информацию говорящую, что мы задаём объект коммита, ветку, на которой он находится, затем отметку, которую мы ранее сгенерировали, информацию о коммитере и сообщение коммита, а затем предыдущий коммит, если он есть. Код выглядит следующим образом:</p>
<p><tt>#&nbsp;print&nbsp;the&nbsp;import&nbsp;information<br></br>puts&nbsp;'commit&nbsp;refs/heads/master'<br></br>puts&nbsp;'mark&nbsp;:'&nbsp;+&nbsp;mark<br></br>puts&nbsp;"committer&nbsp;#{$author}&nbsp;#{date}&nbsp;-0700"<br></br>export_data('imported&nbsp;from&nbsp;'&nbsp;+&nbsp;dir)<br></br>puts&nbsp;'from&nbsp;:'&nbsp;+&nbsp;last_mark&nbsp;if&nbsp;last_mark<br></br></tt></p>
<p>Мы жёстко задаём часовой пояс (-0700), поскольку так проще. Если вы импортируете данные из другой системы, вы должны указать часовой пояс в виде смещения. Сообщение коммита должно быть представлено в особом формате:</p>
<p><tt>data&nbsp;(size)\n(contents)<br></br></tt></p>
<p>Формат состоит из слова <tt>data</tt>, размера данных, которые требуется прочесть, символа переноса строки и, наконец, самих данных. Поскольку нам потребуется использовать такой же формат позже для описания содержимого файла, создадим вспомогательный метод <tt>export_data</tt>:</p>
<p><tt>def&nbsp;export_data(string)<br></br>&nbsp;&nbsp;print&nbsp;"data&nbsp;#{string.size}\n#{string}"<br></br>end<br></br></tt></p>
<p>Всё что нам осталось, это описать содержимое файла для каждого снимка состояния. Это просто, поскольку каждый из них содержится в каталоге: мы можем вывести команду <tt>deleteall</tt>, за которой следует содержимое каждого файла в каталоге. После этого Git соответствующим образом позаботится о регистрации каждого снимка:</p>
<p><tt>puts&nbsp;'deleteall'<br></br>Dir.glob("**/*").each&nbsp;do&nbsp;|file|<br></br>&nbsp;&nbsp;next&nbsp;if&nbsp;!File.file?(file)<br></br>&nbsp;&nbsp;inline_data(file)<br></br>end<br></br></tt></p>
<p>Примечание: поскольку многие системы рассматривают свои ревизии как изменения от одного коммита до другого, <tt>fast-import</tt> также может принимать команды, задающие для каждого коммита, какие файлы были добавлены, удалены или модифицированы, а также что является новым содержимым файлов. В нашем примере вы могли бы вычислить разность между снимками состояния и предоставить только эти данные, но это сложнее. С таким же успехом можно предоставить Git'у все данные для того, чтобы он сам вычислил разницу. Если с вашими данными проще предоставлять разницу между снимками состояния, обратитесь к странице руководства <tt>fast-import</tt> для получения подробностей о том, как предоставлять данные таким способом.</p>
<p>Формат для задания содержимого нового файла либо указания нового содержимого изменённого файла следующий:</p>
<p><tt>M&nbsp;644&nbsp;inline&nbsp;path/to/file<br></br>data&nbsp;(size)<br></br>(file&nbsp;contents)<br></br></tt></p>
<p>Здесь, 644 &mdash; это права доступа (если в проекте есть исполняемые файлы, вам надо выявить их и назначить им права доступа 755), а параметр <tt>inline</tt> говорит о том, что содержимое будет выводиться непосредственно после этой строки. Метод <tt>inline_data</tt> выглядит следующим образом:</p>
<p><tt>def&nbsp;inline_data(file,&nbsp;code&nbsp;=&nbsp;'M',&nbsp;mode&nbsp;=&nbsp;'644')<br></br>&nbsp;&nbsp;content&nbsp;=&nbsp;File.read(file)<br></br>&nbsp;&nbsp;puts&nbsp;"#{code}&nbsp;#{mode}&nbsp;inline&nbsp;#{file}"<br></br>&nbsp;&nbsp;export_data(content)<br></br>end<br></br></tt></p>
<p>Мы повторно используем метод <tt>export_data</tt>, определённый ранее, поскольку он работает тут так же, как и при задании сообщений коммитов.</p>
<p>Последнее, что вам осталось сделать, это вернуть текущую отметку, чтобы её можно было передать для использования в следующую итерацию:</p>
<p><tt>return&nbsp;mark<br></br></tt></p>
<p>ПРИМЕЧАНИЕ: Если вы работаете под Windows, то должны убедиться, что добавили ещё один дополнительный шаг. Мы уже упоминали, что Windows использует CRLF для перехода на новую строку, тогда как <tt>git fast-import</tt> ожидает только LF. Для того чтобы избежать этой проблемы и сделать процесс импорта безошибочным, вам нужно сказать Ruby использовать LF вместо CRLF:</p>
<p><tt>$stdout.binmode<br></br></tt></p>
<p>Это всё. Если вы теперь запустите этот сценарий, то получите примерно следующее содержимое:</p>
<p><tt>$&nbsp;ruby&nbsp;import.rb&nbsp;/opt/import_from&nbsp;<br></br>commit&nbsp;refs/heads/master<br></br>mark&nbsp;:1<br></br>committer&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@geemail.com&gt;&nbsp;1230883200&nbsp;-0700<br></br>data&nbsp;29<br></br>imported&nbsp;from&nbsp;back_2009_01_02deleteall<br></br>M&nbsp;644&nbsp;inline&nbsp;file.rb<br></br>data&nbsp;12<br></br>version&nbsp;two<br></br>commit&nbsp;refs/heads/master<br></br>mark&nbsp;:2<br></br>committer&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@geemail.com&gt;&nbsp;1231056000&nbsp;-0700<br></br>data&nbsp;29<br></br>imported&nbsp;from&nbsp;back_2009_01_04from&nbsp;:1<br></br>deleteall<br></br>M&nbsp;644&nbsp;inline&nbsp;file.rb<br></br>data&nbsp;14<br></br>version&nbsp;three<br></br>M&nbsp;644&nbsp;inline&nbsp;new.rb<br></br>data&nbsp;16<br></br>new&nbsp;version&nbsp;one<br></br>(...)<br></br></tt></p>
<p>Для того чтобы запустить утилиту импорта, перенаправьте этот вывод на вход <tt>git fast-import</tt>, находясь в Git-репозитории, в который хотите совершить импортирование. Вы можете создать новый каталог, а затем выполнить в нём <tt>git init</tt> и потом запустить свой сценарий:</p>
<p><tt>$&nbsp;git&nbsp;init<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/opt/import_to/.git/<br></br>$&nbsp;ruby&nbsp;import.rb&nbsp;/opt/import_from&nbsp;|&nbsp;git&nbsp;fast-import<br></br>git-fast-import&nbsp;statistics:<br></br>---------------------------------------------------------------------<br></br>Alloc'd&nbsp;objects:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5000<br></br>Total&nbsp;objects:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;duplicates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blobs&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;duplicates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;deltas)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trees&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;duplicates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;deltas)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commits:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;duplicates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;deltas)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;duplicates&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;deltas)<br></br>Total&nbsp;branches:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;loads&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;marks:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1024&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;unique&nbsp;&nbsp;&nbsp;&nbsp;)<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atoms:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br></br>Memory&nbsp;total:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2255&nbsp;KiB<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pools:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2098&nbsp;KiB<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;objects:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;156&nbsp;KiB<br></br>---------------------------------------------------------------------<br></br>pack_report:&nbsp;getpagesize()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4096<br></br>pack_report:&nbsp;core.packedGitWindowSize&nbsp;=&nbsp;&nbsp;&nbsp;33554432<br></br>pack_report:&nbsp;core.packedGitLimit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;268435456<br></br>pack_report:&nbsp;pack_used_ctr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9<br></br>pack_report:&nbsp;pack_mmap_calls&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br></br>pack_report:&nbsp;pack_open_windows&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br></br>pack_report:&nbsp;pack_mapped&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1356&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1356<br></br>---------------------------------------------------------------------<br></br></tt></p>
<p>Как видите, после успешного завершения Git выдаёт большое количество информации о проделанной работе. В нашем случае мы импортировали в общей сложности 18 объектов для 5 коммитов в одной ветке. Теперь выполните <tt>git log</tt>, чтобы увидеть свою новую историю изменений:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-2<br></br>commit&nbsp;10bfe7d22ce15ee25b60a824c8982157ca593d41<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@example.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Sun&nbsp;May&nbsp;3&nbsp;12:57:39&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;imported&nbsp;from&nbsp;current<br></br><br></br>commit&nbsp;7e519590de754d079dd73b44d695a42c9d2df452<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@example.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Tue&nbsp;Feb&nbsp;3&nbsp;01:00:00&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;imported&nbsp;from&nbsp;back_2009_02_03<br></br></tt></p>
<p>Ну вот, вы получили чистый и красивый Git-репозиторий. Важно отметить, что пока что у вас нет никаких файлов в рабочем каталоге &mdash; вы должны сбросить свою ветку на ветку <tt>master</tt>:</p>
<p><tt>$&nbsp;ls<br></br>$&nbsp;git&nbsp;reset&nbsp;--hard&nbsp;master<br></br>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;10bfe7d&nbsp;imported&nbsp;from&nbsp;current<br></br>$&nbsp;ls<br></br>file.rb&nbsp;&nbsp;lib<br></br></tt></p>
<p>С помощью утилиты <tt>fast-import</tt> можно делать намного больше &mdash; манипулировать разными правами доступа, двоичными данными, несколькими ветками, совершать слияния, назначать метки, отображать индикаторы прогресса и многое другое. Некоторое количество примеров более сложных сценариев содержится в каталоге <tt>contrib/fast-import</tt> в исходном коде Git'а; один из самых лучших из них &mdash; сценарий <tt>git-p4</tt>, о котором я уже рассказывал.</p>
<div></div><p id="calibre_link-212"><span><span><b>Итоги</b></span></span></p>
<p>После всего вышесказанного вы должны чувствовать себя уверенно, используя Git в связке с Subversion или импортируя практически любой существующий репозиторий в Git-репозиторий, не теряя при этом данных. Следующая глава раскроет перед вами внутреннюю механику Git'а, так что вы будете способны создать каждый необходимый байт данных, если потребуется.</p>
<div></div><p id="calibre_link-213"><span><span><b>Git изнутри</b></span></span></p>
<p>Вы могли прочитать почти всю книгу перед тем, как приступить к этой главе, а могли только часть. Так или иначе, в данной главе рассматриваются внутренние процессы Git'а и особенности его реализации. На мой взгляд, изучение этих вещей &mdash; это основа понимания того, насколько Git полезный и мощный инструмент. Хотя некоторые утверждают, что изложение этого материала может сбить новичков с толку и оказаться для них неоправданно сложным. Именно поэтому эта глава отнесена в конец, давая возможность заинтересованным освоить её раньше, а сомневающимся&nbsp;&mdash; позже.</p>
<p>Итак, приступим. Во-первых, напомню, что Git &mdash; это, по сути, контентно-адресуемая файловая система с пользовательским СКВ-интерфейсом поверх неё. Довольно скоро станет понятнее, что это значит.</p>
<p>На заре развития Git'а (примерно до версии 1.5), интерфейс был значительно сложнее, поскольку был более похож на интерфейс доступа к файловой системе, чем на законченную СКВ. За последние годы, интерфейс значительно улучшился и по удобству не уступает аналогам; у некоторых, тем не менее, с тех пор сохранился стереотип о том, что интерфейс у Git'а чересчур сложный и труден для изучения.</p>
<p>Контентно-адресуемая файловая система&nbsp;&mdash; основа Git'а, очень интересна, именно её мы сначала рассмотрим в этой главе; далее будут рассмотрены транспортные механизмы и инструменты обслуживания репозитория, с которыми вам в своё время, возможно, придётся столкнуться.</p>
<div></div><p id="calibre_link-214"><span><span><b>Сантехника и фарфор</b></span></span></p>
<p>В этой книге было описано, как пользоваться Git'ом, применяя примерно три десятка команд, например, <tt>checkout</tt>, <tt>branch</tt>, <tt>remote</tt> и т.п. Но так как сначала Git был скорее инструментарием для создания СКВ, чем СКВ, удобной для пользователей, в нём полно команд, выполняющих низкоуровневые операции, которые спроектированы так, чтобы их можно было использовать в цепочку в стиле UNIX, а также использовать в сценариях. Эти команды, как правило, называют служебными ("plumbing"&nbsp;&mdash; трубопровод), а ориентированные на пользователя называют пользовательскими ("porcelain"&nbsp;&mdash; фарфор).</p>
<p>Первые восемь глав книги были посвящены практически только пользовательским командам. В данной главе же рассматриваются именно низкоуровневые служебные команды, дающие контроль над внутренними процессами Git'а и показывающие, как он работает и почему он работает так, а не иначе. Предполагается, что данные команды не будут использоваться напрямую из командной строки, а будут служить в качестве строительных блоков для новых команд и пользовательских сценариев.</p>
<p>Когда вы выполняете <tt>git init</tt> в новом или существовавшем ранее каталоге, Git создаёт подкаталог <tt>.git</tt>, в котором располагается почти всё, чем он заправляет. Если требуется выполнить резервное копирование или клонирование репозитория, достаточно скопировать всего лишь один этот каталог, чтобы получить почти всё необходимое. И данная глава почти полностью посвящена его содержимому. Вот так он выглядит:</p>
<p><tt>$&nbsp;ls&nbsp;<br></br>HEAD<br></br>branches/<br></br>config<br></br>description<br></br>hooks/<br></br>index<br></br>info/<br></br>objects/<br></br>refs/<br></br></tt></p>
<p>Там могут быть и другие файлы, но непосредственно после <tt>git init</tt> вы увидите именно это. Каталог <tt>branches</tt> не используется новыми версиями Git'а, а файл <tt>description</tt> требуется только программе GitWeb, на них не стоит обращать особого внимания. Файл <tt>config</tt> содержит настройки проекта, а каталог <tt>info</tt>&nbsp;&mdash; файл с глобальным фильтром, игнорирующим те файлы, которые вы не хотите поместить в .gitignore. В каталоге <tt>hooks</tt> располагаются клиентские и серверные перехватчики, подробно рассмотренные в главе 7.</p>
<p>Итак, осталось четыре важных элемента: файлы <tt>HEAD</tt>, <tt>index</tt> и каталоги <tt>objects</tt>, <tt>refs</tt>. Это ключевые элементы хранилища Git'а. В каталоге <tt>objects</tt> находится, собственно, база данных, в <tt>refs</tt>&nbsp;&mdash; ссылки на объекты коммитов в этой базе (ветки). Файл <tt>HEAD</tt> указывает на текущую ветку, и в файле <tt>index</tt> хранится информация индекса. В последующих разделах данные элементы будут рассмотрены более подробно.</p>
<div></div><p id="calibre_link-215"><span><span><b>Объекты в Git</b></span></span></p>
<p>Git&nbsp;&mdash; контентно-адресуемая файловая система. Здорово. Но что это означает? А означает это, что в своей основе Git&nbsp;&mdash; простое хранилище ключ-значение. Можно добавить туда любое содержимое, в ответ будет выдан ключ, по которому это содержимое можно извлечь. Для примера, можно воспользоваться служебной командой <tt>hash-object</tt>, которая добавляет данные в каталог <tt>.git</tt> и возвращает ключ. Для начала создадим новый Git-репозиторий и убедимся, что каталог <tt>objects</tt> пуст:</p>
<p><tt>$&nbsp;mkdir&nbsp;test<br></br>$&nbsp;cd&nbsp;test<br></br>$&nbsp;git&nbsp;init<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/tmp/test/.git/<br></br>$&nbsp;find&nbsp;.git/objects<br></br>.git/objects<br></br>.git/objects/info<br></br>.git/objects/pack<br></br>$&nbsp;find&nbsp;.git/objects&nbsp;-type&nbsp;f<br></br>$<br></br></tt></p>
<p>Git проинициализировал каталог <tt>objects</tt> и создал в нём подкаталоги <tt>pack</tt> и <tt>info</tt>, пока без файлов. Теперь добавим кое-какое текстовое содержимое в базу Git'а:</p>
<p><tt>$&nbsp;echo&nbsp;'test&nbsp;content'&nbsp;|&nbsp;git&nbsp;hash-object&nbsp;-w&nbsp;--stdin<br></br>d670460b4b4aece5915caf5c68d12f560a9fe3e4<br></br></tt></p>
<p>Ключ <tt>-w</tt> команды <tt>hash-object</tt> указывает, что объект необходимо сохранить, иначе команда просто выведет ключ и всё. Флаг <tt>--stdin</tt> указывает, что данные необходимо считать со стандартного ввода, в противном случае <tt>hash-object</tt> ожидает имя файла. Вывод команды&nbsp;&mdash; 40-символьная контрольная сумма. Это хеш SHA-1&nbsp;&mdash; контрольная сумма содержимого и заголовка, который будет рассмотрен позднее. Теперь можно увидеть, в каком виде будут сохранены ваши данные:</p>
<p><tt>$&nbsp;find&nbsp;.git/objects&nbsp;-type&nbsp;f&nbsp;<br></br>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4<br></br></tt></p>
<p>В каталоге <tt>objects</tt> появился файл. Это и есть начальное внутреннее представление данных в Git'е&nbsp;&mdash; один файл на единицу хранения с именем, являющимся контрольной суммой содержимого и заголовка. Первые два символа SHA определяют подкаталог файла, остальные 38&nbsp;&mdash; собственно, имя.</p>
<p>Получить обратно содержимое объекта можно командой <tt>cat-file</tt>. Это своеобразный швейцарский армейский нож для проверки объектов в Git'е. Ключ <tt>-p</tt> означает автоматическое определение типа содержимого и вывод содержимого на печать в удобном виде:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;d670460b4b4aece5915caf5c68d12f560a9fe3e4<br></br>test&nbsp;content<br></br></tt></p>
<p>Теперь вы умеете добавлять данные в Git и извлекать их обратно. То же самое можно делать и с файлами. Рассмотрим пример. Наиболее простой контроль версий файла можно осуществить, создав его и сохранив в базе:</p>
<p><tt>$&nbsp;echo&nbsp;'version&nbsp;1'&nbsp;&gt;&nbsp;test.txt<br></br>$&nbsp;git&nbsp;hash-object&nbsp;-w&nbsp;test.txt&nbsp;<br></br>83baae61804e65cc73a7201a7252750c76066a30<br></br></tt></p>
<p>Теперь изменим файл и сохраним его в базе ещё раз:</p>
<p><tt>$&nbsp;echo&nbsp;'version&nbsp;2'&nbsp;&gt;&nbsp;test.txt<br></br>$&nbsp;git&nbsp;hash-object&nbsp;-w&nbsp;test.txt&nbsp;<br></br>1f7a7a472abf3dd9643fd615f6da379c4acb3e3a<br></br></tt></p>
<p>Теперь в базе содержатся две версии файла test.txt, а также самый первый сохранённый объект:</p>
<p><tt>$&nbsp;find&nbsp;.git/objects&nbsp;-type&nbsp;f&nbsp;<br></br>.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a<br></br>.git/objects/83/baae61804e65cc73a7201a7252750c76066a30<br></br>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4<br></br></tt></p>
<p>Теперь можно откатить файл к его первой версии:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;83baae61804e65cc73a7201a7252750c76066a30&nbsp;&gt;&nbsp;test.txt&nbsp;<br></br>$&nbsp;cat&nbsp;test.txt&nbsp;<br></br>version&nbsp;1<br></br></tt></p>
<p>или второй:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;1f7a7a472abf3dd9643fd615f6da379c4acb3e3a&nbsp;&gt;&nbsp;test.txt&nbsp;<br></br>$&nbsp;cat&nbsp;test.txt&nbsp;<br></br>version&nbsp;2<br></br></tt></p>
<p>Однако запоминать хеш для каждой версии неудобно, к тому же теряется само имя файла, сохраняется лишь содержимое. Объекты такого типа называют блобами (англ. binary large object). Имея SHA-1 объекта, можно попросить Git показать нам его тип с помощью команды <tt>cat-file -t</tt>:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-t&nbsp;1f7a7a472abf3dd9643fd615f6da379c4acb3e3a<br></br>blob<br></br></tt></p>
<p id="calibre_link-216"><span><span><b>Объекты-деревья</b></span></span></p>
<p>Рассмотрим другой тип объектов Git'а&nbsp;&mdash; деревья. Они решают проблему хранения имён файлов, а также позволяют хранить группы файлов вместе. Git хранит данные сходным с файловыми системами UNIX способом, но в немного упрощённом виде. Содержимое хранится в объектах-деревьях и блобах, дерево соответствует записи каталога в ФС, а блоб более или менее соответствует inode или содержимому файла. Объект-дерево может содержать одну и более записей, каждая из которых представляет собой набор из SHA-1 хеша, соответствующего блобу или поддереву, режима доступа к файлу, типа и имени файла. Например, в проекте simplegit последнее дерево выглядит так:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;master^{tree}<br></br>100644&nbsp;blob&nbsp;a906cb2a4a904a152e80877d4088654daad0c859&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;README<br></br>100644&nbsp;blob&nbsp;8f94139338f9404f26296befa88755fc2598c289&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rakefile<br></br>040000&nbsp;tree&nbsp;99f1a6d12cb4b6f19c8655fca46c3ecf317074e0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lib<br></br></tt></p>
<p>Запись <tt>master^{tree}</tt> означает объект-дерево, на который указывает последний коммит ветки <tt>master</tt>. Заметьте, что подкаталог <tt>lib</tt>&nbsp;&mdash; не блоб, а указатель на другое дерево:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;99f1a6d12cb4b6f19c8655fca46c3ecf317074e0<br></br>100644&nbsp;blob&nbsp;47c6340d6459e05787f644c2447d2595f5d3a54b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simplegit.rb<br></br></tt></p>
<p>Схематически, данные, хранящиеся в Git'е, выглядят примерно так, как это изображено на рисунке 9-1.</p>
<p><img src="images/000035.jpg"></img></p>
<p>Вручную можно создавать не только блобы, но и деревья. Git обычно создаёт дерево, исходя из состояния индекса, и затем сохраняет соответствующий объект-дерево. Поэтому для создания объекта-дерева необходимо проиндексировать какие-нибудь файлы. Для создания индекса из одной записи&nbsp;&mdash; первой версии файла test.txt, воспользуемся командой <tt>update-index</tt>. Данная команда может искусственно добавить более раннюю версию test.txt в новый индекс. Необходимо передать опции <tt>--add</tt>, т.к. файл ещё не существует в индексе (да и самого индекса ещё нет), и <tt>--cacheinfo</tt>, т.к. добавляемого файла нет в рабочем каталоге, но он есть в базе данных. Также необходимо передать режим доступа, хеш и имя файла:</p>
<p><tt>$&nbsp;git&nbsp;update-index&nbsp;--add&nbsp;--cacheinfo&nbsp;100644&nbsp;\<br></br>&nbsp;&nbsp;83baae61804e65cc73a7201a7252750c76066a30&nbsp;test.txt<br></br></tt></p>
<p>В данном случае режим доступа&nbsp;&mdash; <tt>100644</tt>, что означает обычный файл. Другие возможные варианты: <tt>100755</tt>&nbsp;&mdash; исполняемый файл, <tt>120000</tt>&nbsp;&mdash; символическая ссылка. Режимы доступа в Git'е сделаны по аналогии с режимами доступа в UNIX, но они гораздо менее гибки: данные три режима&nbsp;&mdash; единственные доступные для файлов (блобов) в Git'е (хотя существуют и другие режимы, используемые для каталогов и подмодулей).</p>
<p>Теперь можно воспользоваться командой <tt>write-tree</tt> для сохранения индекса в объект-дерево. Здесь опция <tt>-w</tt> не требуется&nbsp;&mdash; вызов <tt>write-tree</tt> автоматически создаст объект-дерево по состоянию индекса, если такого дерева ещё не существует:</p>
<p><tt>$&nbsp;git&nbsp;write-tree<br></br>d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br></br>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br></br>100644&nbsp;blob&nbsp;83baae61804e65cc73a7201a7252750c76066a30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.txt<br></br></tt></p>
<p>Также можно проверить, что мы действительно создали объект-дерево:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-t&nbsp;d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br></br>tree<br></br></tt></p>
<p>Создадим новое дерево со второй версией файла test.txt и ещё одним файлом:</p>
<p><tt>$&nbsp;echo&nbsp;'new&nbsp;file'&nbsp;&gt;&nbsp;new.txt<br></br>$&nbsp;git&nbsp;update-index&nbsp;test.txt&nbsp;<br></br>$&nbsp;git&nbsp;update-index&nbsp;--add&nbsp;new.txt&nbsp;<br></br></tt></p>
<p>Теперь в индексе содержится новая версия файла test.txt и новый файл new.txt. Запишем это дерево (сохранив состояние индекса в объект-дерево) и посмотрим, что из этого получилось:</p>
<p><tt>$&nbsp;git&nbsp;write-tree<br></br>0155eb4229851634a0f03eb265b69f5a2d56f341<br></br>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;0155eb4229851634a0f03eb265b69f5a2d56f341<br></br>100644&nbsp;blob&nbsp;fa49b077972391ad58037050f2a75f74e3671e92&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new.txt<br></br>100644&nbsp;blob&nbsp;1f7a7a472abf3dd9643fd615f6da379c4acb3e3a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.txt<br></br></tt></p>
<p>Заметьте, что в данном дереве находятся записи для обоих файлов, а также, что хеш файла test.txt это хеш "второй версии" этого файла (<tt>1f7a7a</tt>). Для интереса, добавим первое дерево как подкаталог для текущего. Зачитать дерево в индекс можно командой <tt>read-tree</tt>. В нашем случае, чтобы прочитать уже существующее дерево в индекс и сделать его поддеревом, необходимо использовать опцию <tt>--prefix</tt>:</p>
<p><tt>$&nbsp;git&nbsp;read-tree&nbsp;--prefix=bak&nbsp;d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br></br>$&nbsp;git&nbsp;write-tree<br></br>3c4e9cd789d88d8d89c1073707c3585e41b0e614<br></br>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;3c4e9cd789d88d8d89c1073707c3585e41b0e614<br></br>040000&nbsp;tree&nbsp;d8329fc1cc938780ffdd9f94e0d364e0ea74f579&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bak<br></br>100644&nbsp;blob&nbsp;fa49b077972391ad58037050f2a75f74e3671e92&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new.txt<br></br>100644&nbsp;blob&nbsp;1f7a7a472abf3dd9643fd615f6da379c4acb3e3a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.txt<br></br></tt></p>
<p>Если бы вы создали рабочий каталог, соответствующий только что созданному дереву, вы бы получили два файла в корне и подкаталог <tt>bak</tt> со старой версией файла test.txt. Данные, хранящиеся в Git'е для такой структуры, могут быть представлены так, как показано на рисунке 9-2.</p>
<p><img src="images/000048.jpg"></img></p>
<p id="calibre_link-217"><span><span><b>Объекты-коммиты</b></span></span></p>
<p>У нас есть три дерева, соответствующих разным состояниям проекта, но предыдущая проблема с необходимостью запоминать все три значения SHA-1, чтобы иметь возможность восстановить какое-либо из этих состояний, ещё не решена. К тому же у нас нет никакой информации о том, кто, когда и почему сохранил их. Такие данные&nbsp;&mdash; основная информация, которая хранится в объекте-коммите.</p>
<p>Для создания объекта-коммита необходимо вызвать <tt>commit-tree</tt> и задать SHA-1 нужного дерева и, если необходимо, родительские объекты-коммиты. Для начала создадим коммит для самого первого дерева:</p>
<p><tt>$&nbsp;echo&nbsp;'first&nbsp;commit'&nbsp;|&nbsp;git&nbsp;commit-tree&nbsp;d8329f<br></br>fdf4fc3344e67ab068f836878b6c4951e3b15f3d<br></br></tt></p>
<p>Просмотреть вновь созданный объект-коммит можно командой <tt>cat-file</tt>:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;fdf4fc3<br></br>tree&nbsp;d8329fc1cc938780ffdd9f94e0d364e0ea74f579<br></br>author&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;&nbsp;1243040974&nbsp;-0700<br></br>committer&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;&nbsp;1243040974&nbsp;-0700<br></br><br></br>first&nbsp;commit<br></br></tt></p>
<p>Формат объекта-коммита прост: в нём указано дерево верхнего уровня, соответствующее состоянию проекта на некоторый момент; имена автора и коммитера берутся из полей конфигурации <tt>user.name</tt> и <tt>user.email</tt>; также добавляется текущая временная метка, пустая строка и затем сообщение коммита.</p>
<p>Далее, создадим ещё два объекта-коммита, каждый из которых будет ссылаться на предыдущий коммит:</p>
<p><tt>$&nbsp;echo&nbsp;'second&nbsp;commit'&nbsp;|&nbsp;git&nbsp;commit-tree&nbsp;0155eb&nbsp;-p&nbsp;fdf4fc3<br></br>cac0cab538b970a37ea1e769cbbde608743bc96d<br></br>$&nbsp;echo&nbsp;'third&nbsp;commit'&nbsp;&nbsp;|&nbsp;git&nbsp;commit-tree&nbsp;3c4e9c&nbsp;-p&nbsp;cac0cab<br></br>1a410efbd13591db07496601ebc7a059dd55cfe9<br></br></tt></p>
<p>Каждый из трёх объектов-коммитов указывает на одно из состояний проекта. Может показаться странным, но теперь у нас есть полноценная Git-история, которую можно посмотреть командой <tt>git log</tt>, указав хеш последнего коммита:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--stat&nbsp;1a410e<br></br>commit&nbsp;1a410efbd13591db07496601ebc7a059dd55cfe9<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;May&nbsp;22&nbsp;18:15:24&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;third&nbsp;commit<br></br><br></br>&nbsp;bak/test.txt&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br><br></br>commit&nbsp;cac0cab538b970a37ea1e769cbbde608743bc96d<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;May&nbsp;22&nbsp;18:14:29&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;second&nbsp;commit<br></br><br></br>&nbsp;new.txt&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+<br></br>&nbsp;test.txt&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;+-<br></br>&nbsp;2&nbsp;files&nbsp;changed,&nbsp;2&nbsp;insertions(+),&nbsp;1&nbsp;deletions(-)<br></br><br></br>commit&nbsp;fdf4fc3344e67ab068f836878b6c4951e3b15f3d<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;May&nbsp;22&nbsp;18:09:34&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;commit<br></br><br></br>&nbsp;test.txt&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;+<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p>Поразительно. Мы только что выполнили низкоуровневые операции для построения истории без использования высокоуровневых интерфейсов. По существу, именно это делает Git, когда выполняются команды <tt>git add</tt> и <tt>git commit</tt>&nbsp;&mdash; сохраняет блобы для изменённых файлов, обновляет индекс, записывает объекты-деревья и коммит-объекты, ссылающиеся на объекты-деревья верхнего уровня и предшествующие коммиты. Эти три основных вида объектов Git'а: блоб, дерево и коммит &mdash; первоначально сохраняются как отдельные файлы в каталоге <tt>.git/objects</tt>. Вот все объекты, которые сейчас лежат в каталоге с примером (в комментариях написано чему объекты соответствует):</p>
<p><tt>$&nbsp;find&nbsp;.git/objects&nbsp;-type&nbsp;f<br></br>.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341&nbsp;#&nbsp;tree&nbsp;2<br></br>.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9&nbsp;#&nbsp;commit&nbsp;3<br></br>.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a&nbsp;#&nbsp;test.txt&nbsp;v2<br></br>.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614&nbsp;#&nbsp;tree&nbsp;3<br></br>.git/objects/83/baae61804e65cc73a7201a7252750c76066a30&nbsp;#&nbsp;test.txt&nbsp;v1<br></br>.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d&nbsp;#&nbsp;commit&nbsp;2<br></br>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4&nbsp;#&nbsp;'test&nbsp;content'<br></br>.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579&nbsp;#&nbsp;tree&nbsp;1<br></br>.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92&nbsp;#&nbsp;new.txt<br></br>.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d&nbsp;#&nbsp;commit&nbsp;1<br></br></tt></p>
<p>Если пройти по всем внутренним ссылкам, получится граф объектов такой, как на рисунке 9-3.</p>
<p><img src="images/000094.jpg"></img></p>
<p id="calibre_link-218"><span><span><b>Хранение объектов</b></span></span></p>
<p>Ранее я упоминал, что заголовок сохраняется вместе с содержимым. Давайте посмотрим, как сохраняются объекты Git'а на диске. Мы рассмотрим сохранение блоб-объекта, в данном случае это будет строка "есть проблемы, шеф?". Пример будет выполнен на языке Ruby. Для запуска интерактивного интерпретатора воспользуйтесь командой <tt>irb</tt>:</p>
<p><tt>$&nbsp;irb<br></br>&gt;&gt;&nbsp;content&nbsp;=&nbsp;"есть&nbsp;проблемы,&nbsp;шеф?"<br></br>=&gt;&nbsp;"есть&nbsp;проблемы,&nbsp;шеф?"<br></br></tt></p>
<p>Git создаёт заголовок, начинающийся с типа объекта, в данном случае это блоб. Далее добавляется пробел, размер содержимого и в конце нулевой байт:</p>
<p><tt>&gt;&gt;&nbsp;header&nbsp;=&nbsp;"blob&nbsp;#{content.length}\0"<br></br>=&gt;&nbsp;"blob&nbsp;34\000"<br></br></tt></p>
<p>Git дописывает содержимое после заголовка и вычисляет SHA-1 сумму для полученного результата. В Ruby значение SHA-1 для строки можно получить, подключив соответствующую библиотеку командой <tt>require</tt> и затем воспользовавшись вызовом <tt>Digest::SHA1.hexdigest()</tt>:</p>
<p><tt>&gt;&gt;&nbsp;store&nbsp;=&nbsp;header&nbsp;+&nbsp;content<br></br>=&gt;&nbsp;"blob&nbsp;34\000\320\225\321\201\321\202\321\214&nbsp;\320\277\321\200\320\276\320\261\320\273\320\265\320\274\321\213,&nbsp;\321\210\320\265\321\204?"<br></br>&gt;&gt;&nbsp;require&nbsp;'digest/sha1'<br></br>=&gt;&nbsp;true<br></br>&gt;&gt;&nbsp;sha1&nbsp;=&nbsp;Digest::SHA1.hexdigest(store)<br></br>=&gt;&nbsp;"d8a734f44240bdf766c8df342664fde23d421d64"<br></br></tt></p>
<p>Git сжимает новые данные при помощи zlib. В Ruby это можно сделать с помощью одноимённой библиотеки. Сперва необходимо подключить её, а после вызвать <tt>Zlib::Deflate.deflate()</tt> с данными в качестве параметра:</p>
<p><tt>&gt;&gt;&nbsp;require&nbsp;'zlib'<br></br>=&gt;&nbsp;true<br></br>&gt;&gt;&nbsp;zlib_content&nbsp;=&nbsp;Zlib::Deflate.deflate(store)<br></br>=&gt;&nbsp;"x\234\001*\000\325\377blob&nbsp;34\000\320\225\321\201\321\202\321\214&nbsp;\320\277\321\200\320\276\320\261\320\273\320\265\320\274\321\213,&nbsp;\321\210\320\265\321\204?\3453\030S"<br></br></tt></p>
<p>После этого запишем сжатую zlib'ом строку в объект на диск. Определим путь к файлу, который будет записан (первые два символа хеша используются в качестве названия подкаталога, оставшиеся 38&nbsp;&mdash; в качестве имени файла в этом каталоге). В Ruby для этой задачи можно использовать функцию <tt>FileUtils.mkdir_p()</tt> для создания подкаталога, если он не существует. Далее, откроем файл вызовом <tt>File.open()</tt> и запишем наши сжатые данные вызовом <tt>write()</tt> для полученного файлового дескриптора:</p>
<p><tt>&gt;&gt;&nbsp;path&nbsp;=&nbsp;'.git/objects/'&nbsp;+&nbsp;sha1[0,2]&nbsp;+&nbsp;'/'&nbsp;+&nbsp;sha1[2,38]<br></br>=&gt;&nbsp;".git/objects/d8/a734f44240bdf766c8df342664fde23d421d64"<br></br>&gt;&gt;&nbsp;require&nbsp;'fileutils'<br></br>=&gt;&nbsp;true<br></br>&gt;&gt;&nbsp;FileUtils.mkdir_p(File.dirname(path))<br></br>=&gt;&nbsp;".git/objects/bd"<br></br>&gt;&gt;&nbsp;File.open(path,&nbsp;'w')&nbsp;{&nbsp;|f|&nbsp;f.write&nbsp;zlib_content&nbsp;}<br></br>=&gt;&nbsp;32<br></br></tt></p>
<p>Вот и всё, мы создали корректный объект-блоб для Git'а. Все другие объекты создаются аналогично, меняется только запись о типе в заголовке (blob, commit, tree). Стоит добавить, что хотя в блобе может храниться почти любое содержимое, содержимое объектов-деревьев и объектов-коммитов записывается в очень строгом формате.</p>
<div></div><p id="calibre_link-219"><span><span><b>Ссылки в Git</b></span></span></p>
<p>Для просмотра всей истории можно выполнить команду вроде <tt>git log 1a410e</tt>, но, опять же, требуется помнить, что именно коммит <tt>1a410e</tt> является последним, чтобы иметь возможность найти все наши объекты. Нам нужен файл-указатель с простым именем, который бы содержал это значение хеша SHA-1, чтобы можно было пользоваться этим файлом вместо хеша.</p>
<p>В Git'е такие файлы, содержащие SHA-1, называются ссылками ("refs") и располагаются в каталоге <tt>.git/refs</tt>. В нашем проекте этот каталог пока пуст, но в нём уже существует некоторая структура каталогов:</p>
<p><tt>$&nbsp;find&nbsp;.git/refs<br></br>.git/refs<br></br>.git/refs/heads<br></br>.git/refs/tags<br></br>$&nbsp;find&nbsp;.git/refs&nbsp;-type&nbsp;f<br></br>$<br></br></tt></p>
<p>Чтобы создать новую ссылку, которая поможет вам вспомнить, какой коммит последний, по сути, необходимо сделать всего лишь следующее:</p>
<p><tt>$&nbsp;echo&nbsp;"1a410efbd13591db07496601ebc7a059dd55cfe9"&nbsp;&gt;&nbsp;.git/refs/heads/master<br></br></tt></p>
<p>Теперь в командах Git'а вместо хеша можно использовать ссылку, только что созданную в каталоге heads:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=oneline&nbsp;&nbsp;master<br></br>1a410efbd13591db07496601ebc7a059dd55cfe9&nbsp;third&nbsp;commit<br></br>cac0cab538b970a37ea1e769cbbde608743bc96d&nbsp;second&nbsp;commit<br></br>fdf4fc3344e67ab068f836878b6c4951e3b15f3d&nbsp;first&nbsp;commit<br></br></tt></p>
<p>Тем не менее, редактировать данные файлы напрямую не рекомендуется. Git предоставляет безопасную команду <tt>update-ref</tt> для изменения ссылок:</p>
<p><tt>$&nbsp;git&nbsp;update-ref&nbsp;refs/heads/master&nbsp;1a410efbd13591db07496601ebc7a059dd55cfe9<br></br></tt></p>
<p>Вот что такое, по сути, ветка в Git'е&nbsp;&mdash; простой указатель или ссылка на последнюю версию в работе. Для создания ветки, соответствующей состоянию второго коммита, можно выполнить следующее:</p>
<p><tt>$&nbsp;git&nbsp;update-ref&nbsp;refs/heads/test&nbsp;cac0ca<br></br></tt></p>
<p>Данная ветка будет содержать только коммиты, предшествующие выбранному:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=oneline&nbsp;test<br></br>cac0cab538b970a37ea1e769cbbde608743bc96d&nbsp;second&nbsp;commit<br></br>fdf4fc3344e67ab068f836878b6c4951e3b15f3d&nbsp;first&nbsp;commit<br></br></tt></p>
<p>Теперь наша база данных Git'а схематично выглядит так, как показано на рисунке&nbsp;9.4.</p>
<p><img src="images/000078.jpg"></img></p>
<p>Когда выполняется команда <tt>git branch (имя ветки)</tt>, Git, по сути, выполняет <tt>update-ref</tt> для добавления хеша последнего коммита текущей ветки под указанным именем в виде новой ссылки.</p>
<p id="calibre_link-220"><span><span><b>HEAD</b></span></span></p>
<p>Вопрос в том, как же Git получает хеш последнего коммита при выполнении <tt>git branch (имя ветки)</tt>? Ответ содержится в файле HEAD. Данный файл является символической ссылкой на текущую ветку. Символическая ссылка отличается от обычной тем, что она содержит не сам хеш SHA-1, а указатель на другую ссылку. Если вы заглянете в этот файл, то увидите что-то такое:</p>
<p><tt>$&nbsp;cat&nbsp;.git/HEAD&nbsp;<br></br>ref:&nbsp;refs/heads/master<br></br></tt></p>
<p>Если выполнить <tt>git checkout test</tt>, то содержимое файла изменится:</p>
<p><tt>$&nbsp;cat&nbsp;.git/HEAD&nbsp;<br></br>ref:&nbsp;refs/heads/test<br></br></tt></p>
<p>При выполнении <tt>git commit</tt> Git создаёт объект-коммит, указывая его родителем тот объект, SHA-1 которого содержится в файле, на который ссылается HEAD.</p>
<p>Данный файл, конечно, можно редактировать вручную, но безопаснее использовать команду <tt>symbolic-ref</tt>. Получить значение HEAD данной командой можно так:</p>
<p><tt>$&nbsp;git&nbsp;symbolic-ref&nbsp;HEAD<br></br>refs/heads/master<br></br></tt></p>
<p>Изменить значение HEAD можно так:</p>
<p><tt>$&nbsp;git&nbsp;symbolic-ref&nbsp;HEAD&nbsp;refs/heads/test<br></br>$&nbsp;cat&nbsp;.git/HEAD&nbsp;<br></br>ref:&nbsp;refs/heads/test<br></br></tt></p>
<p>Символическую ссылку на файл вне refs поставить нельзя:</p>
<p><tt>$&nbsp;git&nbsp;symbolic-ref&nbsp;HEAD&nbsp;test<br></br>fatal:&nbsp;Refusing&nbsp;to&nbsp;point&nbsp;HEAD&nbsp;outside&nbsp;of&nbsp;refs/<br></br></tt></p>
<p id="calibre_link-221"><span><span><b>Метки</b></span></span></p>
<p>Мы рассмотрели три основных типа объектов Git'а, но есть и четвёртый. Объект-метка очень похож на объект-коммит: он содержит имя поставившего метку, дату, сообщение и указатель. Разница же в том, что метка указывает на коммит, а не на дерево. Она похожа на ветку, которая никогда не перемещается&nbsp;&mdash; она всегда указывает на один и тот же коммит, она просто даёт ему понятное имя.</p>
<p>Как было сказано в главе 2, метки бывают двух типов: аннотированные и легковесные. Легковесную метку можно сделать следующей командой:</p>
<p><tt>$&nbsp;git&nbsp;update-ref&nbsp;refs/tags/v1.0&nbsp;cac0cab538b970a37ea1e769cbbde608743bc96d<br></br></tt></p>
<p>Вот и всё! Легковесная метка&nbsp;&mdash; это ветка, которая никогда не перемещается. Аннотированная метка имеет более сложную структуру. При создании аннотированной метки Git создаёт специальный объект, на который будет указывать ссылка, а не просто указатель на коммит. Мы можем увидеть это, создав аннотированную метку (<tt>-a</tt> задаёт аннотированные метки):</p>
<p><tt>$&nbsp;git&nbsp;tag&nbsp;-a&nbsp;v1.1&nbsp;1a410efbd13591db07496601ebc7a059dd55cfe9&nbsp;-m&nbsp;'test&nbsp;tag'<br></br></tt></p>
<p>Вот значение SHA-1 созданного объекта:</p>
<p><tt>$&nbsp;cat&nbsp;.git/refs/tags/v1.1&nbsp;<br></br>9585191f37f7b0fb9444f35a9bf50de191beadc2<br></br></tt></p>
<p>Теперь выполним <tt>cat-file</tt> для этого хеша:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;9585191f37f7b0fb9444f35a9bf50de191beadc2<br></br>object&nbsp;1a410efbd13591db07496601ebc7a059dd55cfe9<br></br>type&nbsp;commit<br></br>tag&nbsp;v1.1<br></br>tagger&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;&nbsp;Sat&nbsp;May&nbsp;23&nbsp;16:48:58&nbsp;2009&nbsp;-0700<br></br><br></br>test&nbsp;tag<br></br></tt></p>
<p>Заметьте, в поле object записан SHA-1 коммита, для которого мы делали метку. Также стоит отметить, что это поле не обязательно указывает на коммит, но на любой объект в Git'е. Например, в исходный код Git'а мейнтейнер добавил свой открытый GPG-ключ в качестве блоба и поставил для него метку. Увидеть этот ключ можно, выполнив команду</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;blob&nbsp;junio-gpg-pub<br></br></tt></p>
<p>в репозитории с исходным кодом Git'а. В репозитории ядра Linux также есть метка, указывающая не на коммит &mdash; первая метка указывает на дерево первичного импорта.</p>
<p id="calibre_link-222"><span><span><b>Ссылки на удалённые ветки</b></span></span></p>
<p>Третий тип ссылок, который мы рассмотрим&nbsp;&mdash; ссылка на удалённую ветку. Если вы добавили удалённый репозиторий и отправили (push) на него изменения, Git сохранит последнее отправленное значение SHA-1 в каталоге <tt>refs/remotes</tt> для всех отправленных веток. Например, можно добавить удалённый репозиторий <tt>origin</tt> и отправить туда ветку <tt>master</tt>:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;origin&nbsp;git@github.com:schacon/simplegit-progit.git<br></br>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master<br></br>Counting&nbsp;objects:&nbsp;11,&nbsp;done.<br></br>Compressing&nbsp;objects:&nbsp;100%&nbsp;(5/5),&nbsp;done.<br></br>Writing&nbsp;objects:&nbsp;100%&nbsp;(7/7),&nbsp;716&nbsp;bytes,&nbsp;done.<br></br>Total&nbsp;7&nbsp;(delta&nbsp;2),&nbsp;reused&nbsp;4&nbsp;(delta&nbsp;1)<br></br>To&nbsp;git@github.com:schacon/simplegit-progit.git<br></br>&nbsp;&nbsp;&nbsp;a11bef0..ca82a6d&nbsp;&nbsp;master&nbsp;-&gt;&nbsp;master<br></br></tt></p>
<p>Позже вы сможете посмотреть, где находилась ветка <tt>master</tt> с сервера <tt>origin</tt> во время последнего соединения с сервером, заглянув в файл <tt>refs/remotes/origin/master</tt>:</p>
<p><tt>$&nbsp;cat&nbsp;.git/refs/remotes/origin/master&nbsp;<br></br>ca82a6dff817ec66f44342007202690a93763949<br></br></tt></p>
<p>Ссылки на удалённые ветки отличаются от обычных веток (ссылки в <tt>refs/heads</tt>) тем, что на них нельзя переключиться с помощью <tt>git checkout</tt>. Git работает с ними как с закладками, указывающими на последнее состояние соответствующих веток на ваших серверах.</p>
<div></div><p id="calibre_link-223"><span><span><b>Pack-файлы</b></span></span></p>
<p>Вернёмся к базе объектов в нашем тестовом репозитории. К этому моменту их должно быть 11 штук: 4 блоба, 3 дерева, 3 коммита и одна метка:</p>
<p><tt>$&nbsp;find&nbsp;.git/objects&nbsp;-type&nbsp;f<br></br>.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341&nbsp;#&nbsp;tree&nbsp;2<br></br>.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9&nbsp;#&nbsp;commit&nbsp;3<br></br>.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a&nbsp;#&nbsp;test.txt&nbsp;v2<br></br>.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614&nbsp;#&nbsp;tree&nbsp;3<br></br>.git/objects/83/baae61804e65cc73a7201a7252750c76066a30&nbsp;#&nbsp;test.txt&nbsp;v1<br></br>.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2&nbsp;#&nbsp;tag<br></br>.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d&nbsp;#&nbsp;commit&nbsp;2<br></br>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4&nbsp;#&nbsp;'test&nbsp;content'<br></br>.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579&nbsp;#&nbsp;tree&nbsp;1<br></br>.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92&nbsp;#&nbsp;new.txt<br></br>.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d&nbsp;#&nbsp;commit&nbsp;1<br></br></tt></p>
<p>Git сжал содержимое этих файлов при помощи zlib, к тому же мы не записывали много данных, поэтому все эти файлы вместе занимают всего 925 байт. Для того чтобы продемонстрировать одну интересную возможность Git'а, добавим файл побольше. Добавим файл repo.rb из библиотеки Grit, с которой мы работали ранее, он занимает примерно 12 Кбайт:</p>
<p><tt>$&nbsp;curl&nbsp;https://raw.github.com/mojombo/grit/master/lib/grit/repo.rb&nbsp;&gt;&nbsp;repo.rb<br></br>$&nbsp;git&nbsp;add&nbsp;repo.rb&nbsp;<br></br>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'added&nbsp;repo.rb'<br></br>[master&nbsp;484a592]&nbsp;added&nbsp;repo.rb<br></br>&nbsp;3&nbsp;files&nbsp;changed,&nbsp;459&nbsp;insertions(+),&nbsp;2&nbsp;deletions(-)<br></br>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;bak/test.txt<br></br>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;repo.rb<br></br>&nbsp;rewrite&nbsp;test.txt&nbsp;(100%)<br></br></tt></p>
<p>Если мы посмотрим на полученное дерево, мы увидим значение SHA-1, которое получил блоб для файла repo.rb:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;master^{tree}<br></br>100644&nbsp;blob&nbsp;fa49b077972391ad58037050f2a75f74e3671e92&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new.txt<br></br>100644&nbsp;blob&nbsp;9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repo.rb<br></br>100644&nbsp;blob&nbsp;e3f094f522629ae358806b17daf78246c27c007b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.txt<br></br></tt></p>
<p>Посмотрим, сколько этот объект занимает места на диске:</p>
<p><tt>$&nbsp;du&nbsp;-b&nbsp;.git/objects/9b/c1dc421dcd51b4ac296e3e5b6e2a99cf44391e<br></br>4102&nbsp;&nbsp;&nbsp;&nbsp;.git/objects/9b/c1dc421dcd51b4ac296e3e5b6e2a99cf44391e<br></br></tt></p>
<p>Теперь изменим немного данный файл и посмотрим на результат:</p>
<p><tt>$&nbsp;echo&nbsp;'#&nbsp;testing'&nbsp;&gt;&gt;&nbsp;repo.rb&nbsp;<br></br>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'modified&nbsp;repo&nbsp;a&nbsp;bit'<br></br>[master&nbsp;ab1afef]&nbsp;modified&nbsp;repo&nbsp;a&nbsp;bit<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;1&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br></tt></p>
<p>Взглянув на дерево, полученное в результате коммита, мы увидим любопытную вещь:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;master^{tree}<br></br>100644&nbsp;blob&nbsp;fa49b077972391ad58037050f2a75f74e3671e92&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new.txt<br></br>100644&nbsp;blob&nbsp;05408d195263d853f09dca71d55116663690c27c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repo.rb<br></br>100644&nbsp;blob&nbsp;e3f094f522629ae358806b17daf78246c27c007b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test.txt<br></br></tt></p>
<p>Теперь файлу repo.rb соответствует другой объект-блоб. Это означает, что даже одна единственная строка, добавленная в конец 400-строчного файла, требует создания абсолютно нового объекта:</p>
<p><tt>$&nbsp;du&nbsp;-b&nbsp;.git/objects/05/408d195263d853f09dca71d55116663690c27c<br></br>4109&nbsp;&nbsp;&nbsp;&nbsp;.git/objects/05/408d195263d853f09dca71d55116663690c27c<br></br></tt></p>
<p>Итак, мы имеем два почти одинаковых объекта занимающих по 4 Кбайта на диске. Было бы неплохо, если бы Git сохранял только один объект целиком, а другой как разницу между ним и первым объектом.</p>
<p>Оказывается, что Git так и делает. Первоначальный формат для сохранения объектов в Git'е называется рыхлым форматом (loose format) объектов. Однако, время от времени Git упаковывает несколько таких объектов в один pack-файл (pack в пер. с англ.&nbsp;&mdash; упаковывать, уплотнять) для сохранения места на диске и повышения эффективности. Это происходит, когда "рыхлых" объектов становится слишком много, а также при вызове <tt>git gc</tt> вручную, и при отправке изменений на удалённый сервер. Чтобы посмотреть, как происходит упаковка, можно выполнить команду <tt>git gc</tt>:</p>
<p><tt>$&nbsp;git&nbsp;gc<br></br>Counting&nbsp;objects:&nbsp;17,&nbsp;done.<br></br>Delta&nbsp;compression&nbsp;using&nbsp;2&nbsp;threads.<br></br>Compressing&nbsp;objects:&nbsp;100%&nbsp;(13/13),&nbsp;done.<br></br>Writing&nbsp;objects:&nbsp;100%&nbsp;(17/17),&nbsp;done.<br></br>Total&nbsp;17&nbsp;(delta&nbsp;1),&nbsp;reused&nbsp;10&nbsp;(delta&nbsp;0)<br></br></tt></p>
<p>Если вы загляните в каталог с объектами, вы обнаружите, что большая часть объектов исчезла, зато появились два новых файла:</p>
<p><tt>$&nbsp;find&nbsp;.git/objects&nbsp;-type&nbsp;f<br></br>.git/objects/71/08f7ecb345ee9d0084193f147cdad4d2998293<br></br>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4<br></br>.git/objects/info/packs<br></br>.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx<br></br>.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack<br></br></tt></p>
<p>Оставшиеся объекты&nbsp;&mdash; блобы, на которые не указывает ни один коммит. В нашем случае это созданные ранее объекты: содержащий строку "есть проблемы, шеф?", и блоб содержащий "test content". В силу того, что ни в одном коммите данные файлы не присутствуют, они считаются "висячими" и не упаковываются.</p>
<p>Остальные файлы&nbsp;&mdash; это pack-файл и его индекс. Pack-файл&nbsp;&mdash; это файл, который теперь содержит все объекты, которые были удалены. А индекс&nbsp;&mdash; это файл, в котором записаны их смещения в pack-файле, что даёт возможность быстро найти нужный объект. Упаковка данных положительно повлияла на общий размер файлов, если до вызова <tt>gc</tt> они занимали примерно 8 Кбайт, то pack-файл занимает всего 4 Кбайт. Упаковкой объектов мы смогли сократить место, занятое на диске, в два раза.</p>
<p>Как Git это делает? При упаковке Git ищет файлы, которые похожи по имени и размеру, и сохраняет только разницу между двумя версиями файла. Можно рассмотреть pack-файл подробнее и понять, какие действия были выполнены для сжатия. Для просмотра содержимого упакованного файла существует служебная команда <tt>git verify-pack</tt>:</p>
<p><tt>$&nbsp;git&nbsp;verify-pack&nbsp;-v&nbsp;\<br></br>&nbsp;&nbsp;.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx<br></br>0155eb4229851634a0f03eb265b69f5a2d56f341&nbsp;tree&nbsp;&nbsp;&nbsp;71&nbsp;76&nbsp;5400<br></br>05408d195263d853f09dca71d55116663690c27c&nbsp;blob&nbsp;&nbsp;&nbsp;12908&nbsp;3478&nbsp;874<br></br>09f01cea547666f58d6a8d809583841a7c6f0130&nbsp;tree&nbsp;&nbsp;&nbsp;106&nbsp;107&nbsp;5086<br></br>1a410efbd13591db07496601ebc7a059dd55cfe9&nbsp;commit&nbsp;225&nbsp;151&nbsp;322<br></br>1f7a7a472abf3dd9643fd615f6da379c4acb3e3a&nbsp;blob&nbsp;&nbsp;&nbsp;10&nbsp;19&nbsp;5381<br></br>3c4e9cd789d88d8d89c1073707c3585e41b0e614&nbsp;tree&nbsp;&nbsp;&nbsp;101&nbsp;105&nbsp;5211<br></br>484a59275031909e19aadb7c92262719cfcdf19a&nbsp;commit&nbsp;226&nbsp;153&nbsp;169<br></br>83baae61804e65cc73a7201a7252750c76066a30&nbsp;blob&nbsp;&nbsp;&nbsp;10&nbsp;19&nbsp;5362<br></br>9585191f37f7b0fb9444f35a9bf50de191beadc2&nbsp;tag&nbsp;&nbsp;&nbsp;&nbsp;136&nbsp;127&nbsp;5476<br></br>9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e&nbsp;blob&nbsp;&nbsp;&nbsp;7&nbsp;18&nbsp;5193&nbsp;1&nbsp;\<br></br>&nbsp;&nbsp;05408d195263d853f09dca71d55116663690c27c<br></br>ab1afef80fac8e34258ff41fc1b867c702daa24b&nbsp;commit&nbsp;232&nbsp;157&nbsp;12<br></br>cac0cab538b970a37ea1e769cbbde608743bc96d&nbsp;commit&nbsp;226&nbsp;154&nbsp;473<br></br>d8329fc1cc938780ffdd9f94e0d364e0ea74f579&nbsp;tree&nbsp;&nbsp;&nbsp;36&nbsp;46&nbsp;5316<br></br>e3f094f522629ae358806b17daf78246c27c007b&nbsp;blob&nbsp;&nbsp;&nbsp;1486&nbsp;734&nbsp;4352<br></br>f8f51d7d8a1760462eca26eebafde32087499533&nbsp;tree&nbsp;&nbsp;&nbsp;106&nbsp;107&nbsp;749<br></br>fa49b077972391ad58037050f2a75f74e3671e92&nbsp;blob&nbsp;&nbsp;&nbsp;9&nbsp;18&nbsp;856<br></br>fdf4fc3344e67ab068f836878b6c4951e3b15f3d&nbsp;commit&nbsp;177&nbsp;122&nbsp;627<br></br>chain&nbsp;length&nbsp;=&nbsp;1:&nbsp;1&nbsp;object<br></br>pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack:&nbsp;ok<br></br></tt></p>
<p>Здесь блоб <tt>9bc1d</tt>, который, как мы помним, был первой версией файла repo.rb, ссылается на блоб <tt>05408</tt>, который был второй его версией. Третья колонка в выводе&nbsp;&mdash; это размер содержимого объекта. Как видите, содержимое <tt>05408</tt> занимает 12 Кбайт, при этом содержимое <tt>9bc1d</tt> занимает всего лишь 7 байт. Что интересно, вторая версия сохраняется "как есть", а исходная&nbsp;&mdash; в виде дельты. Это из-за того, что необходимость получения доступа к последней версии файла является более вероятной.</p>
<p>Также здорово, что переупаковку можно выполнять в любое время. Время от времени Git будет выполнять её автоматически, чтобы сэкономить место на диске. Если вдруг этого недостаточно, всегда можно выполнить <tt>git gc</tt> вручную.</p>
<div></div><p id="calibre_link-224"><span><span><b>Спецификации ссылок</b></span></span></p>
<p>Во всей книге использовались простые связи между ветками в удалённых репозиториях и локальными ветками, но они могут быть и более сложными. Предположим, мы добавили следующий удалённый репозиторий:</p>
<p><tt>$&nbsp;git&nbsp;remote&nbsp;add&nbsp;origin&nbsp;git@github.com:schacon/simplegit-progit.git<br></br></tt></p>
<p>Данный вызов добавляет секцию в файл <tt>.git/config</tt>, в которой заданы имя удалённого репозитория (<tt>origin</tt>), его URL и спецификация ссылок для извлечения данных:</p>
<p><tt>[remote&nbsp;"origin"]<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;git@github.com:schacon/simplegit-progit.git<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch&nbsp;=&nbsp;+refs/heads/*:refs/remotes/origin/*<br></br></tt></p>
<p>Формат спецификации следующий: опциональный <tt>+</tt>, далее пара <tt>&lt;src&gt;:&lt;dst&gt;</tt>, где <tt>&lt;src&gt;</tt>&nbsp;&mdash; шаблон ссылок в удалённом репозитории, а <tt>&lt;dst&gt;</tt>&nbsp;&mdash; соответствующий шаблон локальных ссылок. Символ <tt>+</tt> сообщает Git'у, что обновление необходимо выполнять даже в том случае, если оно не является перемоткой.</p>
<p>В случае настроек по умолчанию, которые записываются во время выполнения <tt>git remote add</tt>, Git выбирает все ссылки из <tt>refs/heads/</tt> на стороне сервера, и записывает их в локальный каталог <tt>refs/remotes/origin/</tt>. Таким образом, если на сервере есть ветка <tt>master</tt>, журнал данной ветки можно получить, вызвав:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;origin/master<br></br>$&nbsp;git&nbsp;log&nbsp;remotes/origin/master<br></br>$&nbsp;git&nbsp;log&nbsp;refs/remotes/origin/master<br></br></tt></p>
<p>Все эти команды эквивалентны, так как Git развернёт каждую запись до <tt>refs/remotes/origin/master</tt>.</p>
<p>Если хочется, чтобы Git забирал при обновлении только ветку <tt>master</tt>, а не все доступные на сервере, можно изменить соответствующую строку в файле конфигурации на следующее:</p>
<p><tt>fetch&nbsp;=&nbsp;+refs/heads/master:refs/remotes/origin/master<br></br></tt></p>
<p>Данный refspec будет использоваться по умолчанию при вызове <tt>git fetch</tt> для данного удалённого репозитория. Если же вам нужно изменить спецификацию всего раз, можно задать refspec в командной строке. Например, чтобы получить данные из ветки <tt>master</tt> из удалённого репозитория в локальную <tt>origin/mymaster</tt>, можно выполнить</p>
<p><tt>$&nbsp;git&nbsp;fetch&nbsp;origin&nbsp;master:refs/remotes/origin/mymaster<br></br></tt></p>
<p>Конечно, можно задать несколько спецификаций. Получить данные нескольких веток из командной строки можно так:</p>
<p><tt>$&nbsp;git&nbsp;fetch&nbsp;origin&nbsp;master:refs/remotes/origin/mymaster&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;topic:refs/remotes/origin/topic<br></br>From&nbsp;git@github.com:schacon/simplegit<br></br>&nbsp;!&nbsp;[rejected]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;origin/mymaster&nbsp;&nbsp;(non&nbsp;fast&nbsp;forward)<br></br>&nbsp;*&nbsp;[new&nbsp;branch]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;origin/topic<br></br></tt></p>
<p>В данном случае слияние ветки master выполнить не удалось, поскольку слияние не было просто перемоткой. Такое поведение можно изменить, добавив перед спецификацией знак <tt>+</tt>.</p>
<p>В конфигурационном файле также можно задавать несколько спецификаций для получения обновлений. Чтобы каждый раз получать обновления веток master и experiment, добавьте две такие строки:</p>
<p><tt>[remote&nbsp;"origin"]<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;git@github.com:schacon/simplegit-progit.git<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch&nbsp;=&nbsp;+refs/heads/master:refs/remotes/origin/master<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch&nbsp;=&nbsp;+refs/heads/experiment:refs/remotes/origin/experiment<br></br></tt></p>
<p>Задавать частичные регулярные выражения в спецификации нельзя, следующая запись неверна:</p>
<p><tt>fetch&nbsp;=&nbsp;+refs/heads/qa*:refs/remotes/origin/qa*<br></br></tt></p>
<p>Тем не менее, можно использовать пространства имён для получения похожего результата. Если имеется команда QA (сокр. от quality assurance &mdash; контроль качества), которая использует свои несколько веток, и вы хотите получать только ветку master и все ветки команды QA, а остальные &mdash; нет, то можно добавить в конфигурацию следующее:</p>
<p><tt>[remote&nbsp;"origin"]<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;git@github.com:schacon/simplegit-progit.git<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch&nbsp;=&nbsp;+refs/heads/master:refs/remotes/origin/master<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch&nbsp;=&nbsp;+refs/heads/qa/*:refs/remotes/origin/qa/*<br></br></tt></p>
<p>Если ваш рабочий процесс является сложным, и разные команды: разработчики, тестеры, внедренцы &mdash; коммитят в разные ветки одного и того же проекта, то так вы с лёгкостью можете разделить их по разным пространствам имён.</p>
<p id="calibre_link-225"><span><span><b>Спецификации ссылок для команды push</b></span></span></p>
<p>Это хорошо, что мы научились получать данные по ссылкам в отдельных пространствах имён, но нам же ещё надо сделать так, чтобы команда QA сначала смогла отправить свои ветки в пространство имён <tt>qa/</tt>. Мы решим эту задачу, используя спецификации ссылок для команды <tt>push</tt>.</p>
<p>Если разработчик из команды QA хочет отправить изменения из локальной ветки <tt>master</tt> в <tt>qa/master</tt> на удалённом сервере, он может выполнить команду</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;master:refs/heads/qa/master<br></br></tt></p>
<p>Если хочется, чтобы Git автоматически делал так при вызове <tt>git push origin</tt>, можно добавить в конфигурационный файл значение для <tt>push</tt>:</p>
<p><tt>[remote&nbsp;"origin"]<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;git@github.com:schacon/simplegit-progit.git<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fetch&nbsp;=&nbsp;+refs/heads/*:refs/remotes/origin/*<br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;=&nbsp;refs/heads/master:refs/heads/qa/master<br></br></tt></p>
<p>Опять же, это приведёт к тому, что при вызове <tt>git push origin</tt> локальная ветка <tt>master</tt> будет по умолчанию отправляться в удалённую ветку <tt>qa/master</tt>.</p>
<p id="calibre_link-226"><span><span><b>Удаление ссылок</b></span></span></p>
<p>Кроме всего прочего, спецификации ссылок можно использовать следующим образом для удаления ссылок на удалённом сервере:</p>
<p><tt>$&nbsp;git&nbsp;push&nbsp;origin&nbsp;:topic<br></br></tt></p>
<p>Так как спецификация ссылки задаётся в виде <tt>&lt;src&gt;:&lt;dst&gt;</tt>, опускание <tt>&lt;src&gt;</tt> означает, что указанную ветку на удалённом сервере надо сделать пустой, что приводит к её удалению.</p>
<div></div><p id="calibre_link-227"><span><span><b>Протоколы передачи</b></span></span></p>
<p>Git может передавать данные между репозиториями одним из двух основных способов: через HTTP или через "умные" протоколы для транспортов <tt>file://</tt>, <tt>ssh://</tt> и <tt>git://</tt>. В данном разделе мы кратко рассмотрим, как эти два протокола работают.</p>
<p id="calibre_link-228"><span><span><b>Тупой протокол</b></span></span></p>
<p>Git-транспорт, работающий по HTTP, часто называют "тупым" протоколом, потому что для его работы во время передачи данных не требуется исполнения никакого Git-специфичного кода на стороне сервера. Процесс извлечения данных представляет собой последовательность GET-запросов, клиент обращается к стандартной структуре каталогов Git'а. Давайте рассмотрим процесс получения данных по HTTP на примере библиотеки simplegit:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;http://github.com/schacon/simplegit-progit.git<br></br></tt></p>
<p>Первое действие, выполняемое данной командой&nbsp;&mdash; загрузка файла <tt>info/refs</tt>. Данный файл записывается командой <tt>update-server-info</tt>, поэтому для использования HTTP-транспорта необходимо запускать эту команду в перехватчике <tt>post-receive</tt>:</p>
<p><tt>=&gt;&nbsp;GET&nbsp;info/refs<br></br>ca82a6dff817ec66f44342007202690a93763949&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refs/heads/master<br></br></tt></p>
<p>Теперь у нас имеется список удалённых веток и их хеши. Далее, нам надо посмотреть, куда ссылается HEAD, чтобы знать на какую версию переключиться после завершения работы команды.</p>
<p><tt>=&gt;&nbsp;GET&nbsp;HEAD<br></br>ref:&nbsp;refs/heads/master<br></br></tt></p>
<p>Нам надо переключиться на ветку <tt>master</tt> после завершения процесса. На данном этапе можно начать обход дерева. Начальной точкой является объект-коммит <tt>ca82a6</tt>, о чём мы узнали из файла <tt>info/refs</tt>, и мы начинаем с его загрузки:</p>
<p><tt>=&gt;&nbsp;GET&nbsp;objects/ca/82a6dff817ec66f44342007202690a93763949<br></br>(179&nbsp;bytes&nbsp;of&nbsp;binary&nbsp;data)<br></br></tt></p>
<p>Объект получен, он был в рыхлом формате на сервере, и мы получили его по HTTP, используя статический GET-запрос. Теперь можно его разархивировать, отрезать заголовок и посмотреть на его содержимое:</p>
<p><tt>$&nbsp;git&nbsp;cat-file&nbsp;-p&nbsp;ca82a6dff817ec66f44342007202690a93763949<br></br>tree&nbsp;cfda3bf379e4f8dba8717dee55aab78aef7f4daf<br></br>parent&nbsp;085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br></br>author&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;&nbsp;1205815931&nbsp;-0700<br></br>committer&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;&nbsp;1240030591&nbsp;-0700<br></br><br></br>changed&nbsp;the&nbsp;version&nbsp;number<br></br></tt></p>
<p>Далее, необходимо загрузить ещё два объекта: <tt>cfda3b</tt>&nbsp;&mdash; объект-дерево, который обозначен как содержимое только что загруженного коммита, и <tt>085bb3</tt>&nbsp;&mdash; родительский коммит:</p>
<p><tt>=&gt;&nbsp;GET&nbsp;objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br></br>(179&nbsp;bytes&nbsp;of&nbsp;data)<br></br></tt></p>
<p>Так, мы получили следующий объект-коммит. Прихватим и наш объект-дерево:</p>
<p><tt>=&gt;&nbsp;GET&nbsp;objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf<br></br>(404&nbsp;-&nbsp;Not&nbsp;Found)<br></br></tt></p>
<p>Ой! Похоже, этого объекта-дерева нет на сервере в рыхлом формате, поэтому мы получили ответ 404. У этого могут быть две причины: или объект в другом репозитории, или в упакованном файле текущего репозитория. Сперва Git проверяет список альтернативных репозиториев:</p>
<p><tt>=&gt;&nbsp;GET&nbsp;objects/info/http-alternates<br></br>(empty&nbsp;file)<br></br></tt></p>
<p>Если бы этот запрос вернул нам список альтернативных URL, Git обратился бы по ним в поиске "рыхлых" и pack-файлов&nbsp;&mdash; это такой механизм, позволяющий не дублировать данные проектам, являющимися форками друг для друга. Так как в данном случае альтернативных адресов нет, объект должен быть в pack-файле. Для того чтобы узнать, какие упакованные файлы есть на сервере, необходимо загрузить файл со списком pack-файлов: <tt>objects/info/packs</tt> (который также генерируется <tt>update-server-info</tt>):</p>
<p><tt>=&gt;&nbsp;GET&nbsp;objects/info/packs<br></br>P&nbsp;pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack<br></br></tt></p>
<p>На сервере имеется только один pack-файл, поэтому объект точно там, но необходимо проверить индексный файл, чтобы в этом убедиться. Если бы на сервере было несколько pack-файлов, загрузив сначала индексы, мы смогли бы определить, в каком именно pack-файле находится нужный нам объект:</p>
<p><tt>=&gt;&nbsp;GET&nbsp;objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx<br></br>(4k&nbsp;of&nbsp;binary&nbsp;data)<br></br></tt></p>
<p>Теперь, когда мы получили индекс упакованного файла, можно проверить, тут ли наш объект. Это возможно благодаря тому, что в индексе хранятся SHA-1 объектов содержащихся в pack-файле, а также их смещения. Необходимый объект там присутствует, так что продолжим и получим весь pack-файл:</p>
<p><tt>=&gt;&nbsp;GET&nbsp;objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack<br></br>(13k&nbsp;of&nbsp;binary&nbsp;data)<br></br></tt></p>
<p>Итак, мы получили наш объект-дерево, можно продолжить обход списка коммитов. Все они лежат внутри упакованного файла, который мы только что скачали, так что снова обращаться к серверу не надо. Git извлекает рабочую копию ветки <tt>master</tt>, на которую ссылается HEAD.</p>
<p>Полный вывод этого процесса выглядит так:</p>
<p><tt>$&nbsp;git&nbsp;clone&nbsp;http://github.com/schacon/simplegit-progit.git<br></br>Initialized&nbsp;empty&nbsp;Git&nbsp;repository&nbsp;in&nbsp;/private/tmp/simplegit-progit/.git/<br></br>got&nbsp;ca82a6dff817ec66f44342007202690a93763949<br></br>walk&nbsp;ca82a6dff817ec66f44342007202690a93763949<br></br>got&nbsp;085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br></br>Getting&nbsp;alternates&nbsp;list&nbsp;for&nbsp;http://github.com/schacon/simplegit-progit.git<br></br>Getting&nbsp;pack&nbsp;list&nbsp;for&nbsp;http://github.com/schacon/simplegit-progit.git<br></br>Getting&nbsp;index&nbsp;for&nbsp;pack&nbsp;816a9b2334da9953e530f27bcac22082a9f5b835<br></br>Getting&nbsp;pack&nbsp;816a9b2334da9953e530f27bcac22082a9f5b835<br></br>&nbsp;which&nbsp;contains&nbsp;cfda3bf379e4f8dba8717dee55aab78aef7f4daf<br></br>walk&nbsp;085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br></br>walk&nbsp;a11bef06a3f659402fe7563abf99ad00de2209e6<br></br></tt></p>
<p id="calibre_link-229"><span><span><b>Умный протокол</b></span></span></p>
<p>Методика работы HTTP проста, но неэффективна, поэтому чаще используются "умные" протоколы. Эти протоколы обслуживаются процессом на стороне сервера, который учитывает особенности работы Git'а&nbsp;&mdash; он считывает локальные данные, выясняет, что есть и чего не хватает на клиенте, и генерирует для него соответствующие данные. Существует два набора процессов передачи данных: процессы для загрузки данных и процессы для скачивания.</p>
<p><span><b>Загрузка данных</b></span></p>
<p>Для загрузки данных на удалённый сервер используются процессы <tt>send-pack</tt> и <tt>receive-pack</tt>. Процесс <tt>send-pack</tt> запускается на стороне клиента и подключается к <tt>receive-pack</tt> на стороне сервера.</p>
<p>Например, выполняется команда <tt>git push origin master</tt> и <tt>origin</tt> определён как URL использующий протокол SSH. Git запускает процесс <tt>send-pack</tt>, который устанавливает соединение с сервером по протоколу SSH. Он пытается запустить команду на удалённом сервере через вызов команды ssh, который выглядит следующим образом:</p>
<p><tt>$&nbsp;ssh&nbsp;-x&nbsp;git@github.com&nbsp;"git-receive-pack&nbsp;'schacon/simplegit-progit.git'"<br></br>005bca82a6dff817ec66f4437202690a93763949&nbsp;refs/heads/master&nbsp;report-status&nbsp;delete-refs<br></br>003e085bb3bcb608e1e84b2432f8ecbe6306e7e7&nbsp;refs/heads/topic<br></br>0000<br></br></tt></p>
<p>Команда <tt>git-receive-pack</tt> тут же посылает в ответ по одной строке на каждую из имеющихся в наличии ссылок&nbsp;&mdash; в данном случае только ветку <tt>master</tt> и её SHA. Первая строка также содержит список возможностей сервера (здесь это <tt>report-status</tt> и <tt>delete-refs</tt>).</p>
<p>Каждая строка начинается с 4-байтового шестнадцатеричного значения, содержащего длину оставшейся строки. Первая строка начинается с 005b, это 91 в 16-ричном виде, значит в этой строке ещё 91 байт. Следующая строка начинается с 003e, что означает 62, то есть надо прочитать 62 байта. Далее следует строка 0000, которая означает, что сервер закончил листинг своих ссылок.</p>
<p>Теперь, когда процесс <tt>send-pack</tt> выяснил состояние сервера, он определяет коммиты, которые есть локально, но которых нет на сервере. Для каждой ссылки, которая будет обновлена текущей командой <tt>push</tt>, процесс <tt>send-pack</tt> передаёт процессу <tt>receive-pack</tt> эти данные. Например, если мы обновляем ветку <tt>master</tt>, и добавляем ветку <tt>experiment</tt>, ответ <tt>send-pack</tt> будет выглядеть следующим образом:</p>
<p><tt>0085ca82a6dff817ec66f44342007202690a93763949&nbsp;&nbsp;15027957951b64cf874c3557a0f3547bd83b3ff6&nbsp;refs/heads/master&nbsp;report-status<br></br>00670000000000000000000000000000000000000000&nbsp;cdfdb42577e2506715f8cfeacdbabc092bf63e8d&nbsp;refs/heads/experiment<br></br>0000<br></br></tt></p>
<p>Значение SHA-1 из одних нулей означает, что раньше здесь ничего не было&nbsp;&mdash; так получилось из-за того, что мы добавили новую ссылку <tt>experiment</tt>. Если бы мы удаляли ссылку, было бы на оборот: одни нули были бы справа.</p>
<p>Git отправляет строку для каждой ссылки, для которой производится обновление. В строке содержится старый хеш, новый хеш и имя обновляемой ссылки. Первая строка также содержит возможности клиента. Далее, клиент загружает упакованный файл со всеми объектами, которых ещё нет на сервере. В конце, сервер отвечает статусным сообщением сообщающем об успехе (или ошибке):</p>
<p><tt>000Aunpack&nbsp;ok<br></br></tt></p>
<p><span><b>Скачивание данных</b></span></p>
<p>Если выполняется скачивание данных, используются процессы <tt>fetch-pack</tt> и <tt>upload-pack</tt>. Клиент запускает процесс <tt>fetch-pack</tt>, который подключается к процессу <tt>upload-pack</tt> на удалённой машине для определения, какие данные будут переданы.</p>
<p>Существуют разные способы запуска <tt>upload-pack</tt> на удалённом репозитории. Можно запустить его по SSH так же, как и <tt>receive-pack</tt>. Ещё можно вызвать процесс через Git-демон, по умолчанию принимающий соединения на порте 9418. Процесс <tt>fetch-pack</tt> после подключения отправляет демону данные примерно следующего вида:</p>
<p><tt>003fgit-upload-pack&nbsp;schacon/simplegit-progit.git\0host=myserver.com\0<br></br></tt></p>
<p>Начальные 4 байта задают размер последующих данных, далее следует команда, которую следует запустить, завершаемая нулевым байтом, а потом имя сервера и последний нулевой байт. Git-демон проверяет возможность выполнения команды, а также, что репозиторий существует и имеет необходимые права доступа. Если всё хорошо, демон запускает процесс <tt>upload-pack</tt> и передаёт запрос ему.</p>
<p>Если извлечение данных производится по SSH, <tt>fetch-pack</tt> выполняет другие действия:</p>
<p><tt>$&nbsp;ssh&nbsp;-x&nbsp;git@github.com&nbsp;"git-upload-pack&nbsp;'schacon/simplegit-progit.git'"<br></br></tt></p>
<p>В обоих случаях, после того как <tt>fetch-pack</tt> подключится, <tt>upload-pack</tt> передаст обратно следующее:</p>
<p><tt>0088ca82a6dff817ec66f44342007202690a93763949&nbsp;HEAD\0multi_ack&nbsp;thin-pack&nbsp;\<br></br>&nbsp;&nbsp;side-band&nbsp;side-band-64k&nbsp;ofs-delta&nbsp;shallow&nbsp;no-progress&nbsp;include-tag<br></br>003fca82a6dff817ec66f44342007202690a93763949&nbsp;refs/heads/master<br></br>003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7&nbsp;refs/heads/topic<br></br>0000<br></br></tt></p>
<p>Это очень похоже на ответ <tt>receive-pack</tt>, но только возможности другие. Вдобавок <tt>upload-pack</tt> отсылает обратно ссылку HEAD, чтобы клиент понимал, на какую ветку переключиться, если выполняется клонирование.</p>
<p>На данном этапе процесс <tt>fetch-pack</tt> смотрит на объекты, имеющиеся в наличии, и для недостающих объектов отвечает словом "want" и за ним SHA объекта. Для уже имеющихся объектов процесс отправляет их хеши со словом "have". В конце списка он пишет "done", и это даёт понять процессу <tt>upload-pack</tt>, что пора начинать отправлять упакованный файл с необходимыми данными:</p>
<p><tt>0054want&nbsp;ca82a6dff817ec66f44342007202690a93763949&nbsp;ofs-delta<br></br>0032have&nbsp;085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br></br>0000<br></br>0009done<br></br></tt></p>
<p>Это самый основной случай передачи данных. В более сложных случаях клиент поддерживает функции <tt>multi_ack</tt> или <tt>side-band</tt>, но этот пример иллюстрирует основные взаимодействия, используемые процессами умного протокола.</p>
<div></div><p id="calibre_link-230"><span><span><b>Обслуживание и восстановление данных</b></span></span></p>
<p>Иногда требуется выполнить очистку&nbsp;&mdash; сделать репозиторий более компактным, почистить импортированный репозиторий или восстановить потерянную работу. Данный раздел охватывает некоторые из этих сценариев.</p>
<p id="calibre_link-231"><span><span><b>Обслуживание</b></span></span></p>
<p>Иногда Git сам выполняет команду, запускающую автоматический сборщик мусора. Чаще всего эта команда ничего не делает. Однако, если неупакованных объектов слишком много или у вас слишком много pack-файлов, Git запускает полноценную команду <tt>git gc</tt>. Здесь <tt>gc</tt> это сокращение от "garbage collect", что означает "сборка мусора". Эта команда выполняет несколько действий: собирает все объекты в рыхлом формате и упаковывает их в pack-файлы, объединяет несколько упакованных файлов в один большой, удаляет объекты, недостижимые ни из одного коммита и хранящиеся дольше нескольких месяцев.</p>
<p>Вы также можете запустить сборку мусора вручную:</p>
<p><tt>$&nbsp;git&nbsp;gc&nbsp;--auto<br></br></tt></p>
<p>Опять же, как правило, эта команда ничего не делает. Необходимо иметь 7000 несжатых объектов или более 50 упакованных файлов, чтобы запустился настоящий <tt>gc</tt>. Данные пределы можно изменить с помощью параметров <tt>gc.auto</tt> и <tt>gc.autopacklimit</tt> в конфигурационном файле.</p>
<p>Другое действие, выполняемое <tt>gc</tt>&nbsp;&mdash; упаковка ссылок в единый файл. Предположим, репозиторий содержит следующие ветки и теги:</p>
<p><tt>$&nbsp;find&nbsp;.git/refs&nbsp;-type&nbsp;f<br></br>.git/refs/heads/experiment<br></br>.git/refs/heads/master<br></br>.git/refs/tags/v1.0<br></br>.git/refs/tags/v1.1<br></br></tt></p>
<p>Если выполнить <tt>git gc</tt>, данные файлы в каталоге <tt>refs</tt> перестанут существовать. Git перенесёт их в файл <tt>.git/packed-refs</tt> в угоду эффективности. Файл будет иметь следующий вид:</p>
<p><tt>$&nbsp;cat&nbsp;.git/packed-refs&nbsp;<br></br>#&nbsp;pack-refs&nbsp;with:&nbsp;peeled&nbsp;<br></br>cac0cab538b970a37ea1e769cbbde608743bc96d&nbsp;refs/heads/experiment<br></br>ab1afef80fac8e34258ff41fc1b867c702daa24b&nbsp;refs/heads/master<br></br>cac0cab538b970a37ea1e769cbbde608743bc96d&nbsp;refs/tags/v1.0<br></br>9585191f37f7b0fb9444f35a9bf50de191beadc2&nbsp;refs/tags/v1.1<br></br>^1a410efbd13591db07496601ebc7a059dd55cfe9<br></br></tt></p>
<p>При обновлении ссылки Git не будет редактировать этот файл, а добавит новый файл в <tt>refs/heads</tt>. Для получения хеша для нужной ссылки Git сначала проверит наличие ссылки в каталоге <tt>refs</tt>, а к файлу <tt>packed-refs</tt> обратится только в случае неудачи. Однако, если в каталоге <tt>refs</tt> файла нет, скорее всего, он в <tt>packed-refs</tt>.</p>
<p>Заметьте, последняя строка файла начинается с <tt>^</tt>. Это означает, что метка непосредственно над ней является аннотированной и данная строка &mdash; это коммит, на который аннотированная метка указывает.</p>
<p id="calibre_link-232"><span><span><b>Восстановление данных</b></span></span></p>
<p>В какой-то момент при работе с Git'ом вы нечаянно можете потерять коммит. Как правило, такое случается, когда вы удаляете ветку, в которой находились некоторые наработки, а потом оказывается, что они всё-таки были нужными. Либо вы жёстко сбросили ветку, тем самым отказавшись от коммитов, которые теперь понадобились. Как же в таком случае заполучить свои коммиты обратно?</p>
<p>Рассмотрим пример, в котором жёстко сбросим ветку master в тестовом репозитории на какой-нибудь более ранний коммит и затем восстановим потерянные коммиты. Для начала рассмотрим, в каком состоянии находится репозиторий на данном этапе:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=oneline<br></br>ab1afef80fac8e34258ff41fc1b867c702daa24b&nbsp;modified&nbsp;repo&nbsp;a&nbsp;bit<br></br>484a59275031909e19aadb7c92262719cfcdf19a&nbsp;added&nbsp;repo.rb<br></br>1a410efbd13591db07496601ebc7a059dd55cfe9&nbsp;third&nbsp;commit<br></br>cac0cab538b970a37ea1e769cbbde608743bc96d&nbsp;second&nbsp;commit<br></br>fdf4fc3344e67ab068f836878b6c4951e3b15f3d&nbsp;first&nbsp;commit<br></br></tt></p>
<p>Теперь сдвинем ветку <tt>master</tt> на несколько коммитов назад:</p>
<p><tt>$&nbsp;git&nbsp;reset&nbsp;--hard&nbsp;1a410efbd13591db07496601ebc7a059dd55cfe9<br></br>HEAD&nbsp;is&nbsp;now&nbsp;at&nbsp;1a410ef&nbsp;third&nbsp;commit<br></br>$&nbsp;git&nbsp;log&nbsp;--pretty=oneline<br></br>1a410efbd13591db07496601ebc7a059dd55cfe9&nbsp;third&nbsp;commit<br></br>cac0cab538b970a37ea1e769cbbde608743bc96d&nbsp;second&nbsp;commit<br></br>fdf4fc3344e67ab068f836878b6c4951e3b15f3d&nbsp;first&nbsp;commit<br></br></tt></p>
<p>Итак, теперь два последних коммита по-настоящему потеряны&nbsp;&mdash; они не достижимы ни из одной ветки. Необходимо найти SHA последнего коммита и создать ветку, указывающую на него. Сложность в том, чтобы найти этот самый SHA последнего коммита, ведь вряд ли вы его запомнили, да?</p>
<p>Зачастую самый быстрый способ&nbsp;&mdash; использовать инструмент под названием <tt>git reflog</tt>. Во время вашей работы Git записывает все изменения HEAD. Каждый раз при переключении веток и коммите, добавляется запись в reflog. Также обновление производится при вызове <tt>git update-ref</tt>, это, в частности, является причиной необходимости использования этой команды вместо прямой записи значения хеша в ref-файл, как было рассмотрено в разделе "Ссылки в Git" в этой главе. Итак, изменения HEAD в хронологическом порядке можно увидеть, вызвав <tt>git reflog</tt>:</p>
<p><tt>$&nbsp;git&nbsp;reflog<br></br>1a410ef&nbsp;HEAD@{0}:&nbsp;1a410efbd13591db07496601ebc7a059dd55cfe9:&nbsp;updating&nbsp;HEAD<br></br>ab1afef&nbsp;HEAD@{1}:&nbsp;ab1afef80fac8e34258ff41fc1b867c702daa24b:&nbsp;updating&nbsp;HEAD<br></br></tt></p>
<p>Здесь мы видим два коммита, на которых мы когда-то находились, однако информации не так много. Более интересный вывод можно получить, используя <tt>git log -g</tt>, что даст стандартный вывод лога для записей из reflog:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;-g<br></br>commit&nbsp;1a410efbd13591db07496601ebc7a059dd55cfe9<br></br>Reflog:&nbsp;HEAD@{0}&nbsp;(Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;)<br></br>Reflog&nbsp;message:&nbsp;updating&nbsp;HEAD<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;May&nbsp;22&nbsp;18:22:37&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;third&nbsp;commit<br></br><br></br>commit&nbsp;ab1afef80fac8e34258ff41fc1b867c702daa24b<br></br>Reflog:&nbsp;HEAD@{1}&nbsp;(Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;)<br></br>Reflog&nbsp;message:&nbsp;updating&nbsp;HEAD<br></br>Author:&nbsp;Scott&nbsp;Chacon&nbsp;&lt;schacon@gmail.com&gt;<br></br>Date:&nbsp;&nbsp;&nbsp;Fri&nbsp;May&nbsp;22&nbsp;18:15:24&nbsp;2009&nbsp;-0700<br></br><br></br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modified&nbsp;repo&nbsp;a&nbsp;bit<br></br></tt></p>
<p>Похоже, что нижний коммит &mdash; это тот, который мы потеряли, и он может быть восстановлен созданием ветки, указывающей на него. Например, создадим ветку с именем <tt>recover-branch</tt>, указывающую на этот коммит (ab1afef):</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;recover-branch&nbsp;ab1afef<br></br>$&nbsp;git&nbsp;log&nbsp;--pretty=oneline&nbsp;recover-branch<br></br>ab1afef80fac8e34258ff41fc1b867c702daa24b&nbsp;modified&nbsp;repo&nbsp;a&nbsp;bit<br></br>484a59275031909e19aadb7c92262719cfcdf19a&nbsp;added&nbsp;repo.rb<br></br>1a410efbd13591db07496601ebc7a059dd55cfe9&nbsp;third&nbsp;commit<br></br>cac0cab538b970a37ea1e769cbbde608743bc96d&nbsp;second&nbsp;commit<br></br>fdf4fc3344e67ab068f836878b6c4951e3b15f3d&nbsp;first&nbsp;commit<br></br></tt></p>
<p>Здорово, теперь у нас есть ветка <tt>recover-branch</tt>, указывающая туда, куда ранее указывала <tt>master</tt>, и потерянные коммиты вновь доступны. Теперь, положим, потерянная ветка по какой-то причине не попала в reflog, для этого удалим восстановленную ветку и весь reflog. Теперь два первых коммита недоступны ниоткуда:</p>
<p><tt>$&nbsp;git&nbsp;branch&nbsp;-D&nbsp;recover-branch<br></br>$&nbsp;rm&nbsp;-Rf&nbsp;.git/logs/<br></br></tt></p>
<p>Теперь данные из <tt>.git/logs/</tt> удалены, а значит, и reflog больше нет, так как все его данные находились там. Как восстановить коммиты теперь? Один способ&nbsp;&mdash; использовать утилиту <tt>git fsck</tt>, проверяющую базу на целостность. Если выполнить её с ключом <tt>--full</tt>, будут показаны все объекты, недостижимые из других объектов:</p>
<p><tt>$&nbsp;git&nbsp;fsck&nbsp;--full<br></br>dangling&nbsp;blob&nbsp;d670460b4b4aece5915caf5c68d12f560a9fe3e4<br></br>dangling&nbsp;commit&nbsp;ab1afef80fac8e34258ff41fc1b867c702daa24b<br></br>dangling&nbsp;tree&nbsp;aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9<br></br>dangling&nbsp;blob&nbsp;7108f7ecb345ee9d0084193f147cdad4d2998293<br></br></tt></p>
<p>В данном случае потерянный коммит указан после слов "dangling commit" (dangling commit в пер. с англ. &mdash; "висячий" коммит). Его можно восстановить аналогичным образом, добавив ветку, указывающую на данный хеш.</p>
<p id="calibre_link-233"><span><span><b>Удаление объектов</b></span></span></p>
<p>У Git'а есть много замечательных особенностей, но одна из них способна вызвать проблемы&nbsp;&mdash; команда <tt>git clone</tt> загружает проект вместе со всей историей, включая все версии всех файлов. Это нормально, если в репозитории хранится только исходный код, так как Git хорошо оптимизирован под такой тип данных и может эффективно сжимать их. Однако, если когда-либо в проект был добавлен большой файл, каждый, кто потом захочет клонировать проект, будет вынужден скачивать этот большой файл, даже если он был удалён в следующем же коммите. Он будет в базе всегда, просто потому, что он доступен в истории.</p>
<p>Это может стать огромной проблемой при конвертации репозиториев Subversion или Perforce в Git. В данных системах вам не нужно загружать всю историю, поэтому добавление больших бинарных файлов не имеет там особых последствий. Если при импорте из другой системы или при каких-либо других обстоятельствах стало ясно, что ваш репозиторий намного больше, чем он должен быть, то как раз сейчас мы расскажем как можно найти и удалить большие объекты.</p>
<p>Будьте внимательны, данный способ разрушителен по отношению к истории коммитов. Каждый коммит будет переписан, начиная с самого раннего, из которого вы удалите ссылку на большой файл. Если сделать это непосредственно после импорта, когда никто ещё не работал с репозиторием, всё хорошо, иначе придётся сообщать всем участникам разработки о необходимости перемещения их правок на новые коммиты.</p>
<p>Для примера добавим большой файл в свой тестовый репозиторий, удалим его в следующем коммите, а потом найдём и удалим его полностью из базы. Для начала добавим большой файл в нашу историю:</p>
<p><tt>$&nbsp;curl&nbsp;http://kernel.org/pub/software/scm/git/git-1.6.3.1.tar.bz2&nbsp;&gt;&nbsp;git.tbz2<br></br>$&nbsp;git&nbsp;add&nbsp;git.tbz2<br></br>$&nbsp;git&nbsp;commit&nbsp;-am&nbsp;'added&nbsp;git&nbsp;tarball'<br></br>[master&nbsp;6df7640]&nbsp;added&nbsp;git&nbsp;tarball<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;0&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br>&nbsp;create&nbsp;mode&nbsp;100644&nbsp;git.tbz2<br></br></tt></p>
<p>Упс, кажется, этот огромный архив нам в проекте не нужен. Избавимся от него:</p>
<p><tt>$&nbsp;git&nbsp;rm&nbsp;git.tbz2&nbsp;<br></br>rm&nbsp;'git.tbz2'<br></br>$&nbsp;git&nbsp;commit&nbsp;-m&nbsp;'oops&nbsp;-&nbsp;removed&nbsp;large&nbsp;tarball'<br></br>[master&nbsp;da3f30d]&nbsp;oops&nbsp;-&nbsp;removed&nbsp;large&nbsp;tarball<br></br>&nbsp;1&nbsp;files&nbsp;changed,&nbsp;0&nbsp;insertions(+),&nbsp;0&nbsp;deletions(-)<br></br>&nbsp;delete&nbsp;mode&nbsp;100644&nbsp;git.tbz2<br></br></tt></p>
<p>Теперь "соберём мусор" в базе и узнаем её размер:</p>
<p><tt>$&nbsp;git&nbsp;gc<br></br>Counting&nbsp;objects:&nbsp;21,&nbsp;done.<br></br>Delta&nbsp;compression&nbsp;using&nbsp;2&nbsp;threads.<br></br>Compressing&nbsp;objects:&nbsp;100%&nbsp;(16/16),&nbsp;done.<br></br>Writing&nbsp;objects:&nbsp;100%&nbsp;(21/21),&nbsp;done.<br></br>Total&nbsp;21&nbsp;(delta&nbsp;3),&nbsp;reused&nbsp;15&nbsp;(delta&nbsp;1)<br></br></tt></p>
<p>Чтобы быстро узнать, сколько у нас занято места, можно воспользоваться командой <tt>count-objects</tt>:</p>
<p><tt>$&nbsp;git&nbsp;count-objects&nbsp;-v<br></br>count:&nbsp;4<br></br>size:&nbsp;16<br></br>in-pack:&nbsp;21<br></br>packs:&nbsp;1<br></br>size-pack:&nbsp;2016<br></br>prune-packable:&nbsp;0<br></br>garbage:&nbsp;0<br></br></tt></p>
<p>Запись <tt>size-pack</tt>&nbsp;&mdash; это размер упакованных файлов в килобайтах, то есть всего занято 2 MБ. Перед последним коммитом использовалось около 2 КБ, то есть удаление файла не удалило его из истории. Из-за того, что мы однажды случайно добавили большой файл, при каждом клонировании этого репозитория каждому человеку придётся скачивать все эти 2 МБ, только для того, чтобы получить этот крошечный проект. Попробуем избавиться от этого файла.</p>
<p>Сперва найдём его. В данном случае, мы знаем, что это за файл. Но если бы не знали, как можно было бы определить, какие файлы занимают много места? При вызове <tt>git gc</tt> все объекты упаковываются в один файл, но, несмотря на это, определить самые крупные файлы можно, запустив служебную команду <tt>git verify-pack</tt>, и отсортировав её вывод по третьей колонке, в которой записан размер файла. К тому же, так как нас интересуют только самые крупные файлы, оставим только последние несколько строк, направив вывод команде <tt>tail</tt>:</p>
<p><tt>$&nbsp;git&nbsp;verify-pack&nbsp;-v&nbsp;.git/objects/pack/pack-3f8c0...bb.idx&nbsp;|&nbsp;sort&nbsp;-k&nbsp;3&nbsp;-n&nbsp;|&nbsp;tail&nbsp;-3<br></br>e3f094f522629ae358806b17daf78246c27c007b&nbsp;blob&nbsp;&nbsp;&nbsp;1486&nbsp;734&nbsp;4667<br></br>05408d195263d853f09dca71d55116663690c27c&nbsp;blob&nbsp;&nbsp;&nbsp;12908&nbsp;3478&nbsp;1189<br></br>7a9eb2fba2b1811321254ac360970fc169ba2330&nbsp;blob&nbsp;&nbsp;&nbsp;2056716&nbsp;2056872&nbsp;5401<br></br></tt></p>
<p>Большой объект в самом внизу, его размер&nbsp;&mdash; 2 МБ. Для того чтобы узнать, что это за файл, воспользуемся командой <tt>rev-list</tt>, которая уже упоминалась в главе 7. Если передать ей ключ <tt>--objects</tt>, то она выдаст хеши всех коммитов, а также хеши объектов и соответствующие им имена файлов. Воспользуемся этим для определения имени выбранного объекта:</p>
<p><tt>$&nbsp;git&nbsp;rev-list&nbsp;--objects&nbsp;--all&nbsp;|&nbsp;grep&nbsp;7a9eb2fb<br></br>7a9eb2fba2b1811321254ac360970fc169ba2330&nbsp;git.tbz2<br></br></tt></p>
<p>Теперь необходимо удалить данный файл из всех деревьев в прошлом по истории. Легко получить все коммиты, которые меняли данный файл:</p>
<p><tt>$&nbsp;git&nbsp;log&nbsp;--pretty=oneline&nbsp;--branches&nbsp;--&nbsp;git.tbz2<br></br>da3f30d019005479c99eb4c3406225613985a1db&nbsp;oops&nbsp;-&nbsp;removed&nbsp;large&nbsp;tarball<br></br>6df764092f3e7c8f5f94cbe08ee5cf42e92a0289&nbsp;added&nbsp;git&nbsp;tarball<br></br></tt></p>
<p>Необходимо переписать все коммиты, начиная с <tt>6df76</tt> для полного удаления данного файла. Для этого воспользуемся командой <tt>filter-branch</tt>, которая приводилась в главе 6:</p>
<p><tt>$&nbsp;git&nbsp;filter-branch&nbsp;--index-filter&nbsp;\<br></br>&nbsp;&nbsp;&nbsp;'git&nbsp;rm&nbsp;--cached&nbsp;--ignore-unmatch&nbsp;git.tbz2'&nbsp;--&nbsp;6df7640^..<br></br>Rewrite&nbsp;6df764092f3e7c8f5f94cbe08ee5cf42e92a0289&nbsp;(1/2)rm&nbsp;'git.tbz2'<br></br>Rewrite&nbsp;da3f30d019005479c99eb4c3406225613985a1db&nbsp;(2/2)<br></br>Ref&nbsp;'refs/heads/master'&nbsp;was&nbsp;rewritten<br></br></tt></p>
<p>Опция <tt>--index-filter</tt> похожа на <tt>--tree-filter</tt>, использовавшуюся в главе 6, за исключением того, что вместо передачи команды, модифицирующей файлы на диске, мы используем команду, изменяющую файлы в индексе. Вместо удаления файла чем-то вроде <tt>rm file</tt>, стоит сделать это командой <tt>git rm --cached</tt>, так как нам надо удалить файл из индекса, а не с диска. Причина, по которой мы делаем именно так,&nbsp;&mdash; скорость. Нет необходимости извлекать каждую ревизию на диск, чтобы применить фильтр, а это может очень сильно ускорить процесс. Можете использовать и <tt>tree-filter</tt> для получения аналогичного результата, если хотите. Опция <tt>--ignore-unmatch</tt> команды <tt>git rm</tt> отключает вывод сообщения об ошибке в случае отсутствия файлов, соответствующих шаблону. И последнее, команда <tt>filter-branch</tt> переписывает историю, начиная с коммита <tt>6df7640</tt>, потому что мы знаем, что именно с этого коммита появилась проблема. По умолчанию перезапись начинается с самого первого коммита, что потребовало бы гораздо больше времени.</p>
<p>Теперь наша история не содержит ссылок на данный файл. Однако, в reflog и в новом наборе ссылок, добавленном Git'ом в <tt>.git/refs/original</tt> после выполнения <tt>filter-branch</tt>, ссылки на него всё ещё присутствуют. Поэтому необходимо их удалить, а потом переупаковать базу. Необходимо избавиться от всех возможных ссылок на старые коммиты перед переупаковкой:</p>
<p><tt>$&nbsp;rm&nbsp;-Rf&nbsp;.git/refs/original<br></br>$&nbsp;rm&nbsp;-Rf&nbsp;.git/logs/<br></br>$&nbsp;git&nbsp;gc<br></br>Counting&nbsp;objects:&nbsp;19,&nbsp;done.<br></br>Delta&nbsp;compression&nbsp;using&nbsp;2&nbsp;threads.<br></br>Compressing&nbsp;objects:&nbsp;100%&nbsp;(14/14),&nbsp;done.<br></br>Writing&nbsp;objects:&nbsp;100%&nbsp;(19/19),&nbsp;done.<br></br>Total&nbsp;19&nbsp;(delta&nbsp;3),&nbsp;reused&nbsp;16&nbsp;(delta&nbsp;1)<br></br></tt></p>
<p>Посмотрим, сколько места удалось сохранить:</p>
<p><tt>$&nbsp;git&nbsp;count-objects&nbsp;-v<br></br>count:&nbsp;8<br></br>size:&nbsp;2040<br></br>in-pack:&nbsp;19<br></br>packs:&nbsp;1<br></br>size-pack:&nbsp;7<br></br>prune-packable:&nbsp;0<br></br>garbage:&nbsp;0<br></br></tt></p>
<p>Размер упакованного репозитория сократился до 7 КБ, что намного лучше, чем 2 МБ. Из значения поля size видно, что большой объект всё ещё хранится в одном из ваших "рыхлых" объектов, но, что самое важное, при любой последующей отправке данных наружу и в том числе при клонировании он передаваться не будет. Если очень хочется, можно удалить его навсегда локально, выполнив <tt>git prune --expire</tt>.</p>
<div></div><p id="calibre_link-234"><span><span><b>Итоги</b></span></span></p>
<p>Теперь вы довольно хорошо понимаете, что Git делает в фоне и, в некоторой степени, как он написан. В данной главе мы рассмотрели несколько служебных команд&nbsp;&mdash; простых команд, работающих на более низком уровне, чем обычные пользовательские команды, описанные в остальной части книги. Понимание принципов работы Git'а на низком уровне упрощает понимание работы Git'а в целом и даёт возможность написания собственных утилит и сценариев для организации специфического процесса работы с Git'ом.</p>
<p>Git как контентно-адресуемая файловая система &mdash; это очень мощный инструмент, который можно использовать не только как систему контроля версий. Надеюсь, полученное знание внутренней реализации Git'а поможет вам в написании ваших собственных интересных приложений, использующих данные технологии, и сделает вашу работу с Git'ом более продвинутой и комфортной.</p>
<div></div><p id="calibre_link-235"><span><span><b>Содержание</b></span></span></p>
<p><a href="#calibre_link-1">Введение</a></p>
<blockquote><blockquote><a href="#calibre_link-2">О контроле версий</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-3">Локальные системы контроля версий</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-4">Централизованные системы контроля версий</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-5">Распределённые системы контроля версий</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-6">Краткая история Git</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-7">Основы Git</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-8">Слепки вместо патчей</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-9">Почти все операции &mdash; локальные</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-10">Git следит за целостностью данных</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-11">Чаще всего данные в Git только добавляются</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-12">Три состояния</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-13">Установка Git</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-14">Установка из исходников</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-15">Установка в Linux</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-16">Установка на Mac</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-17">Установка в Windows</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-18">Первоначальная настройка Git</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-19">Имя пользователя</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-20">Выбор редактора</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-21">Утилита сравнения</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-22">Проверка настроек</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-23">Как получить помощь?</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-24">Итоги</a></blockquote></blockquote><p><a href="#calibre_link-25">Основы Git</a></p>
<blockquote><blockquote><a href="#calibre_link-26">Создание Git-репозитория</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-27">Создание репозитория в существующем каталоге</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-28">Клонирование существующего репозитория</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-29">Запись изменений в репозиторий</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-30">Определение состояния файлов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-31">Отслеживание новых файлов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-32">Индексация изменённых файлов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-33">Игнорирование файлов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-34">Просмотр индексированных и неиндексированных изменений</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-35">Фиксация изменений</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-36">Игнорирование индексации</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-37">Удаление файлов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-38">Перемещение файлов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-39">Просмотр истории коммитов</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-40">Ограничение вывода команды log</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-41">Использование графического интерфейса для визуализации истории</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-42">Отмена изменений</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-43">Изменение последнего коммита</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-44">Отмена индексации файла</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-45">Отмена изменений файла</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-46">Работа с удалёнными репозиториями</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-47">Отображение удалённых репозиториев</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-48">Добавление удалённых репозиториев</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-49">Fetch и Pull</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-50">Push</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-51">Инспекция удалённого репозитория</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-52">Удаление и переименование удалённых репозиториев</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-53">Работа с метками</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-54">Просмотр меток</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-55">Создание меток</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-56">Аннотированные метки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-57">Подписанные метки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-58">Легковесные метки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-59">Верификация меток</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-60">Выставление меток позже</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-61">Обмен метками</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-62">Полезные советы</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-63">Автоматическое дополнение</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-64">Псевдонимы в Git</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-65">Итоги</a></blockquote></blockquote><p><a href="#calibre_link-66">Ветвление в Git</a></p>
<blockquote><blockquote><a href="#calibre_link-67">Что такое ветка?</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-68">Основы ветвления и слияния</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-69">Основы ветвления</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-70">Основы слияния</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-71">Основы конфликтов при слиянии</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-72">Управление ветками</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-73">Приёмы работы с ветками</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-74">Долгоживущие ветки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-75">Тематические ветки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-76">Удалённые ветки</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-77">Отправка изменений</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-78">Отслеживание веток</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-79">Удаление веток на удалённом сервере</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-80">Перемещение</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-81">Основы перемещения</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-82">Более интересные перемещения</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-83">Возможные риски перемещения</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-84">Итоги</a></blockquote></blockquote><p><a href="#calibre_link-85">Git на сервере</a></p>
<blockquote><blockquote><a href="#calibre_link-86">Протоколы</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-87">Локальный протокол</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-88">Протокол SSH</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-89">Git-протокол</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-90">Протокол HTTP/S</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-91">Настройка Git на сервере</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-92">Размещение "голого" репозитория на сервере</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-93">Малые установки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-94">Создание открытого SSH-ключа</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-95">Настраиваем сервер</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-96">Открытый доступ</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-97">GitWeb</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-98">Gitosis</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-99">Gitolite</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-100">Установка</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-101">Изменение параметров установки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-102">Конфигурационный файл и правила контроля доступа</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-103">Продвинутый контроль доступа с запрещающими правилами</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-104">Ограничение push'ей на основе изменённых файлов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-105">Персональные ветки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-106">"Шаблонные" репозитории</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-107">Другие функции</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-108">Git-демон</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-109">Git-хостинг</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-110">GitHub</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-111">Настройка учётной записи</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-112">Создание нового репозитория</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-113">Импорт из Subversion</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-114">Добавление участников</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-115">Ваш проект</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-116">Ответвления проектов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-117">Заключение о GitHub</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-118">Итоги</a></blockquote></blockquote><p><a href="#calibre_link-119">Распределённый Git</a></p>
<blockquote><blockquote><a href="#calibre_link-120">Распределённые рабочие процессы</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-121">Централизованный рабочий процесс</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-122">Рабочий процесс с менеджером по интеграции</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-123">Рабочий процесс с диктатором и его помощниками</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-124">Содействие проекту</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-125">Рекомендации по созданию коммитов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-126">Отдельная маленькая команда</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-127">Отдельная команда с менеджером</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-128">Небольшой открытый проект</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-129">Большой открытый проект</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-130">Итоги</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-131">Сопровождение проекта</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-132">Работа с тематическими ветками</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-133">Применение патчей, отправленных по почте</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-134">Проверка удалённых веток</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-135">Определение вносимых изменений</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-136">Интегрирование чужих наработок</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-137">Отметка релизов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-138">Генерация номера сборки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-139">Подготовка релиза</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-140">Команда shortlog</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-141">Итоги</a></blockquote></blockquote><p><a href="#calibre_link-142">Инструменты Git</a></p>
<blockquote><blockquote><a href="#calibre_link-143">Выбор ревизии</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-144">Одиночные ревизии</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-145">Сокращённый SHA</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-146">Небольшое замечание о SHA-1</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-147">Ссылки на ветки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-148">RefLog-сокращения</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-149">Ссылки на предков</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-150">Диапазон коммитов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-151">Интерактивное индексирование</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-152">Добавление и удаление файлов из индекса</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-153">Индексирование по частям</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-154">Прятанье</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-155">Прятанье своих трудов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-156">Откат применения спрятанных изменений</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-157">Создание ветки из спрятанных изменений</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-158">Перезапись истории</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-159">Изменение последнего коммита</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-160">Изменение сообщений нескольких коммитов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-161">Переупорядочение коммитов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-162">Уплотнение коммитов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-163">Разбиение коммита</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-164">Крайнее средство: filter-branch</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-165">Отладка с помощью Git</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-166">Аннотация файла</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-167">Бинарный поиск</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-168">Подмодули</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-169">Начало использования подмодулей</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-170">Клонирование проекта с подмодулями</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-171">Суперпроекты</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-172">Проблемы с подмодулями</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-173">Слияние поддеревьев</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-174">Итоги</a></blockquote></blockquote><p><a href="#calibre_link-175">Настройка Git</a></p>
<blockquote><blockquote><a href="#calibre_link-176">Конфигурирование Git</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-177">Основные настройки клиента</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-178">Цвета в Git</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-179">Внешние утилиты merge и diff</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-180">Форматирование и пробельные символы</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-181">Настройка сервера</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-182">Git-атрибуты</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-183">Бинарные файлы</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-184">Развёртывание ключа</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-185">Экспорт репозитория</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-186">Стратегии слияния</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-187">Перехватчики в Git</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-188">Установка перехватчика</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-189">Перехватчики на стороне клиента</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-190">Перехватчики на стороне сервера</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-191">Пример навязывания политики с помощью Git</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-192">Перехватчик на стороне сервера</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-193">Перехватчики на стороне клиента</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-194">Итоги</a></blockquote></blockquote><p><a href="#calibre_link-195">Git и другие системы контроля версий</a></p>
<blockquote><blockquote><a href="#calibre_link-196">Git и Subversion</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-197">git svn</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-198">Настройка</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-199">Приступим к работе</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-200">Коммит в Subversion</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-201">Получение новых изменений</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-202">Проблемы с ветвлением в Git</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-203">Ветвление в Subversion</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-204">Переключение активных веток</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-205">Команды Subversion</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-206">Заключение по Git-Svn</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-207">Миграция на Git</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-208">Импортирование</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-209">Subversion</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-210">Perforce</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-211">Собственная утилита для импорта</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-212">Итоги</a></blockquote></blockquote><p><a href="#calibre_link-213">Git изнутри</a></p>
<blockquote><blockquote><a href="#calibre_link-214">Сантехника и фарфор</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-215">Объекты в Git</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-216">Объекты-деревья</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-217">Объекты-коммиты</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-218">Хранение объектов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-219">Ссылки в Git</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-220">HEAD</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-221">Метки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-222">Ссылки на удалённые ветки</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-223">Pack-файлы</a></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-224">Спецификации ссылок</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-225">Спецификации ссылок для команды push</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-226">Удаление ссылок</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-227">Протоколы передачи</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-228">Тупой протокол</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-229">Умный протокол</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-230">Обслуживание и восстановление данных</a></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-231">Обслуживание</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-232">Восстановление данных</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><a href="#calibre_link-233">Удаление объектов</a></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><a href="#calibre_link-234">Итоги</a></blockquote></blockquote><div></div><a></a>
<a></a>
<a></a></div>

</body></html>
